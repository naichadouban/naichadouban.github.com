---
title: btcd里的优秀代码总结
date: 2019-06-06
tags: ["btcd","golang"]
categories: ["btcd","golang"]
---

## service的定义，判断，添加
定义的时候会进行移位操作，这样每一种服务就代表了一位。
```
const (
	// 节点可以被请求全节点。实现了当前版本的所有功能
	SFNodeNetwork ServiceFlag = 1 << iota
)
```

然后判断节点有没有一个服务，直接进行与操作。
```
func (msg *MsgVersion) HasService(service ServiceFlag) bool {
	if msg.Services&service == service {
		return true
	}
	return false
}
```
添加服务
```
func (msg *MsgVersion) AddService(service ServiceFlag) {
	msg.Services |= service
}
```
直接进行或运算就可以
> note:
1.扩展下可以用日志等级
2.可以用在权限系统

## golang随机数
利用rand包
```
// randomUint64 returns a cryptographically random uint64 value.  This
// unexported version takes a reader primarily to ensure the error paths
// can be properly tested by passing a fake reader in the tests.
func randomUint64(r io.Reader) (uint64, error) {
	var b [8]byte
	_, err := io.ReadFull(r, b[:])
	if err != nil {
		return 0, err
	}
	return binary.BigEndian.Uint64(b[:]), nil
}

// RandomUint64 returns a cryptographically random uint64 value.
func RandomUint64() (uint64, error) {
	return randomUint64(rand.Reader)
}
```
关键点就是`rand`包给我们提供了`io.Reader`,我们从这个`reader`里读到的都是随机的。

## 判断两个结构体对象是否相同

```
if !reflect.DeepEqual(na,test.out){
	t.Errorf("readNetAddress #%d\n got: %s want: %s", i,
		spew.Sdump(na), spew.Sdump(test.out))
	continue
}
```
就是利用`reflect.DeepEqual()`

## golang生成证书

```golang

// generateRPCKeyPair generates a new RPC TLS keypair and writes the cert and
// possibly also the key in PEM format to the paths specified by the config.  If
// successful, the new keypair is returned.
func generateRPCKeyPair(writeKey bool) (tls.Certificate, error) {
	log.Infof("Generating TLS certificates...")

	// Create directories for cert and key files if they do not yet exist.
	certDir, _ := filepath.Split(cfg.RPCCert.Value)
	keyDir, _ := filepath.Split(cfg.RPCKey.Value)
	err := os.MkdirAll(certDir, 0700)
	if err != nil {
		return tls.Certificate{}, err
	}
	err = os.MkdirAll(keyDir, 0700)
	if err != nil {
		return tls.Certificate{}, err
	}

	// Generate cert pair.
	org := "hcwallet autogenerated cert"
	validUntil := time.Now().Add(time.Hour * 24 * 365 * 10)
	cert, key, err := hcutil.NewTLSCertPair(cfg.TLSCurve.Curve(), org,
		validUntil, nil)
	if err != nil {
		return tls.Certificate{}, err
	}
	keyPair, err := tls.X509KeyPair(cert, key)
	if err != nil {
		return tls.Certificate{}, err
	}

	// Write cert and (potentially) the key files.
	err = ioutil.WriteFile(cfg.RPCCert.Value, cert, 0600)
	if err != nil {
		return tls.Certificate{}, err
	}
	if writeKey {
		err = ioutil.WriteFile(cfg.RPCKey.Value, key, 0600)
		if err != nil {
			rmErr := os.Remove(cfg.RPCCert.Value)
			if rmErr != nil {
				log.Warnf("Cannot remove written certificates: %v",
					rmErr)
			}
			return tls.Certificate{}, err
		}
	}

	log.Info("Done generating TLS certificates")
	return keyPair, nil
}
```
