<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[grin交易流程深入分析]]></title>
    <url>%2F2019%2F02%2F27%2Fgrin-2019-02-27-grin%E4%BA%A4%E6%98%93%E6%B5%81%E7%A8%8B%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Grin is an exciting new cryptocurrency leveraging the MimbleWimble protocol. But tutorials on Grin are notoriously nondescript. 这篇文章旨在确切的分享grin的交易过程。 在grin中，一个输出就是一个Pedersen Commitment,任何输出都呈现下面的形式： Pedersen Commitment(Pedersen 承诺)用一种和聪明的方式隐藏了信息。如果你是刚听说commitments（承诺）， 那看到它把它理解成shielded value(屏蔽值)就可以了。 下面的内容来Grin wiki，对理解这篇文章来说是很好的入门。 • 如果选择一个很大的数k作为私钥，k*H就是对应的公钥。即使一个人知道公钥k*H值，想推导出k几乎不可能 • r是被用作致盲因子的私钥，G是椭圆曲线上的固定点，它们的乘积r*G是r在曲线上的公钥。 • v 是输入或输出的金额，H是椭圆曲线上的另一个固定点。 (k+j)*H = k*H + j*H，k和j都是私钥。等式表明从两个私钥的和获取公钥（k + j）* H，等价于每个私钥的对应公钥的和 （k * H + j * H） 更深入的密码学研究可以在这里ECC primer找到。但简而言之，要花费Grin的输出，你必须知道致盲因子（r）和Grin（v）的数量。要解构承诺来推断这些值是不可能的。你必须提前知道它们。 致盲因素的存在是因为有人支付给你这些grin，他也会知道v的值（他给你发送了多少grin）。但只有你（甚至都不是Grin的发送者）将会知道这个输出的致盲因子，因此只有你能够花掉这个输出。 假设此输出使用致盲因子20，此输出包含40 Grin。（注意： Grin的数量实际上是以原子单位1 NanoGrin的倍数发送的。在这里直接使用grin简化了）： 如果我们看Grin 区块链浏览器，输出不会像上面那样优雅的分解。就像我们所说的，这才是Grin真正输出的样子， 再重复一次，从这个输出中推导出20(致盲因子)或者40(grin 数量)是不可能的。 花费输出假设刚才展示的输出属于Alice。现在，Alice希望将40个Grin中的25个发送给Bob。为简单起见，我们会忽略挖矿费。 假如您有5美元，购买3美元的东西，您将获得2美元的找零。比特币交易是这样的，Grin也不例外。如果Alice想要从她40个未花费的Grin输出中向Bob发送25个Grin，她也会在同一笔交易中创建一个输出，把剩余的15个 Grin（她的零钱）返还自己。 这15个Grin将会返还Alice，这意味着只有她能够控制它并再次花费它。换句话说，Bob不应该花费Alice的找零。为此，Alice必须为她的找零输出创建一个新的致盲因子。假设Alice选择34。 Alice知道r（为她找零输出的致盲因子）和 v（她找零的grin的数量），她拥有创建找零输出（co）所需的一切。这将作为一个输出记录在区块链上，就像Alice创建的将25个Grin发送给Bob的输出一样。 正如我之前提到的，要花费任何输出，您必须知道该输出中使用的致盲因子。Alice知道她想要花费的输出中所使用的致盲因素（20），但她需要一种方法向所有人证明她知道。 这就是为什么她需要创建一个完全独立的计算，就是致盲因子的和。这涉及到Alice刚才为她的找零输出采用的致盲因子（34），并从中减去她想要花费的输出的致盲因子（20）。 rs（s表示发送者，现在是Alice）是Alice所有致盲因子的总和，现在的情况下它是14。（Note: I am intentionally leaving out kernel offsets）。 Alice做的就是创建一个随机的nonce ks（再次说明，s表示发送者）。她将使用这个随机的nonce来帮助她对这笔交易签名，我们稍后将会展示。Alice不会将实际的nonce发送给Bob。相反，她发送ks•G，这是对该nonce 的承诺。如前所述，通过将nonce乘以生成点G，Alice屏蔽了她实际的nonce值。 Alice将以下信息发送给Bob。实际上，Grin数据不会区分“Metadata”和“Data”字段，这里只是为了清楚的显示。 Metadata中的数据： Amount to send: Alice想要发送给Bob的grin数量（现在是25）。 TX UUID: Alice和Bob用于在来回发送数据时，标识此交易的唯一标识符。 TX fee: 交易费（这篇文章先不讨论）。 lock_height: 区块数，在此之后交易将有效。 Data中的数据 TX Inputs: Alice为她给Bob的交易的使用的未花费输入。 co: Alice的找零输出 ks • G: Alice的nonce变成对应的承诺通过乘以生成点G. rs • G*: Alice致盲因子的和对应的承诺通过乘以生成点G. Alice将所有这些发送给Bob，Bob继续下一步。 Bob的回合一旦从Alice接收到该数据后，Bob将TX fee和lock_height连接起来以创建M，称为交易的“Message”。 Bob为他希望从Alice哪里收到的25个grin选择一个致盲因子rr（r表示接受者，在这里是Bob）。假设他选择 11。他还选择了他自己的随机的nonce kr（r表示接受者）。 就像Alice一样，Bob通过将每个值乘以生成点G来创建对这两个值的承诺。使用这些值，Bob 为此交易生成 Schnorr challenge，由变量e表示： Schnorr challenge由以下值的 SHA256 hash组成： 交易的message。 Alice和Bob使用的nonce对应承诺的和。 Bob的致盲因子（为他25个grin的输出）对应的承诺 + Alice致盲因子和对应的承诺。 Bob使用e为此交易生成他的Schnorr signature ，简称sr（r为收件人）。虽然它是Bob签名的全部，但我们称之为Bob方签名，因为它最终将被添加到Alice方签名中来创建整个交易的签名。 当Alice最终收到sr时，她将无法从中推断出kr或rr的值。 Bob将以下内容发送回Alice包括： sr: Bob方的签名 kr • G： Bob的nonce对应的承诺 rr • G： Bob为他期望收到的25个grin选择的致盲因子对应的承诺。 最后一步：返回给AliceAlice现在有所需的一切，她也需要计算e（这笔交易的Schnorr challenge）。在本地计算e之后，Alice就可以验证Bob方的签名。回顾一下Bob方的签名sr,由一下组成： 基于我们前面描述的椭圆曲线的性质，Alice可以将生成点G 引入等式的两边，等式任然成立。 由于Alice收到了Bob的kr • G（Bob的nonce对应的承诺）和rr•G（Bob为他期望收到的25个Grin选择的致盲因子对应的承诺），并且因为她已经在本地计算了e，所以Alice验证Bob方签名sr，通过简单地将它乘以生成器G并确保等式的右边等于该值。通过这样做，Alice证明： Bob知道他将收到多少grin Bob知道他的nonce Bob知道他期望收到的25grin的致盲因子 Alice并不知道Bob的nonce和他选择的致盲因子。 然后Alice生成自己方的签名： Alice现在可以生成整个交易的签名，该签名包括她和Bob的签名： 签名包括 Alice和Bob方签名的和 Alice和Bob的nonces对应的承诺（他们都不知道对方真正的nonce） 再简明一点，它可以是这样： 其中 s = ss + sr ，k = ks + kr. 记住这个签名，它马上会很有意义。 完成交易数字货币需要一个”memory” , 也就是说，当你向一个人转账后，你不能将同样的钱再发给别人。在Grin中，我们隐藏了发送的Grin数和接受者。那么我们怎么能证明没有钱被双花或者凭空产生呢？ 在Grin交易中，当您从输入中减去所有输出时，剩余的Grin数应该等于0。回到刚才的5美元的比喻，有下面的公式： 3 dollars to cashier (output) + 2 dollars in change back to me (output) - 5 dollar bill (input) = 0 在Grin中，当交易合法时，相同的求和使v值总和为零。但是，我们如何在不知道value的情况下证明这一点？让我们看一下从Alice到Bob的交易中使用的输入和输出： （34•G）+（15•H）+（11•G）+（25•H） - （20•G） - （40•H）=（25•G）+（0•H） 这里比较巧妙的属性是，当Grin金额抵消时（因为没有钱是凭空创造的），从输入中减去输出所剩下的全部是“the excess blinding factor” 的承诺，或者“kernel excess”。这个“the excess blinding factor”的承诺，现在是25•G，就是椭圆曲线上的公钥。 如果Grin交易的输出总和减去输入的总和会在曲线上产生有效的公钥，你便知道v值肯定已经抵消了。如果等式的右边不是n•G + 0•H的形式 【for some known value of n】 ，你便知道该交易无效。这意味着花费的金额大于输入金额（例如，您提供5美元的账单，向收银员支付3美元，并在找零中获得10美元），或者输入大于输出（例如，您提供5美元的账单，向收银员支付3美元，并且没有找零）。 记得之前的签名吗？ 这个签名实际上已经签署了我刚刚提到的excess blinding factor对应的承诺。这是如何做的？ 如果你还记得，当你用生成器G乘以等式的两边时，这就是Bob方签名。 类似地，当你用生成器G乘以等式两边时，Alice方签名就是这样：如果将两个方程式加在一起会发生什么？你会得到： sr•G + ss•G =（kr•G）+（ks•G）+（e•（rr•G + rs•G）） 请记住，rr是Bob的致盲因子，rs是Alice的盲目因子之和。还需要记住rr•G + rs•G 和 (rr + rs)•G是等价的。 Bob的致盲因子对应的承诺是11•G。Alice所有致盲因子的和对应的承诺是14•G。将它们加在一起得到25•G，这是交易的 excess blinding factor对应的承诺。因此，添加sr和ss（ Bob和Alice各自的部分签名）证明了整个交易的有效性，因为它们加起来是 excess blinding factor对应的承诺。Further simplifying that equation, we get:进一步简化该等式，我们得到： sr•G + ss•G = (k•G) + (e • (r•G)) 或者 sr•G + ss•G = (k•G) + (e • (25•G)) 剩下要做的就是检查等式左侧等于右侧。 请记住，这个等式中的所有内容（双方签名的和，e中的所有内容， excess blinding factor对应的承诺，nonce和对应的承诺）都是公开可见的，因此任何人都可以进行此验证。我们不需要Alice和Bob的致盲因子来验证交易。By adding their partial signatures and verifying that they summed to the commitment to the excess blinding factor，我们证明： 再花费Alice之前的输入时，没有钱凭空产生。 Alice and Bob both knew the blinding factors for their outputs when they created this transaction. This means the new outputs are spendable by them, and not lost to the abyss.Alice和Bob都知道他们的输出对应的致盲因子。这意味着他们可以花费新的输出，而不是丢失【这里翻译不好】 我们用来验证交易的信息放在所谓的transaction kernel中了。 交易核除了输出之外，transaction kernel（交易核）是从Grin交易中产生的另一块信息。每个交易都会产生一个transaction kernel（交易核），但是没有办法通过Grin区块链将输出和交易核关联起来。每个Grin交易都存在一个，它包含没有钱凭空产生的证明。 下面的信息存储来交易核中： 交易的签名(s, k • G) 和“excess blinding factor” 相关联的公钥（这里指25•G），如上所述，它可以用来验证s。 交易的交易费和锁定高度(注意:如果这是Coinbase交易，那么这些交易都不存在). 总结After all this is said and done, the only things broadcast to the network from the transaction are:完成所有这些之后，只把交易的以下内容向网络广播： 所用的输入 新的输出 交易核 核偏移 (这篇文章没有讲到). None of the transaction metadata from earlier are relayed. Even better, some of this information may get discarded, too — but we will save that for another post. 希望这篇文章能够说明Grin交易是如何运作的。我遗漏了范围证明，内核偏移和交易费用。请留意更多关于Grin如何实现切入工作的帖子，多参与者交易的外观以及一些实验性功能。Look out for more posts on how cut-through works in Grin, what multi-participant transactions look like, and some experimental features. 原文链接: https://medium.com/@brandonarvanaghi/grin-transactions-explained-step-by-step-fdceb905a853作者: Brandon Arvanaghi 翻译&amp;校对: 徐晓峰]]></content>
      <categories>
        <category>grin</category>
      </categories>
      <tags>
        <tag>grin</tag>
        <tag>交易</tag>
        <tag>Mimblewimble</tag>
        <tag>区块链blockchain</tag>
        <tag>隐私交易</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Simple Golang HTTPS/TLS Examples]]></title>
    <url>%2F2019%2F02%2F20%2Fgolang-2019-02-20-Simple-Golang-HTTPS-TLS-Examples%2F</url>
    <content type="text"><![CDATA[Generate private key (.key)123456# Key considerations for algorithm &quot;RSA&quot; ≥ 2048-bitopenssl genrsa -out server.key 2048# Key considerations for algorithm &quot;ECDSA&quot; ≥ secp384r1# List ECDSA the supported curves (openssl ecparam -list_curves)openssl ecparam -genkey -name secp384r1 -out server.key Generation of self-signed(x509) public key (PEM-encodings .pem|.crt) based on the private (.key)1openssl req -new -x509 -sha256 -key server.key -out server.crt -days 3650 Simple Golang HTTPS/TLS Server1234567891011121314151617181920212223package mainimport ( // "fmt" // "io" "net/http" "log")func HelloServer(w http.ResponseWriter, req *http.Request) &#123; w.Header().Set("Content-Type", "text/plain") w.Write([]byte("This is an example server.\n")) // fmt.Fprintf(w, "This is an example server.\n") // io.WriteString(w, "This is an example server.\n")&#125;func main() &#123; http.HandleFunc("/hello", HelloServer) err := http.ListenAndServeTLS(":443", "server.crt", "server.key", nil) if err != nil &#123; log.Fatal("ListenAndServe: ", err) &#125;&#125; Hint: visit, please do not forget to use https begins,otherwise chrome will download a file as follows: 12$ curl -sL https://localhost:443 | xxd0000000: 1503 0100 0202 0a ....... TLS (transport layer security) — Server12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package mainimport ( "log" "crypto/tls" "net" "bufio")func main() &#123; log.SetFlags(log.Lshortfile) cer, err := tls.LoadX509KeyPair("server.crt", "server.key") if err != nil &#123; log.Println(err) return &#125; config := &amp;tls.Config&#123;Certificates: []tls.Certificate&#123;cer&#125;&#125; ln, err := tls.Listen("tcp", ":443", config) if err != nil &#123; log.Println(err) return &#125; defer ln.Close() for &#123; conn, err := ln.Accept() if err != nil &#123; log.Println(err) continue &#125; go handleConnection(conn) &#125;&#125;func handleConnection(conn net.Conn) &#123; defer conn.Close() r := bufio.NewReader(conn) for &#123; msg, err := r.ReadString('\n') if err != nil &#123; log.Println(err) return &#125; println(msg) n, err := conn.Write([]byte("world\n")) if err != nil &#123; log.Println(n, err) return &#125; &#125;&#125; TLS (transport layer security) — Client123456789101112131415161718192021222324252627282930313233343536package mainimport ( "log" "crypto/tls")func main() &#123; log.SetFlags(log.Lshortfile) conf := &amp;tls.Config&#123; //InsecureSkipVerify: true, &#125; conn, err := tls.Dial("tcp", "127.0.0.1:443", conf) if err != nil &#123; log.Println(err) return &#125; defer conn.Close() n, err := conn.Write([]byte("hello\n")) if err != nil &#123; log.Println(n, err) return &#125; buf := make([]byte, 100) n, err = conn.Read(buf) if err != nil &#123; log.Println(n, err) return &#125; println(string(buf[:n]))&#125; Perfect SSL Labs Score with Go123456789101112131415161718192021222324252627282930313233package mainimport ( "crypto/tls" "log" "net/http")func main() &#123; mux := http.NewServeMux() mux.HandleFunc("/", func(w http.ResponseWriter, req *http.Request) &#123; w.Header().Add("Strict-Transport-Security", "max-age=63072000; includeSubDomains") w.Write([]byte("This is an example server.\n")) &#125;) cfg := &amp;tls.Config&#123; MinVersion: tls.VersionTLS12, CurvePreferences: []tls.CurveID&#123;tls.CurveP521, tls.CurveP384, tls.CurveP256&#125;, PreferServerCipherSuites: true, CipherSuites: []uint16&#123; tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384, tls.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA, tls.TLS_RSA_WITH_AES_256_GCM_SHA384, tls.TLS_RSA_WITH_AES_256_CBC_SHA, &#125;, &#125; srv := &amp;http.Server&#123; Addr: ":443", Handler: mux, TLSConfig: cfg, TLSNextProto: make(map[string]func(*http.Server, *tls.Conn, http.Handler), 0), &#125; log.Fatal(srv.ListenAndServeTLS("tls.crt", "tls.key"))&#125; Generation of self-sign a certificate with a private (.key) and public key (PEM-encodings .pem|.crt) in one command:123456789101112# ECDSA recommendation key ≥ secp384r1# List ECDSA the supported curves (openssl ecparam -list_curves)openssl req -x509 -nodes -newkey ec:secp384r1 -keyout server.ecdsa.key -out server.ecdsa.crt -days 3650# openssl req -x509 -nodes -newkey ec:&lt;(openssl ecparam -name secp384r1) -keyout server.ecdsa.key -out server.ecdsa.crt -days 3650# -pkeyopt ec_paramgen_curve:… / ec:&lt;(openssl ecparam -name …) / -newkey ec:…ln -sf server.ecdsa.key server.keyln -sf server.ecdsa.crt server.crt# RSA recommendation key ≥ 2048-bitopenssl req -x509 -nodes -newkey rsa:2048 -keyout server.rsa.key -out server.rsa.crt -days 3650ln -sf server.rsa.key server.keyln -sf server.rsa.crt server.crt .crt — Alternate synonymous most common among *nix systems .pem (pubkey). .csr — Certficate Signing Requests (synonymous most common among *nix systems). .cer — Microsoft alternate form of .crt, you can use MS to convert .crt to .cer (DER encoded .cer, or base64[PEM] encoded .cer). .pem = The PEM extension is used for different types of X.509v3 files which contain ASCII (Base64) armored data prefixed with a «—– BEGIN …» line. These files may also bear the cer or the crt extension. .der — The DER extension is used for binary DER encoded certificates. Generating the Certficate Signing Requestopenssl req -new -sha256 -key server.key -out server.csr openssl x509 -req -sha256 -in server.csr -signkey server.key -out server.crt -days 3650 ECDSA &amp; RSA — FAQ Validate the elliptic curve parameters -check List “ECDSA” the supported curves openssl ecparam -list_curves Encoding to explicit “ECDSA” -param_enc explicit Conversion form to compressed “ECDSA” -conv_form compressed “EC” parameters and a private key -genkey CA Bundle Path Distro Package Path to CA Fedora, RHEL, CentOS ca-certificates /etc/pki/tls/certs/ca-bundle.crt Debian, Ubuntu, Gentoo, Arch Linux ca-certificates /etc/ssl/certs/ca-certificates.crt SUSE, openSUSE ca-certificates /etc/ssl/ca-bundle.pem FreeBSD ca_root_nss /usr/local/share/certs/ca-root-nss.crt Cygwin - /usr/ssl/certs/ca-bundle.crt macOS (MacPorts) curl-ca-bundle /opt/local/share/curl/curl-ca-bundle.crt Default cURL CA bunde path (without –with-ca-bundle option) /usr/local/share/curl/curl-ca-bundle.crt Really old RedHat? /usr/share/ssl/certs/ca-bundle.crt Reference Link Achieving a Perfect SSL Labs Score with Go – blog.bracelab.com OpenSSL without prompt – superuser.com (Stack Exchange) TLS server and client — gist.github.com/spikebike Echo, a fast and unfancy micro web framework for Go — echo.labstack.com/guide https://kjur.github.io/jsrsasign/sample-ecdsa.html Creating Self-Signed ECDSA SSL Certificate using OpenSSL – guyrutenberg.com https://www.openssl.org/docs/manmaster/ https://www.openssl.org/docs/manmaster/man1/ecparam.html https://www.openssl.org/docs/manmaster/man1/ec.html https://www.openssl.org/docs/manmaster/man1/req.html https://digitalelf.net/2016/02/creating-ssl-certificates-in-3-easy-steps/ HTTPS and Go – kaihag.com The complete guide to Go net/http timeouts – blog.cloudflare.com Certificate fetcher in Go – gist.github.com How to redirect HTTP to HTTPS with a golang webserver – gist.github.com XCA - X Certificate and key management Package tcplisten provides customizable TCP net.Listener with various performance-related options https://github.com/bifurcation/mint — minimal TLS 1.3 Implementation in Go https://github.com/cloudflare/tls-tris — crypto/tls, now with 100% more 1.3 https://github.com/Xeoncross/secureserver https://github.com/cloudflare/cfssl https://github.com/google/certificate-transparency https://cipherli.st/ https://github.com/cmrunton/tls-dashboard — dashboard written in JavaScript &amp; HTML to check the remaining time before a TLS certificate expires. https://github.com/tomato42/tlsfuzzer https://github.com/mozilla/tls-observatory (https://observatory.mozilla.org/) https://dev.ssllabs.com/ssltest/ https://indieweb.org/HTTPS https://github.com/konklone/shaaaaaaaaaaaaa (https://shaaaaaaaaaaaaa.com/) https://securityheaders.io/ https://testssl.sh/ https://github.com/nabla-c0d3/sslyze https://github.com/iSECPartners/sslyze https://github.com/mozilla/cipherscan https://github.com/ssllabs/ssllabs-scan https://github.com/chromium/badssl.com (https://badssl.com) https://github.com/datatheorem/TrustKit https://github.com/certifi/gocertifi … 原文链接https://gist.github.com/denji/12b3a568f092ab951456]]></content>
      <categories>
        <category>golang学习</category>
      </categories>
      <tags>
        <tag>https</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解base64]]></title>
    <url>%2F2019%2F02%2F20%2Fcomputer-2019-02-20-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3base64%2F</url>
    <content type="text"><![CDATA[base64base64简单介绍base64是一种可逆的编码方式。 简单来说，base64一种用64个Ascii字符来表示任意二进制数据的方法，就是表示二进制数据，用自己设定的64个字符。主要用于将不可打印的字符转化成可打印的字符。或者简单的说将二进制数据编码成Ascii字符。Base64是网络上最常用的传输8bit字节数据的编码方式之一 base64表 Base64的原理其实很简单，首先，需要准备一个包含64个字符的表格（如下表），0～63分别对应了唯一一个字符，比如18对应的是S。 base64编码过程对二进制数据进行处理，每3个字节一组，一共3x8=24bit，将这24bit划分为4组，每组正好6个bit，6bit的数据刚好可以表示0～63的范围，也就可以对应上表的64个字符。这样我们就得到了4个数字作为索引，然后查表获得相应的4个字符，就得到了编码后的字符串。 比如现在要编码Man三个字符，我们需要先根据ascii编码转化成二进制数据，然后再对照base64编码，将二进制数据映射到base64字符上 base64后面为什么会有等号(=)?Base64编码会把3字节的二进制数据编码为4字节的文本数据，长度增加为原来的4/3。如果要编码的二进制数据不是3的倍数，最后会剩下1个或2个字节怎么办？此时，需在原数据后面添加1个或2个零值字节，使其字节数是3的倍数。然后，在编码后的字符串后面添加1个或2个等号“=”，表示所添加的零值字节数。解码的时候，会自动去掉. base64优缺点优点：可以将二进制数据转换成可打印字符，方便传输数据；对数据进行简单的加密，肉眼安全。缺点：内容编码后的体积会变大，编码和解码需要额外的工作量。 它的使用场景有很多，比如将图片等资源文件以Base64编码形式直接放于代码中，使用的时候反Base64后转换成Image对象使用；有些文本协议不支持不可见字符的传递，只能转换成可见字符来传递信息。有时在一些特殊的场合，大多数消息是纯文本的，偶尔需要用这条纯文本通道传一张图片之类的情况发生的时候，就会用到Base64，比如多功能Internet 邮件扩充服务（MIME）就是用Base64对邮件的附件进行编码的。 base58base58介绍和通常base64编码一样，base58编码的作用也是将非可视字符可视化（ASCII化） 和base64的区别不同的是base58编码去掉了几个看起来会产生歧义的字符，如 0 (零), O (大写字母O), I (大写的字母i) and l (小写的字母L) ，和几个影响双击选择的字符，如/, +。结果字符集正好58个字符(包括9个数字，24个大写字母，25个小写字母) 而且因为58 不是2的整次幂，所以没有使用类似base64编码中使用直接截取3个字符转4个字符（38=46 , 2的6次方刚好64）的方法进行转换，而是采用我们数学上经常使用的进制转换方法——辗转相除法（本质上，base64编码是64进制，base58是58进制） base58表也就是字符1代表0，字符2代表1,字符3代表2…字符z代表57。然后回一下辗转相除法。 如要将1234转换为58进制； 第一步：1234除于58，商21，余数为16，查表得H 第二步：21除于58，商0，余数为21，查表得N 所以得到base58编码为：NH 提示写代码时，可以直接跳入到base64和base58的Encode()和Decode()代码中看源码实现。]]></content>
      <categories>
        <category>computer</category>
        <category>base编码</category>
      </categories>
      <tags>
        <tag>base64</tag>
        <tag>base58</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从Dart看js中的async和await]]></title>
    <url>%2F2019%2F02%2F13%2Fjs-2019-02-13-%E4%BB%8EDart%E7%9C%8Bjs%E4%B8%AD%E7%9A%84async%E5%92%8Cawait%2F</url>
    <content type="text"><![CDATA[今天看Dart的时候，看到下面的解释原文地址：https://juejin.im/post/5b5005866fb9a04fea589561#heading-9 Dart提供了类似ES7中的async await等异步操作，这种异步操作在Flutter开发中会经常遇到，比如网络或其他IO操作，文件选择等都需要用到异步的知识。async和await往往是成对出现的，如果一个方法中有耗时的操作，你需要将这个方法设置成async，并给其中的耗时操作加上await关键字，如果这个方法有返回值，你需要将返回值塞到Future中并返回，如下代码所示： 1234Future checkVersion() async &#123; var version = await lookUpVersion(); // Do something with version&#125; 下面的代码使用Dart从网络获取数据并打印出来：12345678910111213import 'dart:async';import 'package:http/http.dart' as http;Future&lt;String&gt; getNetData() async&#123; http.Response res = await http.get("http://www.baidu.com"); return res.body;&#125;main() &#123; getNetData().then((str) &#123; print(str); &#125;);&#125; 疑问既然getNetData方法中使用了await,为什么后面调用的时候还要使用.then((){}) ?我觉得是可以这样调用1234main() &#123; var res = getNetData(); print(res)&#125; 大远解释如果这样的话，会先print打印，打印出来为空。自己想打印的没有打印。因为函数中的await，只能保证函数中包含await的代码和下它下一句代码之间是顺序执行的。其他的并不会影响到。如果你在getNetData函数中，后面要使用res，await就可以保证函数内部等待http.get到结果后再执行。]]></content>
      <categories>
        <category>async\await</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>Dart</tag>
        <tag>js</tag>
        <tag>async\await</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[btcd的p2p网络（1）-地址addrMrg]]></title>
    <url>%2F2019%2F01%2F28%2F%E6%AF%94%E7%89%B9%E5%B8%81%E7%B3%BB-btcd-2019-01-23-btcd%E7%9A%84p2p%E7%BD%91%E7%BB%9C%EF%BC%881%EF%BC%89-%E5%9C%B0%E5%9D%80addrMgr%2F</url>
    <content type="text"><![CDATA[p2p网络从底层到上层可以分为3层，地址 连接 节点，每一层都有自己的功能。这一节主要介绍地址声明：文章代码和源码有不一致地方 btcd的p2p网络之地址主要有四个结构体,两两对应 AddrManagerserializedAddrManager KnownAddressserializedKnownAddress 我们先看peer.json中的内容,这个就是和serializedAddrManager的内容对应的。123456789101112131415161718192021222324252627282930313233343536373839404142434445//peers.json&#123; &quot;Version&quot;: 1, &quot;Key&quot;: [233,19,87,131,183,155,......,231,78,82,150,10,102], &quot;Addresses&quot;: [ &#123; &quot;Addr&quot;: &quot;109.157.120.169:8333&quot;, &quot;Src&quot;: &quot;104.172.5.90:8333&quot;, &quot;Attempts&quot;: 0, &quot;TimeStamp&quot;: 1514967959, &quot;LastAttempt&quot;: -62135596800, &quot;LastSuccess&quot;: -62135596800 &#125;, ...... ], &quot;NewBuckets&quot;: [ [ &quot;[2001:0:9d38:78cf:3cb1:bb2:ab6f:e8b4]:8333&quot;, &quot;196.209.239.229:8333&quot;, ...... &quot;65.130.177.198:8333&quot; ], ...... [ &quot;125.227.159.115:8333&quot;, ...... &quot;alhlegtjkdmbqsvt.onion:8333&quot;, ...... &quot;79.250.188.226:8333&quot; ] ], &quot;TriedBuckets&quot;: [ [ &quot;5.9.165.181:8333&quot;, ...... &quot;5.9.17.24:8333&quot; ], [ &quot;95.79.50.90:8333&quot;, ...... &quot;[2a02:c207:2008:9136::1]:8333&quot; ] ]&#125; start()start()先从peer.json中加载，然后开启一个goroutine定期进行跟踪和添加地址。123456789101112131415func (a *AddrManager) Start()&#123; //alter stared ? if atomic.AddInt32(&amp;a.started,1) != 1&#123; log.Trace(&quot;AddrManager has stared&quot;) return &#125; log.Trace(&quot;Starting address manager&quot;) // load peers we already know about from file // 从文件中加载peers a.loadPeers() // start the address ticker to save addresses periodically（定期）. a.wg.Add(1) // 在下面的goroutine中，a.wg.Done()之后，start才会结束 go a.addressHandler()&#125; 我们再看a.loadPeers(),主要是调用deserializePeers,就是把peer.json中的文件反序列化。主要是把Addresses`NewBucketsTriedBuckets,解析到AddrManager的addrIndexaddrNewaddrTried`1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889func (a *AddrManager) deserializePeers(filePath string) error &#123; _, err := os.Stat(filePath) if os.IsNotExist(err) &#123; return nil &#125; r, err := os.Open(filePath) if err != nil &#123; return fmt.Errorf(&quot;opening file:%v error:%v&quot;, filePath, err) &#125; defer r.Close() var sam serializedAddrManager dec := json.NewDecoder(r) err = dec.Decode(&amp;sam) if err != nil &#123; return fmt.Errorf(&quot;error reading %s: %v&quot;, filePath, err) &#125; // 检查版本 if sam.Version != serialisationVersion &#123; return fmt.Errorf(&quot;unknown version %v in serialized &quot;+ &quot;addrmanager&quot;, sam.Version) &#125; copy(a.key[:], sam.Key[:]) // 先解析Addresses for _, v := range sam.Addresses &#123; ka := new(KnownAddress) ka.na, err = a.DeserializeNetAddress(v.Addr) if err != nil &#123; return fmt.Errorf(&quot;failed to deserialize netaddress &quot;+ &quot;%s: %v&quot;, v.Addr, err) &#125; ka.srcAddr, err = a.DeserializeNetAddress(v.Src) if err != nil &#123; return fmt.Errorf(&quot;failed to deserialize netaddress &quot;+ &quot;%s: %v&quot;, v.Src, err) &#125; ka.attempts = v.Attempts ka.lastattempt = time.Unix(v.LastAttempt, 0) ka.lastsuccess = time.Unix(v.LastAttempt, 0) // 遍历sam.Addresses中的每一项，然后辨析成一个KnownAddress后， // 添加到addrManager.addrIndex,是一个map a.addrIndex[NetAddressKey(ka.na)] = ka &#125; // 遍历解析Newbuckets for i := range sam.NewBuckets &#123; for _, val := range sam.NewBuckets[i] &#123; // 先看看addrIndex中有没有这个ip:port ka, ok := a.addrIndex[val] if !ok &#123; return fmt.Errorf(&quot;newbucket contains %s but &quot;+ &quot;none in address list&quot;, val) &#125; // addrIndex中已经有了 if ka.refs == 0 &#123; a.nNew ++ &#125; ka.refs ++ a.addrNew[i][val] = ka &#125; &#125; // 遍历解析TriedBuckets for i := range sam.TriedBuckets &#123; for _, val := range sam.TriedBuckets[i] &#123; ka, ok := a.addrIndex[val] if !ok &#123; return fmt.Errorf(&quot;Newbucket contains %s but &quot;+ &quot;none in address list&quot;, val) &#125; ka.tried = true a.nTried++ // 一个bucket到这里就成了一个数组 a.addrTried[i].PushBack(ka) &#125; &#125; // 检查,保证一个地址要么在 NewBuckets中，要么在TriedBuckets for k, v := range a.addrIndex &#123; if v.refs == 0 &amp;&amp; !v.tried &#123; return fmt.Errorf(&quot;address %s after serialisation &quot;+ &quot;with no references&quot;, k) &#125; if v.refs &gt; 0 &amp;&amp; v.tried &#123; return fmt.Errorf(&quot;address %s after serialisation &quot;+ &quot;which is both new and tried!&quot;, k) &#125; &#125; return nil&#125; 然后调用a.addressHandler()，主要逻辑就是定期保存地址123456789101112131415161718// addressHandler is the main handler for the address manager. It must be run// as a goroutine.func (a *AddrManager) addressHandler() &#123; dumpAddressTicker := time.NewTicker(dumpAddressInterval) defer dumpAddressTicker.Stop()out: for &#123; select &#123; case &lt;-dumpAddressTicker.C: a.savePeers() case &lt;-a.quit: break out &#125; &#125; a.savePeers() a.wg.Done() // start方法中已经有wg.Add(1)在等着了 log.Trace(&quot;Address handler done&quot;)&#125; a.savePeers(),大家可以查看源码 updateAddress节点直接交换getaddr和addr消息时，就会收到addr信息，调用AddAddress()是实际上都是调用updateAddress如果我们已经有了，就进行一些修改如果我们没有，就添加，如果满了的话，就把老的给移除掉 NewBucket到TriedBucket在节点获取地址，并建立peer连接成功后，会调用Good方法。就是说这个地址是好的，可以从NewBucket移到TriedBucket了。 GetAddress这个是供外面获取地址的方法 按照50%的记录随机从NewBucket或者TriedBucket中选择。随机选择bucket后，从中随机选择地址。选择出来的地址要判断一下12345randval := a.rand.Intn(large)if float64(randval) &lt; (factor * ka.chance() * float64(large)) &#123; log.Tracef(&quot;Selected %v from new bucket&quot;,NetAddressKey(ka.na)) return ka&#125; 决定是不是用这个选中地址，主要是由factor和ka.chance()决定。facket依次递增而ka.chance()则和这个地址的其他属性密切相关。比如上次尝试到现在间隔，失败的次数。 我们完全可以去除这个包，设置几个固定的地址，但是这几个地址不能用后，我们的节点也就没法同步了。就不是p2p了。搞这么复杂，主要还是为了防止攻击。AddLocalAddress12345678910111213141516171819202122// AddLocalAddress adds na to the list of known local addresses to advertise with the given priority.// 地址会先加到AddrManager.localAddressesfunc (a *AddrManager) AddLocalAddress(na *wire.NetAddress,priority AddressPriority)error&#123; // TODO 判断不是是公网路由 a.lamtx.Lock() defer a.lamtx.Unlock() // 得到特定格式的ip：端口 key := NetAddressKey(na) // 判断localAddresses有没有这个ip la,ok := a.localAddresses[key] if !ok || la.score &lt; priority&#123; if ok &#123; la.score = priority + 1 &#125;else&#123; a.localAddresses[key] = &amp;localAddress&#123; na:na, score:priority, &#125; &#125; &#125; return nil&#125;]]></content>
      <categories>
        <category>btcd</category>
      </categories>
      <tags>
        <tag>btcd</tag>
        <tag>p2p</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两张图看懂http和https]]></title>
    <url>%2F2019%2F01%2F24%2Fcomputer-network-2019-01-24-%E4%B8%A4%E5%BC%A0%E5%9B%BE%E7%9C%8B%E6%87%82http%E5%92%8Chttps%2F</url>
    <content type="text"><![CDATA[http访问过程 https访问过程]]></content>
      <categories>
        <category>计算机网路</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[btcd的p2p网络（2）-连接connMgr]]></title>
    <url>%2F2019%2F01%2F24%2F%E6%AF%94%E7%89%B9%E5%B8%81%E7%B3%BB-btcd-2019-01-28-btcd%E7%9A%84p2p%E7%BD%91%E7%BB%9C%EF%BC%882%EF%BC%89-%E8%BF%9E%E6%8E%A5connMgr%2F</url>
    <content type="text"><![CDATA[p2p网络从底层到上层可以分为3层，地址 连接 节点，每一层都有自己的功能声明：文章代码和源码有不一致地方这篇文章简单记录下连接conn 三个主要的结构体1、连接管理123456789101112131415161718192021// ConnManager providers a manager to handle network connections.type ConnManager struct &#123; // the following variables must only be used atomically // 记录自己主动连接其他节点的连接数量 connReqCount uint64 // 标识connmgr已经启动 start int32 // 标识connmgr已经结束 stop int32 // 设定相关的配置 cfg Config // 用于同步connmgr的退出状态，调用方可以阻塞等待connmgr的工作协程退出 wg sync.WaitGroup // 某个连接失败后，connmgr尝试选择新的peer地址连接的总次数 failedAttempts uint64 // 用于与connmgr工作协程通信的管道 requests chan interface&#123;&#125; // 用于通知工作协程退出 quit chan struct&#123;&#125;&#125; 2、Config，配置参数其实就是connmgr配置，本身就是ConnManager结构体的一个字段:cfg。123456789101112131415161718192021222324252627282930313233343536373839404142434445// Config holds the configuration options related to the connection manager.type Config struct &#123; // Listeners define a slice of listeners for which the connection manager // will take ownership of(取得所有权) and accept connections. when a connection // is accepted,the OnAccept handler will be invoked with the connection. since // the connection manager takes ownership of these listeners,they will be closed // when the connection manager is stoped. // this field will not have any effect if the onAccept field is not also specified. // It may be nil if the caller does not wish to listen for // incoming connection Listeners []net.Listener //节点上所有等待外部连接的监听点; // OnAccept is a callback that is fired when an inbound connection is // accepted. It is the caller&apos;s responsibility(责任、义务) to close the connection. // Failure to close the connection will result in the connection manager // believing the connection is still active and thus have undesirable // side effects such as still counting toward maximum connection limits. // // This field will not have any effect if the Listeners field is not // also specified since there couldn&apos;t possibly be any accepted // connections in that case. OnAccept func(net.Conn) // 节点应答并接受外部连接后的回调函数 // TargetOutbound is the number of outbound network connections to // maintain. Defaults to 8. TargetOutbound uint32 // 节点主动向外连接peer的最大个数 // RetryDuration is the duration to wait before retrying connection // requests. Defaults to 5s. RetryDuration time.Duration // 连接失败后发起重连的等待时间 // OnConnection is a callback that is fired when a new outbound // connection is established. OnConnection func(*ConnReq, net.Conn) // 连接建立成功后的回调函数 // OnDisconnection is a callback that is fired when an outbound // connection is disconnected. OnDisconnection func(*ConnReq) // 连接关闭后的回调函数 // GetNewAddress is a way to get an address to make a network connection // to. If nil, no new connections will be made automatically. // 连接失败后，ConnMgr可能会选择新的peer地址进行连接 // GetNewAddress函数提供了获取新的peer地址的方法，它最终会调用addrManager中 // 的GetAddress()来分配新地址。 GetNewAddress func() (net.Addr, error) // Dial connects to the address on the named network.It cannot be nil. // 定义建立TCP连接的方式，是直接连接还是通过代理连接。 Dial func(net.Addr) (net.Conn, error)&#125; 3、ConnReq 描述了一个连接123456789101112131415161718192021// ConnReq is the connection request to a network address. If permanent, the// connection will be retried on disconnection.// ConnReq 描述了一个连接type ConnReq struct &#123; // The following variables must only be used atomically. // 连接的序号，用于索引 id uint64 // 连接的目的地址 Addr net.Addr // 标识是否与Peer保持永久连接，如果为true， // 则连接失败后，继续尝试与该Peer连接，而不是选择新的Peer地址重新连接 Permanent bool // 连接成功后，真实的net.Conn对象; conn net.Conn // 连接的状态，有ConnPending、ConnEstablished、ConnDisconnected及ConnFailed等; state ConnState // stateMtx: 保护state状态的读写锁; stateMtx sync.RWMutex //retryCount: 如果Permanent为true，retryCount记录该连接重复重连的次数; retryCount uint32&#125; 结合起来说，就是连接管理器connmgr按照自身的配置config，管理着一些连接connReq 启动ConnMgr我们先看start()函数123456789101112131415161718192021222324// Start: launches(发起、发动)the connection manager and begins conecting to the network.func (cm *ConnManager) Start() &#123; // already started ? if atomic.AddInt32(&amp;cm.start, 1) != 1 &#123; return &#125; log.Trace(&quot;Connection manager started&quot;) cm.wg.Add(1) // 启动工作协程 go cm.connHandler() // Start all the listeners so long as the caller requested // them and provided a callback to be invoked when connections are accepted. if cm.cfg.OnAccept != nil &#123; for _, listenr := range cm.cfg.Listeners &#123; cm.wg.Add(1) // 启动监听协程listenHandler，等待其他节点连接; go cm.listenHandler(listenr) &#125; &#125; // 启动建立连接的协程，选择Peer地址并主动连接; for i := atomic.LoadUint64(&amp;cm.connReqCount); i &lt; uint64(cm.cfg.TargetOutbound); i++ &#123; go cm.NewConnReq() &#125;&#125; 主要是启动工作协程cm.connHandler(),然后一方面监听其他节点的连接，go cm.listenHandler(listenr)这里面做的事情就是我们普通的tcp地址监听。一方面主动去连接其他的节点: cm.NewConnReq()动态选择Peer并发起连接的过程就是在NewConnReq()中实现:1234567891011121314151617181920212223242526272829303132333435363738394041// NewConnReq creates a new connection request and connects to the// corresponding(对应的) address.// 创建一个连接请求，然后连接对应的地址func (cm *ConnManager) NewConnReq() &#123; if atomic.LoadInt32(&amp;cm.stop) != 0 &#123; return &#125; if cm.cfg.GetNewAddress == nil &#123; return &#125; c := &amp;ConnReq&#123;&#125; atomic.StoreUint64(&amp;c.id, atomic.AddUint64(&amp;cm.connReqCount, 1)) // Submit a request of a pending connection attempt to the connection // manager. By registering the id before the connection is even established, // we&apos;ll be able to later cancel the connection via the Remove method. done := make(chan struct&#123;&#125;) select &#123; case cm.requests &lt;- registerPending&#123;c, done&#125;: case &lt;-cm.quit: return &#125; // wait for the registration to successfully add the pending conn req // to the conn manager&apos;s internal state. select &#123; case &lt;-done: case &lt;-cm.quit: return &#125; addr,err := cm.cfg.GetNewAddress() if err != nil &#123; select &#123; case cm.requests &lt;- handleFailed&#123;c, err&#125;: case &lt;-cm.quit: &#125; return &#125; c.Addr = addr cm.Connect(c)&#125; 首先构造一个ConnReq:c := &amp;ConnReq{},然后生成registerPending{c, done},把registerPending写入到connmgr的通道case cm.requests &lt;- registerPending{c, done} 这里的registerPending结构体中还有一个通道done,cm.requests这个通道的另一端肯定有人会从里面读数据，处理完后会通过通道done返回信息。下面的case &lt;-done:就是在等待返回的信息。谁在通道的另外一头读呢？go cm.connHandler(),下面这个图就是他们工作概况 cm.connHandler()从通道requests中接受信息，处理完后通过通道done返回。然后就可以cm.cfg.GetNewAddress()得到一个连接的地址（这里用到了addrMgr）,然后连接cm.Connect(c)123456789101112131415161718192021// Connection assigns an id and dials a connection to the address of the connection requestfunc (cm *ConnManager) Connect(c *ConnReq)&#123; if atomic.LoadInt32(&amp;cm.stop) != 0&#123; return &#125; // TODO 再次检查一遍，相当于重复了NewConnReq（）的工作 log.Debugf(&quot;Attempting to connect to %v&quot;, c) conn,err := cm.cfg.Dial(c.Addr) if err != nil &#123; select &#123; case cm.requests &lt;- handleFailed&#123;c, err&#125;: case &lt;-cm.quit: &#125; return &#125; select &#123; case cm.requests &lt;- handleConnected&#123;c, conn&#125;: case &lt;-cm.quit: &#125;&#125; 连接主要就是这句代码conn,err := cm.cfg.Dial(c.Addr),这个Dial就是在普通的tcp连接外包了一层，让我们有个选择，比如可以通过代理进行连接。 如果连接失败，cm.requests &lt;- handleFailed{c, err}；如果连接成功，cm.requests &lt;- handleConnected{c, conn}.handleConnected{c, conn}:和handleFailed{c, err}:这两个结构体都被构建，并且发送到cm.requests 有连接就有断开12345678910func (cm *ConnManager) Disconnect(id uint64) &#123; if atomic.LoadInt32(&amp;cm.stop) != 0 &#123; return &#125; select &#123; case cm.requests &lt;- handleDisconnected&#123;id, true&#125;: case &lt;-cm.quit: &#125;&#125; 可connect也差不多，都是向cm.requests发了一个请求。 看来，连接或者断开连接的主要处理逻辑在connHandler中，我们来看看它的实现:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// connHandler handles all connection related requests. It must be run as a// goroutine.//// The connection handler makes sure that we maintain a pool of active outbound// connections so that we remain connected to the network. Connection requests// are processed and mapped by their assigned ids.func (cm *ConnManager) connHandler() &#123; // pending holds all registered conn requests that hava yet to succeed. var pending = make(map[uint64]*ConnReq) // conns represents the set of all actively connected peers. var conns = make(map[uint64]*ConnReq, cm.cfg.TargetOutbound) // make map时，size可以省略，当你知道大小时，最好加上out: for &#123; select &#123; case req := &lt;- cm.requests: switch msg:=req.(type) &#123; case registerPending: // TODO case handleConnected: connReq := msg.c if _, ok := pending[connReq.id]; !ok &#123; if msg.conn != nil &#123; msg.conn.Close() &#125; log.Debugf(&quot;Ignoring connection for &quot;+ &quot;canceled connreq=%v&quot;, connReq) continue &#125; connReq.updateState(ConnEstablished) connReq.conn = msg.conn conns[connReq.id] = connReq log.Debugf(&quot;Connected to %v&quot;, connReq) connReq.retryCount = 0 cm.failedAttempts = 0 delete(pending, connReq.id) if cm.cfg.OnConnection != nil &#123; go cm.cfg.OnConnection(connReq, msg.conn) &#125; case handleDisconnected: // TODO case handleFailed: // TODO &#125; case &lt;-cm.quit: break out &#125; &#125; cm.wg.Done() log.Trace(&quot;Connection handler done&quot;)&#125; 在这里不停的处理cm.requests通道中的信息。我们看下连接成功的处理：首先创建了两个变量1234// pending holds all registered conn requests that hava yet to succeed. var pending = make(map[uint64]*ConnReq) // conns represents the set of all actively connected peers. var conns = make(map[uint64]*ConnReq, cm.cfg.TargetOutbound) // make map时，size可以省略，当你知道大小时，最好加上 连接成功后 在map变量 pending中找有没有这个连接请求，如果没有则表明这不是我们要的连接。断开 更新connReq的状态，然后添加到map conns中 调用go cm.cfg.OnConnection(connReq, msg.conn) 两个peer之间的连接conn，还需要考虑其他的很多方面。但是还好，到现在我们至少可以简单的创建一个连接了。 至于连接成功后调用cm.cfg.OnConnection()要干什么，我们后面再分析了。参考https://www.jianshu.com/p/d6484e5710ad]]></content>
      <categories>
        <category>btcd</category>
      </categories>
      <tags>
        <tag>btcd</tag>
        <tag>p2p</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker基本使用]]></title>
    <url>%2F2019%2F01%2F18%2F%E8%BF%90%E7%BB%B4-docker-2019-01-18-docker%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>运维</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu16.04-jenkins-golang部署]]></title>
    <url>%2F2019%2F01%2F16%2F%E8%BF%90%E7%BB%B4-cicd-2019-01-16-ubuntu16-04-jenkins-golang%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[jenkins安装首先安装java方式一1234sudo add-apt-repository ppa:openjdk-r/ppa# 需要回车一下sudo apt-get updateecho y|sudo apt-get install openjdk-8-jdk 方式二在官网下载对应版本http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html解压到当前位置tar -zxvf jdk-8u151-linux-x64.tar.gz移动到opt路径下sudo mv jdk-8u151-linux-x64.tar.gz /opt/编辑环境变量vim ~/.bashrc添加以下123export JAVA_HOME=/opt/jdk1.8.0_151export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jart source ~/.bashrc检测java -version 安装jenkins四部1234wget -q -O - https://pkg.jenkins.io/debian/jenkins-ci.org.key | sudo apt-key add -sudo sh -c &apos;echo deb http://pkg.jenkins.io/debian-stable binary/ &gt; /etc/apt/sources.list.d/jenkins.list&apos;sudo apt-get updatesudo apt-get install jenkins 如果报错如下 解决办法创建一条软连接sudo ln -s /opt/jdk1.8.0_201/bin/java /usr/bin/java/opt/jdk1.8.0_201/bin/java根据自己的安装目录确定 jenkins使用基本情况 安装目录/var/lib/jenkins配置文件 /etc/sysconfig/jenkins日志目录 /var/log/jenkins 登录 http://ip:8080初始密码：cat /var/lib/jenkins/secrets/initialAdminPassword安装推荐的插件创建第一个管理员 // TODO 还没有和golang结合]]></content>
      <categories>
        <category>golang学习</category>
        <category>jenkins部署</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go 性能测试]]></title>
    <url>%2F2019%2F01%2F12%2Fgolang-go-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"></content>
      <categories>
        <category>golang学习</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>性能测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go 格式化打印-utf-8编码规则]]></title>
    <url>%2F2019%2F01%2F11%2Fgolang-2019-01-11-go-%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%89%93%E5%8D%B0%2F</url>
    <content type="text"><![CDATA[示例程序1234567891011121314func main() &#123; var s byte = '?' fmt.Println(s) //63 //输出 2/8/10 进制格式 fmt.Printf("%b,%o,%d\n", s, s, s) // 111111,77,63 // 以16进制输出字符串 fmt.Printf("%x\n", "hex this") // 输出数值所表示的 Unicode 字符 fmt.Printf("%c\n", 63) //输出数值所表示的 Unicode 字符（带单引号）。对于无法显示的字符，将输出其转义字符。 fmt.Printf("%q\n", 63) //输出 Unicode 码点（例如 U+1234，等同于字符串 "U+%04X" 的显示结果） fmt.Printf("%U\n", 63)&#125; 在线编码转换http://tools.jb51.net/transcoding/unicode_chinese 汉字字符集编码查询http://www.qqxiuzi.cn/bianma/zifuji.php 在线进制转换https://tool.lu/hexconvert/ 在线Unicode和UTF编码转换https://www.qqxiuzi.cn/bianma/Unicode-UTF.php UTF-8编码规则https://blog.csdn.net/sandyen/article/details/1108168 编码示例12345678func main() &#123; var s rune = '好' fmt.Printf("%d\n",s) // 22909 buf := bytes.NewBufferString("hello") fmt.Println(buf.Bytes()) // [104 101 108 108 111] buf.WriteRune(s) fmt.Println(buf.Bytes()) // [104 101 108 108 111 229 165 189]&#125; 什么好会写入三个字节？[229 165 189]我们先看看好的编码方式http://tool.oschina.net/hexconvert将Unicode编码597D转化为UTF-8编码可以看到utf-8编码是E5A58D,这是十六进制的，我们转为为10进制 我们要的是字节数组，所以需要将11100101 10100101 10111101拆成字节，然后再转化成10进制显示。]]></content>
      <categories>
        <category>golang学习</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>格式化打印</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go bytes.Buffer]]></title>
    <url>%2F2019%2F01%2F10%2Fgolang-2019-01-10-go-bytes-Buffer%2F</url>
    <content type="text"><![CDATA[Buffer 介绍Buffer 是 bytes 包中的一个 type Buffer struct{…}A buffer is a variable-sized buffer of bytes with Read and Write methods. The zero value for Buffer is an empty buffer ready to use.（是一个变长的 buffer，具有 Read 和Write 方法。 Buffer 的 零值 是一个 空的 buffer，但是可以使用）Buffer 就像一个集装箱容器，可以存东西，取东西（存取数据） 创建缓冲器1234567891011func main() &#123; buf1 := bytes.NewBufferString("hello") buf2 := bytes.NewBuffer([]byte("hello")) buf3 := bytes.NewBuffer([]byte&#123;'h','e','l','l','o'&#125;) fmt.Printf("%v,%v,%v\n",buf1,buf2,buf3) fmt.Printf("%v,%v,%v\n",buf1.Bytes(),buf2.Bytes(),buf3.Bytes()) buf4 := bytes.NewBufferString("") buf5 := bytes.NewBuffer([]byte&#123;&#125;) fmt.Println(buf4.Bytes(),buf5.Bytes())&#125; 输出123hello,hello,hello[104 101 108 108 111],[104 101 108 108 111],[104 101 108 108 111][] [] 写入到缓冲器buffer在new的时候是空的，也是可以直接Write的 Writefunc (b *Buffer) Write(p []byte) (n int,err error)func main() { s := []byte(“ world”) buf := bytes.NewBufferString(“hello”) fmt.Printf(“%v,%v\n”,buf.String(),buf.Bytes()) buf.Write(s) fmt.Printf(“%v,%v\n”,buf.String(),buf.Bytes())}结果12hello,[104 101 108 108 111]hello world,[104 101 108 108 111 32 119 111 114 108 100] WriteStringfunc (b *Buffer) WriteString(s string)(n int,err error)1234567func main() &#123; s := " world" buf := bytes.NewBufferString("hello") fmt.Printf("%v,%v\n",buf.String(),buf.Bytes()) buf.WriteString(s) fmt.Printf("%v,%v\n",buf.String(),buf.Bytes())&#125; 结果12hello,[104 101 108 108 111]hello world,[104 101 108 108 111 32 119 111 114 108 100] WriteBytefunc (b *Buffer) WriteByte(c byte) error1234567func main() &#123; var s byte = '?' buf := bytes.NewBufferString("hello") fmt.Println(buf.Bytes()) // [104 101 108 108 111] buf.WriteByte(s) fmt.Println(buf.Bytes()) // [104 101 108 108 111 63]&#125; WriteRunefunc (b *Buffer) WriteRune(r Rune) (n int,err error)1234567func main()&#123; var s rune = '好' buf := bytes.NewBufferString("hello") fmt.Println(buf.String()) //hello buf.WriteRune(s) fmt.Println(buf.String()) //hello好&#125; 结果12322909[104 101 108 108 111][104 101 108 108 111 229 165 189] 从缓冲器中写出12345func main() &#123; file,_ := os.Create("test.txt") buf := bytes.NewBufferString("hello world") buf.WriteTo(file)&#125; 读出缓冲器Readfunc (b *Buffer) Read(p []byte)(n int,err error)12345678910111213141516func main() &#123; s1 := []byte("hello") buff :=bytes.NewBuffer(s1) s2 := []byte(" world") buff.Write(s2) fmt.Println(buff.String()) //hello world s3 := make([]byte,3) buff.Read(s3) fmt.Println(string(s3)) //hel,s3的容量为3，只能读3个 fmt.Println(buff.String()) //lo world buff.Read(s3) // 会把s3覆盖掉 fmt.Println(string(s3)) // lo fmt.Println(buff.String()) // world&#125; ReadByte返回缓冲器头部的第一个bytefunc (b *Buffer) ReadByte() (c byte,err error)1234567func main() &#123; buf := bytes.NewBufferString("hello") fmt.Println(buf.String()) // hello b,_:= buf.ReadByte() fmt.Println(string(b)) //h fmt.Println(buf.String()) //ello&#125; ReadRunReadRune方法，返回缓冲器头部的第一个runefunc (b *Buffer) ReadRune() (r rune,size int,err error)12345678910111213141516func main() &#123; buf1 := bytes.NewBufferString("你好xuxiaofeng") fmt.Println(buf1.Bytes()) //[228 189 160 229 165 189 120 117 120 105 97 111 102 101 110 103] b1,n1,_ := buf1.ReadRune() fmt.Println(string(b1)) // 你 fmt.Println(n1) buf := bytes.NewBufferString("hello") fmt.Println(buf.String()) //hello b,n,_:= buf.ReadRune() fmt.Println(n) // 1 fmt.Println(string(b)) //h fmt.Println(buf.String()) //ello&#125; 为什么n==3，而n1==1呢？我们看下ReadRune 的源码1234567891011121314151617func (b *Buffer) ReadRune() (r rune, size int, err error) &#123; if b.empty() &#123; // Buffer is empty, reset to recover space. b.Reset() return 0, 0, io.EOF &#125; c := b.buf[b.off] if c &lt; utf8.RuneSelf &#123; // 就是在这里判断，读取的第一个字符是不是Rune b.off++ b.lastRead = opReadRune1 return rune(c), 1, nil &#125; r, n := utf8.DecodeRune(b.buf[b.off:]) b.off += n b.lastRead = readOp(n) return r, n, nil&#125; ReadBytesReadBytes方法，需要一个byte作为分隔符，读的时候从缓冲器里找出第一个出现的分隔符，缓冲器头部开始到分隔符之间的byte返回。func (b *Buffer) ReadBytes(delim byte) (line []byte,err error)123456789func main() &#123; var d byte = 'f' buf := bytes.NewBufferString("xuxiaofeng") fmt.Println(buf.String()) b,_ :=buf.ReadBytes(d) fmt.Println(string(b)) fmt.Println(buf.String())&#125; 相当于有一个分隔符 ReadString和readBytes方法类似 读入缓冲器ReadFrom方法，从一个实现io.Reader接口的r，把r的内容读到缓冲器里，n返回读的数量func (b *Buffer) ReadFrom(r io.Reader) (n int64,err error123456func main()&#123; file, _ := os.Open("text.txt") buf := bytes.NewBufferString("bob ") buf.ReadFrom(file) fmt.Println(buf.String()) //bob hello world&#125; 从缓冲器取出Next方法，返回前n个byte（slice），原缓冲器变func (b *Buffer) Next(n int) []byte1234567func main() &#123; buf := bytes.NewBufferString("helloworld") fmt.Println(buf.String()) // helloworld b := buf.Next(2) fmt.Println(string(b)) // he&#125; 缓冲区原理介绍go字节缓冲区底层以字节切片做存储，切片存在长度len与容量cap, 缓冲区写从长度len的位置开始写，当len&gt;cap时，会自动扩容。缓冲区读会从内置标记off位置开始读(off始终记录读的起始位置)，当off==len时，表明缓冲区已全部读完并重置缓冲区(len=off=0),此外当将要内容长度+已写的长度(即len) &lt;= cap/2时，缓冲区前移覆盖掉已读的内容(off=0，len-=off)，从避免缓冲区不断扩容1234567891011121314151617181920func main() &#123; byteSlice := make([]byte, 20) byteSlice[0] = 1 // 将缓冲区第一个字节置1 byteBuffer := bytes.NewBuffer(byteSlice) // 创建20字节缓冲区 len = 20 off = 0 c, _ := byteBuffer.ReadByte() // off+=1 fmt.Printf("len:%d, c=%d\n", byteBuffer.Len(), c) // len = 20 off =1 打印c=1 byteBuffer.Reset() // len = 0 off = 0 fmt.Printf("len:%d\n", byteBuffer.Len()) // 打印len=0 byteBuffer.Write([]byte("hello byte buffer")) // 写缓冲区 len+=17 fmt.Printf("len:%d\n", byteBuffer.Len()) // 打印len=17 byteBuffer.Next(4) // 跳过4个字节 off+=4 c, _ = byteBuffer.ReadByte() // 读第5个字节 off+=1 fmt.Printf("第5个字节:%d\n", c) // 打印:111(对应字母o) len=17 off=5 byteBuffer.Truncate(3) // 将未字节数置为3 len=off+3=8 off=5 fmt.Printf("len:%d\n", byteBuffer.Len()) // 打印len=3为未读字节数 上面len=8是底层切片长度 byteBuffer.WriteByte(96) // len+=1=9 将y改成A byteBuffer.Next(3) // len=9 off+=3=8 c, _ = byteBuffer.ReadByte() // off+=1=9 c=96 fmt.Printf("第9个字节:%d\n", c) // 打印:96&#125;]]></content>
      <categories>
        <category>golang学习</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>bytes</tag>
        <tag>Buffer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go 日志系统]]></title>
    <url>%2F2019%2F01%2F07%2Fgolang-2019-01-07-go%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[介绍golang的log包已经提供了比较完善的功能，我们只是做了一些简单的封装 主要就是构造了Writer，这个writer每次调用Write()的时候，执行了两步第一步就是在终端输出，其实就是写到终端里第二部就是写入到我们的日志文件。写入到日志文件的时候，有个大小判断，超过预定的大小后，就会进行分割和压缩 golang原生日志系统log包简单实用123func main() &#123; log.Println(&quot;this is my first log&quot;)&#125; 进入到log包中，看Println()函数12345// Println calls Output to print to the standard logger.// Arguments are handled in the manner of fmt.Println.func Println(v ...interface&#123;&#125;) &#123; std.Output(2, fmt.Sprintln(v...))&#125; 再往上追溯12Stdout = NewFile(uintptr(syscall.Stdout), "/dev/stdout")var std = New(os.Stderr, "", LstdFlags) 1234567// New creates a new Logger. The out variable sets the// destination to which log data will be written.// The prefix appears at the beginning of each generated log line.// The flag argument defines the logging properties.func New(out io.Writer, prefix string, flag int) *Logger &#123; return &amp;Logger&#123;out: out, prefix: prefix, flag: flag&#125;&#125; 这里的Logger就是一切的重点了1234567891011// A Logger represents an active logging object that generates lines of// output to an io.Writer. Each logging operation makes a single call to// the Writer's Write method. A Logger can be used simultaneously from// multiple goroutines; it guarantees to serialize access to the Writer.type Logger struct &#123; mu sync.Mutex // ensures atomic writes; protects the following fields prefix string // prefix to write at beginning of each line flag int // properties out io.Writer // destination for output buf []byte // for accumulating text to write&#125; 我们再看Output 函数123456func (l *Logger) Output(calldepth int, s string) error &#123; ... ... _, err := l.out.Write(l.buf) return err&#125; 其实就是把日志写入到一个文件中。只是终端有默认的文件而已。 构建我们自己的Logger上面的例子，当我们没有创建Logger时，系统会使用默认的Logger，也就是Stdout.接下来，我们构建一个自己的Logger ,让日志输出到我们自己指定的文件中12345678func main() &#123; //logFile,_ := os.Open(&quot;./test.log&quot;) / logFile, _ := os.OpenFile(&quot;test.log&quot;, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0666) logger := log.New(logFile, &quot;TEST&quot;, log.Lshortfile|log.Ldate|log.Ltime) for i := 0; i &lt; 10; i++ &#123; logger.Printf(&quot;this is my %v test log&quot;,i) &#125;&#125; 注意两点 open(filename) 默认是以只读方式打开，那我们就不能写入了 123func Open(name string) (*File, error) &#123; return OpenFile(name, O_RDONLY, 0)&#125; os.O_APPEND以追加模式test.log 123456TEST2019/01/10 14:25:35 test01.go:13: this is my 0 test logTEST2019/01/10 14:25:35 test01.go:13: this is my 1 test logTEST2019/01/10 14:25:35 test01.go:13: this is my 2 test logTEST2019/01/10 14:25:35 test01.go:13: this is my 3 test logTEST2019/01/10 14:25:35 test01.go:13: this is my 4 test log... 开始造轮子第一步就是在终端输出，其实就是写到终端里第二部就是写入到我们的日志文件。写入到日志文件的时候，有个大小判断，超过预定的大小后，就会进行分割和压缩接下来展示一下目录结构12345678mlog 定义了我们日志系统，还有日志子系统 log.go 日志系统接口实现和子系统的创建 interface.go 日志系统接口rotator rotator.go 日志写入文件、日志分割、日志压缩log.go 项目的日志配置文件，创建日志系统及子系统config.go 项目的配置文件，加载日志等级，用配置的日志文件初始化rotatormain.go 项目入口文件 源码https://github.com/naichadouban/logProject 分析首先在log.go文件中，初始化后台日志系统,还有日志子系统。123456var ( backendLog = mlog.NewBackend(logWriter&#123;&#125;) //往终端中写入日志 logRotator *rotator.Rotator // 往文件中写入日志 Mainlog = backendLog.Logger(&quot;HCD&quot;) //日志子系统 TESTlog = backendLog.Logger(&quot;TEST&quot;) // 日志子系统) 然后我们会在config.go 会初始化 logRatator,设置日志等级12initLogRotator(&quot;./test.log&quot;) // 这里已经设置了日志输出文件setLogLevels(DebugLevel) 当我们调用子日志系统打印日志1Mainlog.Infof(&quot;this si my log %v&quot;,i) 判断日志级别后，调用Backend打印日志，BackendLog统一管理各个子日志系统的日志123456func (l *slog) Infof(format string, args ...interface&#123;&#125;) &#123; lvl := l.Level() if lvl &lt;= LevelInfo &#123; l.b.printf(&quot;INF&quot;, l.tag, format, args...) &#125;&#125; 然后我们再看Backend.printf()函数123b.mu.Lock()b.w.Write(*bytebuf)b.mu.Unlock() b.w.Write(*bytebuf),这个w.Write()是我们实现io.Writer接口的Write函数。他内部有两个Write()123456type logWriter struct&#123;&#125;func (logWriter) Write(p []byte)(n int,err error)&#123; os.Stdout.Write(p) //标准输出，就是我们看到的前台显示 logRotator.Write(p) // rotator的输出，就是文件记录中的操作 return len(p),nil&#125; 1backendLog = mlog.NewBackend(logWriter&#123;&#125;) 我们再分析logWriter的Write方法1os.Stdout.Write(p) 这个是系统的标准数据，暂时不讨论 1logRotator.Write(p) 123456789101112131415func (r *Rotator) Write(p []byte) (n int, err error) &#123; // 写入文件 n, _ = r.out.Write(p) r.size += int64(n) // 日志拆分，压缩 if r.size &gt;= r.threshold &amp;&amp; len(p) &gt; 0 &amp;&amp; p[len(p)-1] == &apos;\n&apos; &#123; err := r.rotate() if err != nil &#123; return 0, err &#125; r.size = 0 &#125; return n, nil&#125; 具体的日志压缩，可以看源码]]></content>
      <categories>
        <category>golang学习</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>go log</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go 变量声明初始化、new、make]]></title>
    <url>%2F2019%2F01%2F07%2Fgolang-2019-01-06-go-%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%81new%E3%80%81make%2F</url>
    <content type="text"><![CDATA[变量的声明和初始化实验一起源于大远问，下面的代码会输出什么？123456789type Person struct &#123; name string age int&#125;func main() &#123; var p Person fmt.Println(p.age)&#125; 按照我之前的理解，报错。因为p只是声明了，并没有初始化。但是打印出来却是0 说明Person对象确实初始化了。 实验二12345func main() &#123; var p *Person fmt.Println(p) //&lt;nil&gt; fmt.Println(p.age) //panic: runtime error: invalid memory address or nil pointer dereference&#125; 声明一个变量，初始化的内容只跟变量的类型相关 声明了一个*Person类型的指针p,说明p初始化的内容就是指针的默认值，那就是nil 了。打印p.age出错，证明了Person并没有初始化，当然是空指针错误了。 我们可以画图说明下两者的关系 总结 nil 只能赋值给指针类型的变量，实际上nil就是是指针类型变量的零值。值类型的变量有各自的零值 比如 int 是 0 string 是 “” 变量的声明，无论是值类型还是指针类型的变量，声明之后，变量都会占有一块内存，并且被初始化为一个零值，被初始化的内容只跟变量的类型有关（注意：Post,跟Post是两种类型var i int // 值类型 因此 i 是 0var p Person // 值类型 因此 p.title 是“” p.num 是 0var po Person // 初始化的不是Post类型，而是*Post类型，即指针类型，因此p是nil p.title 会报错 make和newnew 和 make 都可以用来分配空间，初始化类型。他们和上面有什么关系吗？ new(T) 返回的是 T 的指针123456789101112func main() &#123; a := new(int) *a = 3 fmt.Printf("%T,%p,%p,%v\n",a,&amp;a,a,a) // *int,0xc000006028,0xc00000a0a8,0xc00000a0a8 b := new(Person) fmt.Printf("%T,%p,%p,%v\n",b,&amp;b,b,b.age) // *main.Person,0xc000006038,0xc000004460,0 c := new(Person) c = &amp;Person&#123;"xuxiaofeng",26&#125; fmt.Printf("%T,%p,%p,%v\n",c,&amp;c,c,c.age) // *main.Person,0xc000006040,0xc0000044a0,26&#125; 画图表示一下 第三段中，new就相当于下面这两句话12var c *Personc = &amp;Person&#123;"xuxiaofeng",26&#125; 如果我们new(*Person)呢,道理还是同样的道理，只是多了一层指针，指针的指针，容易绕晕。12345678910func main() &#123; a := new(*Person) fmt.Printf("%T.%p,%p\n",a,&amp;a,a) // **main.Person.0xc000006028,0xc000006030 //a = Person&#123;&#125; // error //a = &amp;Person&#123;&#125; // error //*a = Person&#123;&#125; //error *a = &amp;Person&#123;"xuxiaofeng",16&#125; fmt.Printf("%T.%p,%p\n",*a,&amp;(*a),*a) // *main.Person.0xc000006030,0xc000004460 fmt.Println((**a).age)&#125; 画图表示一下 new就是初始化T为默认值，然后返回了*T，就是指向初始化的T的指针 make 只能用于 slice,map,channelmake基本使用就不做介绍了，只要注意只能是slice,map,channel，这三种类型就可以了。这三种类型都是引用类型 new slice我们能否new([]int) new一个slice呢？123456789func main() &#123; a := new([]int) //a[0] = 1 //(type *[]int does not support indexing) //(*a)[0] = 2 // error: index out of range fmt.Println(len(*a),cap(*a)) //0 0 *a = append(*a,1) fmt.Printf("%T\n",a) //*[]int fmt.Println((*a)[0]) //1&#125; 我们看也是可以的，只是给我们返回了长度和容量都是0的slice，而append之后，slice的底层数据已经不是原来的数组了。 new map123456func main() &#123; a := new(map[string]int) (*a)["xuxaiofeng"] =26 //panic: assignment to entry in nil map fmt.Println(*a)&#125; new chan12345678910func main() &#123; a := new(chan int) go func() &#123; (*a) &lt;- 2 &#125;() t := &lt;-*a fmt.Println(t)&#125;//fatal error: all goroutines are asleep - deadlock!//goroutine 1 [chan receive (nil chan)]: 说明我们创建的chan就是一个nil，还没有初始化，从一个nil中读数据，程序当然会deadlock 总结new(T) 返回 T 的指针 *T 并指向 T 的零值。make(T) 返回的初始化的 T，只能用于 slice，map，channel。 p.name 和*p.name123456func main() &#123; p := new(Person) //p = Person&#123;"xuxiaofeng",26&#125; //cannot use Person literal (type Person) as type *Person in assignment p.name = "xuxiaofeng" fmt.Println(p)&#125; p是*Person,是Person的指针，所以不能直接复制，要想复制也要这样p = &amp;Person{&quot;xuxiaofeng&quot;,26},但是为什么调用字段的时候就可以p.name = &quot;xuxiaofeng&quot;？ 如果 x 是可寻址的，&amp;x 的 filed 集合包含 m，x.m 和 (&amp;x).m 是等同的，go 自动做转换，也就是 p.name和 (*p).name调用是等价的，go 在下面自动做了转换。]]></content>
      <categories>
        <category>golang学习</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>变量声明和初始化</tag>
        <tag>new</tag>
        <tag>make</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go指针类型转化 unsafe Pointer]]></title>
    <url>%2F2019%2F01%2F04%2Fgolang-2019-01-04-go-unsafe-Pointer%E3%80%81%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96%2F</url>
    <content type="text"><![CDATA[golang强类型golang是一种强类型的静态语言。强类型就是说一旦类型定义了，就不能够再改变它的类型。静态是说，程序在运行前检测类型，而不是像JavaScript和python等动态语言，运行时才检测 为了安全考虑，golang时不允许两种指针类型 之间相互转化的。 指针类型转换即使有相同的底层类型也是不能转换的123456func main() &#123; var i Myint = 2 var j int =3 j = i // cannot use i (type Myint) as type int in assignment fmt.Println(j)&#125; 1234567891011121314func main() &#123; i := 10 fmt.Printf("%T:%v,%p,%T\n",i,i,&amp;i,&amp;i) // int:10,0x416020,*in var j float64 = 3.434 fmt.Printf("%T:%v,%p,%T\n",j,j,&amp;j,&amp;j) // float64:3.434,0x416038,*float64 // 类型转化 m := float64(i) fmt.Printf("%T:%v,%p,%T\n",m,m,&amp;m,&amp;m) // float64:10,0x416060,*float64 // 指针类型转化 n := (*float64)(&amp;i) //cannot convert &amp;i (type *int) to type *float64 fmt.Printf("%T:%v,%p,%T\n",n,n,&amp;n,&amp;n)&#125; 程序中我们需明白 int，表示int类型的指针，float表示float类型的指针 float64(i)就是普通的类型转化，golang时允许的 (*float64)(&amp;i) 中 (*float64) 括号中整体是一个类型，表示float64类型的指针类型 通过上面的例子，我们知道不同的指针类型是不同转换的，但是我们就需要转化怎么办？就需要用到unsafe包的 Pointer了 unsafe.Pointer介绍unsafe.Pointer是一种特殊类型的指针，它可以包含任意类型的地址我们可以在golang的源码中看到如下的定义12type ArbitraryType inttype Pointer *ArbitraryType 说明unsafe.Pointer其实就是*int，一个通用类型的指针示例一123456func main() &#123; i := 10 fmt.Printf("%T,%v\n",&amp;i,&amp;i) // *int,0xc00004c080 var j unsafe.Pointer = unsafe.Pointer(&amp;i) // unsafe.Pointer,0xc00004c080 fmt.Printf("%T,%v",j,j)&#125; 如果我们直接var j unsafe.Pointer = &amp;i 的话，就会报错：cannot use &amp;i (type *int) as type unsafe.Pointer in assignment。说民unsafe.Pointer是一种类型，上面的示例只是类型强转。 利用unsafe.Pointer再不同*T之间转换1234567func main() &#123; var i int = 10 var j *float64 = (*float64)(unsafe.Pointer(&amp;i)) fmt.Printf("%T.%T\n",j,*j) // *float64.float64 *j = *j * 3 fmt.Printf("%v,%v",i,j) //30,0xc00004c080&#125; 上面的代码中，我们通过操作j指针就改变了i的值。虽然毫无意义，但是证明了通过unsafe.Pointer，我们可以将*int转化成*float64 unsafe.Pointer 四原则 1.任何指针都可以转化为unsafe.Pointer2.unsafe.Pointer 可以转化为任何指针3.uintptr可以转化为unsafe.Pointer4.unsafe.Pointer可以转化为uintptr 规则1,2我们前面已经演示过了，3,4是干什么的？*T 不能计算偏移量，也不能计算便宜。但是uintptr可以。所以，涉及到指针运算的时候，我们可以转化为uintptr计算，之后再转化回去。利用uintprt 我们可以访问特定的内存，可以达到对特定内存的读写 uintptr写一个uintptr直接操作内存的代码123456789101112131415161718192021import ( "fmt" "unsafe")type user struct &#123; name string age int64&#125;func main() &#123; u := new(user) fmt.Printf("%T\n",u) pname := (*string)(unsafe.Pointer(u)) *pname = "xuxiaofeng" page := (*int64)(unsafe.Pointer(uintptr(unsafe.Pointer(u))+unsafe.Offsetof(u.age))) *page = 26 // print u fmt.Println(u) //&amp;&#123;xuxiaofeng 26&#125;&#125; name值是user的第一个字段，不用偏移age 是第二个字段，需要便宜。就需要用到uintptr和unsafe.Pointer 注意事项 如若改成下面的代码，虽然从逻辑上是对的但是这里会牵涉到GC，如果我们的这些临时变量被GC，那么导致的内存操作就错了，我们最终操作的，就不知道是哪块内存了，会引起莫名其妙的问题。123temp:=uintptr(unsafe.Pointer(u))+unsafe.Offsetof(u.age)pAge:=(*int)(unsafe.Pointer(temp))*pAge = 20]]></content>
      <categories>
        <category>golang学习</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>指针转化</tag>
        <tag>unsafe</tag>
        <tag>Pointer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go指针类型转化 unsafe Pointer]]></title>
    <url>%2F2019%2F01%2F04%2Fgolang-2019-01-05-go%E5%8F%8D%E5%B0%84%E8%A7%84%E5%88%99-the-law-of-reflection%2F</url>
    <content type="text"><![CDATA[参考文章https://segmentfault.com/a/1190000006190038https://mikespook.com/2011/09/%E5%8F%8D%E5%B0%84%E7%9A%84%E8%A7%84%E5%88%99/]]></content>
      <categories>
        <category>golang学习</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>指针转化</tag>
        <tag>unsafe</tag>
        <tag>Pointer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[golang切片的使用和本质]]></title>
    <url>%2F2019%2F01%2F03%2Fgolang-2019-01-03-golang%E5%88%87%E7%89%87%E4%BD%BF%E7%94%A8%E5%92%8C%E6%9C%AC%E8%B4%A8%2F</url>
    <content type="text"><![CDATA[内部实现切片中有三个字段， 指向底层数组的指针 切片的长度 切片的容量 声明和初始化12345678910111213141516171819202122// 方式1：声明s1 := make([]int,5)s2 := make([]int,5,10)// 直接创建并且初始哈s3 := []int&#123;1,2,3,4,5&#125;s4 := []int&#123;4:6&#125; //第四个元素是6，其他的默认// 数组和切片的区别slice := []int&#123;4:1&#125; //切片array := [5]int&#123;4:1&#125;// 空切片和nil切片// 切片还有nil切片和空切片，它们的长度和容量都是0，但是它们指向底层数组的指针不一样// nil切片意味着指向底层数组的指针为nil，而空切片对应的指针是个地址s6 := []int&#123;&#125; //空切片var s7 []int // nil切片// 基于现有的切片或数组创建sl := []int&#123;1,2,3,4,5&#125;sl1 := sl[:]sl2 := sl[:2] 基于数据或者切片创建新切片基于数据或者切片创建一个新切片后，新切片和原切片共用一个底层数组 基于切片创建新切片 1234567func main() &#123; s := []int&#123;1,2,3,4,5&#125; s1 := s[:] fmt.Println(s1) //[1 2 3 4 5] s[0] = 88 fmt.Println(s1) //[88 2 3 4 5] &#125; 基于数组创建新切片 12345678func main() &#123; s := [5]int&#123;1,2,3,4,5&#125; s1 := s[:] fmt.Println(s1) //[1 2 3 4 5 ] s[0] = 88 fmt.Println(s1) //[88 2 3 4 5] &#125; 新切片的长度和容量12345678910111213141516171819func main() &#123; s := []int&#123;1,2,3,4,5,6&#125; fmt.Println(len(s)) // 6 fmt.Println(cap(s)) //6 s1 := s[1:2] fmt.Println(len(s1)) // 1 fmt.Println(cap(s1)) // 5 s2 := s[1:5] fmt.Println(len(s2)) //4 fmt.Println(cap(s2)) //5 s3 := s[0:2] fmt.Println(len(s3)) //2 fmt.Println(cap(s3)) //6&#125; 规律就是：新切片长度还算正常，但是容量就是从你截取的部分一直到原切片容量的结束。这也符合切片在内存中线性分布的特征 切片的使用长度和容量房12345func main() &#123; s := make([]int,5,10) fmt.Println(len(s)) // 5 fmt.Println(cap(s)) // 10&#125; 取值和修改123456func main() &#123; s := make([]int,5,10) fmt.Println(s[2]) // 0 s[2] = 88 fmt.Println(s[2]) // 88&#125; append可用容量足够12345678910func main() &#123; s := []int&#123;1,2,3,4,5&#125; s1 := s[1:3] fmt.Println(s1) //[2,3] fmt.Println(cap(s1)) s1 = append(s1,66) fmt.Println(s1) //[2,3,66] fmt.Println(s) //[1,2,3,66,5]&#125; s1中增加66很正常，为什么s的值中也会去掉4，而增加66呢？ s1有可用的容量，不会创建新的切片来满足追加 s1和s共用一个底层数组其实这里的追加只是把第四个元素4，替换成了66 可用容量不够当容量不够的时候，会把原来的数组复制一份，再增加新值，这时候对新切片的操作就不会影响旧切片了。123456789101112131415161718func main() &#123; s := []int&#123;1,2,3,4,5&#125; s1:= s[:] fmt.Printf("%p:%v\n",s1,s1) //0x452000:[1 2 3 4 5] // 此时两者共用一个底层数组，一个变都变 s1[0] = 66 fmt.Println(s) //[66 2 3 4 5] fmt.Println(s1) //[66 2 3 4 5] // s1 append之后，容量不够了，会把底层数组复制一份。 s1 = append(s1,6) fmt.Println(s) //[66 2 3 4 5] fmt.Println(s1) //[66 2 3 4 5 6] // 再改变s1,s就没有收到影响 s1[0] = 88 fmt.Println(s) //[66 2 3 4 5] fmt.Println(s1) //[88 2 3 4 5 6] &#125; 建议：我们再创建切片的时候，尽量让长度和容量相同。这样我们再追加操作的时候，就可以生成新的底层数据。会减免一些共用底层数据引起的错误。 append函数会智能的增长底层数组的容量，目前的算法是：容量小于1000个时，总是成倍的增长，一旦容量超过1000个，增长因子设为1.25，也就是说每次会增加25%的容量。 我们看append函数的定义：1func append(slice []Type, elems ...Type) []Type 所以我们可以穿多个值，也可以传切片123s1 := []int&#123;1,2,3,4,5&#125;s1 = append(s1,6,7)s1 = append(s1,[]int&#123;8,9&#125;...) slice append灾难首先分析下面的代码1234567891011type Slice []intfunc (A Slice)Append(value int) &#123; A = append(A, value)&#125;func main() &#123; mSlice := make(Slice, 10, 20) mSlice.Append(5) fmt.Println(mSlice)&#125; 抛开代码的规范性不说，这段代码本意是要调用一次mSlice.Append(5) ,就往mSlice中添加一个值。但是结果却是无论怎么Append，mSlice都不变。这里有一篇详细的解释https://www.flysnow.org/2018/12/21/golang-sliceheader.html其实主要的区别就是这句话中A = append(A, value),=两边的A已经不是同一个了。我们可以更改一下代码1234567891011121314type Slice []intfunc (A Slice)Append(value int) &#123; A1 := append(A,value) fmt.Printf("%p\n",A) fmt.Printf("%p\n",A1) &#125;func main() &#123; mSlice := make(Slice, 10, 20) mSlice.Append(5) fmt.Println(mSlice)&#125; ？？打印出来的是相同的啊，为什么说不一样，看下面 SliceHeaderSliceHeader是Slice运行时的具体表现，它的结构定义如下：12345type SliceHeader struct &#123; Data uintptr Len int Cap int&#125; 我们把代码改变成这样1234567891011func (A Slice)Append(value int) &#123; A1 := append(A, value) sh:=(*reflect.SliceHeader)(unsafe.Pointer(&amp;A)) fmt.Printf("A Data:%d,Len:%d,Cap:%d\n",sh.Data,sh.Len,sh.Cap) sh1:=(*reflect.SliceHeader)(unsafe.Pointer(&amp;A1)) fmt.Printf("A1 Data:%d,Len:%d,Cap:%d\n",sh1.Data,sh1.Len,sh1.Cap)&#125;// A Data:4530176,Len:10,Cap:20// A1 Data:4530176,Len:11,Cap:20 这下大家明白了吧，他们的Len不一样，并不是一个Slice，所以使用append方法并没有改变原来的A，而是新生成了一个A1,A1只是在方法内有效。而且新生成的A1并没有return。即使Dreamerque这位朋友通过如下代码 A = append(A, value) 进行复制，也只是一个mSlice的拷贝A的指向被改变了，而且这个A只在Append方法内有效（其实就是上面的A1），mSlice本身并没有改变，所以输出的mSlice不会有任何变化。 这里正确的做法是让Append返回append后的结果。其实对于内置函数append的使用，Go语言(golang)官方做了说明的，要保存返回的值。 Append returns the updated slice. It is therefore necessary to store the result of append]]></content>
      <categories>
        <category>golang学习</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>切片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[标志寄存器]]></title>
    <url>%2F2018%2F12%2F22%2Fstudy-%E7%BC%96%E7%A8%8B%E8%BE%BE%E4%BA%BA-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%913%E6%9C%9F%E5%AD%A6%E4%B9%A0-2018-12-25-%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8%2F</url>
    <content type="text"><![CDATA[crackme.exe 引出标志寄存器现在有一个crackme.exe的程序，进去后需要我们注册成功后才可以使用。要想破解这个小软件，我们需要掌握哪些东西呢？ PE 断点我们随便输入一个用户名和密码，就会弹出一个失败提示框。我们就在弹出提示框的地方打断点。 win32 API我们知道要在弹出提示框的地方打断点，可是只有我们知道了win32的API后，我们才知道， 那就是一个messageBoxAbp messageBoxA 函数调用 熟悉堆栈，熟练绘画堆栈图 如果熟悉堆栈，肯定知道，一个函数调用的时候，栈顶的位置肯定放着它的放回地址。所以函数执行完毕后，就会返回到栈顶编号对应的位置。 call 、 jcc and 标志寄存器最后判断我们输入的对不对，是否继续，其实就是判断某个标志寄存器中的值 copy to executable -&gt; 保存即可完成我们的修改 以上的东西其实就是暴力破解，不管你算法多么优秀，我们只找那个关键点，让你直接进行下一步 标志寄存器这就是计算机中的标志寄存器，说到标志我们就应该想到flag，bool类型。而一个bool类型用1bit就可以表示了，所以我们谈论这个32位的标志寄存器，更多的时候是讨论其中的某一位。比如0位，2位，4位，都是cpu中设定好的用途，就跟通用寄存器一样，有自己的名字。比如C位，P位，O位。 进位标志位CF（carry flag） 如果运算结果的最高位产生了一个进位或借位，那么，其值为1，否则其值为0。 三个实验:1234567891011mov al,0xffadd al,2 // c位变成1mov al,0xfe // mov不是运算所以C位不变// C位手动清零add al,2 // c位又变成1// C位手动清零mov ax,0xffadd ax,2 // c位已经是0// =========================重点// 标志寄存器在学习过程中，我们一定要明白数据的宽度 //【mov ax，0xff 】中，数据的宽度是16位，add之后，确实是进位了，但不是最高位的进位 补充：什么是运算？mov不算是运算，其他的加减乘除异或等都是运算 奇偶标志位：PF（Parity Flag） PF 反应运算结果中“1”的个数的奇偶性，如果1的个数是偶数，则P位是1，如果1的个数是奇数，则P位是0 实验12MOV AL,3 // 00001011 p位：0add al,2 // 00001010 P位：1 辅助进位标志AF(Auxiliary Carry Flag) 在发生下列情况时，辅助进位标志AF的值被置为1，否则其值为0：(1)、在字节操作时，发生低字节向高字节进位或借位时；(2)、在字节操作时，发生低4位向高4位进位或借位时。大白话说下，就是运算时，把位划分成两半，低位的一半的第一位如果向高位进位（加）或者借位（减）时，A位就是1如下图，就看突出的那一位32位运算： _ _ _ _ - _ _ _16位运算： _ _ - _8位运算： _ - 实验：123456789// 第一组MOV EAX,0x55EEFFFFADD EAX,2 // A位变1// 第二组MOV AX,5EFE add ax,2 // A位又变1// 第三组MOV AL,4Eadd al,2 // A位又变1 零标志ZF(Zero Flag) 零标志ZF用来反映运算结果是否为0如果运算结果为0，则其值为1，否则其值为0。在判断运算结果是否为0时，可使用此标志位。 实验1234XOR EAX,EAX // Z位：1// 这句话的作用有两个// 1.将EAX的值变为1// 2.将标志位Z位置为1。如果[mov eax,0] 的话就没有第二个作用了,mov就不是运算 符号标志SF(Sign Flag) 符号标志SF用来反映运算结果的符号位，它与运算结果的最高位相同。特别注意：这里的最高位说的是二进制的最高位，所以只能是0或1 12MOV AL,7FADD AL,2 // 1 溢出标志OF(Overflow Flag) 溢出标志OF用于反映有符号数加减运算所得结果是否溢出。如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF的值被置为1，否则，OF的值被清为0。 最高位进位（CF）和溢出（OF）的区别？这里主要涉及到了无符号整数和有符号整数。计算机在存储的时候，并不知道自己存储的是有符号整数还是无符号整数。只有使用的人才知道，就是程序员喽。C位是做无符号运算时该关注的O位是做有符号运算时该关注的 想知道现在计算的结果有没有溢出，是看CF位还是OF位？我要看那个取决于我做的是有符号还是无符号运算。 如果你知道自己做的是无符号运算，你只用看C位，不用管O位如果你知道自己的做的是有符号运算，只要看O位，不用管C位 好好看这个图就什么都明白了 正数+负数，一定在圈内，永远不会溢出正数+正数，如果结果为负数（超过7F内），一定溢出。因为越界了，两个正数相加不应该是负数。 说结果之前，一定要指定到底是无符号运算还是有符号预算。 自己这个分析判断是错误的，其实只要是圈上的点可以表示的，都没有溢出，圈上的点不能表示的，就是溢出了。只是有符号的话，只有右边区域表示正数，左边区域表示负数无符号的话，整个区域都可以表示 和标志寄存器相关的指令ADC指令：带进位加法 百度百科：ADC 带进位的加法指令 ADC Reg/Mem, Reg/Mem/Imm 功能，将目的操作数和源操作数相加再加低位进位，结果送入目的的地址 dst+src+cf-&gt;dst， 受影响的标志位：AF、CF、OF、PF、SF和ZF，该指令的功能是把源操作数和进位标志位CF的值(0/1)一起加到目的操作数中。 实验12345MOV AL,1MOV CL,2ADC AL,CL //按照我们正常的ADD指令，此时AL中应该是3// 但是ADC指令是带进位的加法,它会把c位中的值也给加上。// 如果此时cf中的值是1，那结果:AL中的值是4，cf的值：0 注意事项：1.两边 SBB指令：带借位减法 百度百科的解释很明确SBB：带借位减法， 格式：SBB DST,SRC, 执行的操作：（DST)←(DST)-(SRC)-CF,其中CF为进位的值。 SBB Compents ：他们组成了Application .他们以何种方式组合是由SLEE来确定的。 实验123456MOV AL,3MOV CL,1SBB AL,CL // 分两种情况：// 1. 如果cf是0，那么结果和我们预想的一样，2// 2. 如果cf是1，那么结果还会减1，结果al变为1了 XCHG指令：交换数据 百度百科交换指令XCHG是两个寄存器，寄存器和内存变量之间内容的交换指令，两个操作数的数据类型要相同，可以是一个字节，也可以是一个字，也可以是双字 说明什么？我们交换的是两个容器，不能是立即数而且交换的两个容器不能都是内存 123456// 实验：MOV AL,1MOV CL,3XCHG AL,CL // AL变成3，CL变成了1XCHG DWORD PTR DS:[0X0019FF74],EAX MOVS指令：移动数据看了一下通用寄存器中EDI和ESI的分工：再回顾一下通用寄存器的划分：https://xuxiaofeng.gitlab.io/2018/12/12/study-%E7%BC%96%E7%A8%8B%E8%BE%BE%E4%BA%BA-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%913%E6%9C%9F%E5%AD%A6%E4%B9%A0-2018-12-12-%E8%BF%9B%E4%B8%80%E6%AD%A5%E5%AD%A6%E4%B9%A0%E5%AF%84%E5%AD%98%E5%99%A8/ 现在我们来解释MOVS指令 movs指令是用来复制一个数据项（字节，字或双字）从源字符串到目标字符串。原字符串又ESI/SI/DH 指出，目标字符串又EDI/DI/BH指出。（具体又那个指出，我们需要看使用时定义的单位） 这里还有一段解释：MOVS指令可以把由（SI）指向的数据段中的一个字（或字节）传送到由（DI）指向的附加段中的一个字（或字节）中去，同时根据方向标志(df标志寄存器)及数据格式（字 或字节）对SI和DI进行修改 在执行该指令前，应该先做好以下 准备工作： 1） 把存放于数据段中的源串首地址（如反向传送则应是末地址）放入SI寄存器中； 2） 把将要存放数据串的附加段中的目的串首地址（或反向传送时的末地址）放入DI寄存器中； 3） 建立方向标志。 实验首先说明一下，我们之前碰到内存的时候，我们总是这样表示DS:[],没错。但是碰到EDI表示内存地址单元时，我们应该这样ES:[],所以往下，我们会经常看到这样的字符：ES:[EDI] （这里涉及到段、页的概念）123 1.直接输入movs，点击确定，编辑器就会自动给我们生成下面的额语句 充分说明了这个指令是针对EDI和ESI的MOVS DWORD PTR ES:[EDI],DWORD PTR DS:[ESI] 12345678mov edi,0019ff88mov esi,0019ff80MOVS DWORD PTR ES:[EDI],DWORD PTR DS:[ESI] 结果edi:0019ff8cesi:0019ff84并且刚才edi对应内存编号中的值和dsi对应内存编号中的值确实做了交换我们发现EDI和ESI中的值都+4 了。这是有D位（df标志寄存器决定的） 所以这个MOVS指令有两个主要影响，一是真的交换了寄存器对应内存地址单元中的值，二是根据DF标志寄存器中的值，让ESI和EDI都进行一些位移。 STOS指令：讲Al/AX/EAX的值存储到[EDI]指定的内存单元 到底是复制AL还是AX还是EAX，是又我们指定的内存宽度决定的。复制完毕后，EDI的变化方向是由我们的D位（df标志寄存器）决定的。 12345678// 实验mov eax,12345678mov edi,0019ff88直接数据stos，确定酒水弹出下面的值STOS DWORD PTR ES:[EDI]运行结果（D位此时是0）DEI：0019FF8C内存单元0019FF88中的值：12345678 REP指令：按计数寄存器 (ECX) 中指定的次数重复执行字符串指令这里有一个把movs和rep指令糅合在一起的解释 MOVS指令可以把由（SI）指向的数据段中的一个字（或字节）传送到由（DI）指向的附加段中的一个字（或字节）中去，同时根据方向标志及数据格式（字 或字节）对SI和DI进行修改。当该指令与前缀REP联用时，则可将数据段中的整串数据传送到附加段中去。这里源串必须在数据段中，目的串必须在附加段 中，但源串允许使用段跨越前缀来修改。在与REP联用时还必须先把数据串的长度送到CX寄存器中，以便控制指令结束。因此在执行该指令前，应该先做好以下 准备工作： 1） 把存放于数据段中的源串首地址（如反向传送则应是末地址）放入SI寄存器中； 2） 把将要存放数据串的附加段中的目的串首地址（或反向传送时的末地址）放入DI寄存器中； 3） 把数据串长度放入CX寄存器； 4） 建立方向标志。在完成这些准备工作后就可使用串指令传送信息了 123MOV ECX,10REP MOVSDREP STOSD]]></content>
      <categories>
        <category>滴水逆向三期视频教程</category>
      </categories>
      <tags>
        <tag>滴水逆向</tag>
        <tag>汇编</tag>
        <tag>标志寄存器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git系统学习]]></title>
    <url>%2F2018%2F12%2F21%2Ftools-git-2018-12-21-git%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[git的特性 版本控制最终版，最终版1，最终版2 分布式分布式和集中式都需要中央服务器，不同的是分布式在工作电脑上保存了服务器的完整工程，即使服务器挂掉了，也不会影响工作电脑上的开发。集中式就不可以了。中央服务器挂掉，其他人就都不可以开发了。 git的安装和基本使用安装1sudo apt-get install git 基本使用1234567891011//目录初始化git init // 创建版本vim code.txtgit add code.txtgit commit -m &quot;create file code.txt&quot;// 查看版本记录git log// 版本回退git reset --hard HEAD^ // HEAD表示当前的最新版本，也可以用版本编号（commit hash）// HEAD^也是这样表示HEAD~1,回退四个版本git reset --hard HEAD~4 使用git reset 回退到低版本后，高版本并没有删掉。（但是git log看不到了）如果我们现在又想回到高版本该如何做？git log看不到高版本的版本编号了，我们可以用git reflog 查看历史操作。就会看到我们高版本的commit hash（版本编号）git reset --hard 版本编号 工作区和版本库工作区就是本地工作的目录版本库就是我们工作区下面的.git文件。 git版本库里有很多东西，其中最重要的就是本称为stage（或者叫index）的暂存区。 已经git add 到暂存区的文件，如何恢复？git reset HEAD 就相当于git add 命令的倒退，从暂存区清理code.txt,但是工作区的修改依然在。此时用git status，应该又提示文件修改，需要你git add git只会用暂存区的修改来创建版本，工作区的修改如果没有添加到暂存区。git commit创建的版本中是不会包括工作区修改的内容的。vim code.txt -&gt; 添加第一行git add code.txtvim code.txt -&gt; 添加第二行// 没有git add 直接git commitgit commit -m “update code.txt” // 这个版本中是没有第二行内容的 撤销修改编辑完工作区后，想撤销对工作区的修改1git checkout -- &lt;file&gt; 编辑完文件，git add 提交到暂存区，突然又不想到暂存区的此文件的改动了123git reset HEAD &lt;file&gt; // 这就是取消暂存想要继续丢弃工作区的改动git checkout -- &lt;file&gt; 总结撤销修改的三种情况1.只在工作区修改，还没有提交到暂存区git checkout – 2.工作区修改后，git add 提交到了暂存区git reset head git checkout – 3 git add 并且已经git commitgit reset –hard HEAD^ git对比文件工作区和版本库中的对比git diff HEAD – 将工作区和版本库HEAD进行比较如何看比较的内容？—和+++ ，分队对应diff后面的第一个和第二个 — a/ 代表HEAD版本中的+++ b/ 代表工作区的前面没有出现+或者-的，就是两个文件共有的 两个版本库中的对比git diff HEAD HEAD^ 删除文件12345rm &lt;file&gt;// 将删除的改动提交到暂存区git add &lt;file&gt;// 将删除的改动提交到版本库git commit - &quot;delete&quot; rm 和 git add ,两个命令可以合为一个，git rm 恢复删除删除文件也是对工作区的改动，和上面修改文件的恢复是一样的。在工作区删除后，发现删错了。想要恢复怎么办？git checkout – 特别注意： 创建文件touch filename.txt后，如果没有git add添加到暂存区，git是不会开始管理这个文件的。这个时候，如果你直接rm filename.txt,就真的删掉了。因为git本来就没有跟踪这个文件。 分支管理工厂里面的流水线平行宇宙 创建分支与合并分支主分支，默认分支 master刚才我们说HEAD指向最新的commit，严格的说：HEAD是指向master，master才是指向最新的commit合并完分支之后，我们可以删除dev分支。删除dev分支就是把dev指针给删除掉。删掉后，我们就剩下一个master分支。 实验12345678910111213141516git branch //查看当前仓库又多少分支 * master // *代表当前在那个分支里面// 创建并切换到新的分支devgit checkout -b devvim code.txt -&gt; add online git add code.txt // 在dev分支中进行开发git commit -m &quot;dev 分支提交&quot; // 此时master分支并没有改变// 切换到master分支git checkout master// 查看master分支上有没有dev分支的操作记录git log --pretty=online //发现并没有dev分支的操作记录// 合并分支git merge dev 执行完命令后，我们发现出现又这样的提示，fast-forward，这属于快速合并。快速合并就是直接挪动master指针就可以。// 删除分支git branch -d dev 分支-解决冲突 合并分支往往不是一帆风顺的。当我们在两个分支上都对一个文件进行修改了。那执行git merge命令的时候，就会提示自动合并失败。并给出冲突失败文件。当然我们执行git status 也会看到合并有冲突的文件。 这时候我们该怎么做？需要手动融合，打开冲突文件进行手动融合。融合之后，需要做一次新的提交。gti add *，git commit - “”。HEAD指向master，master向前移动了，但是dev分支是不动的。 重点有时候我们需要看分支图例git log –graph –pretty=online 分支管理策略没有快速合并，但是也没有冲突 我们在dev分支和master分支都做了修改，但是修改的不是同一个文件。我们合并时，不能使用fast-forward模式了，但是并没有冲突。 当我们在master分支上git merge dev时，命令行中会出现一次弹窗，让我们输入一个commit信息。这种合并方式时recursive合并。这时候，git默认会给我们做一次新的提交。 强制禁止快速合并是在什么样的情景呢？ git checkout -b dev后，在dev分支做了修改，提交了好几个commit。git checkout master，然后git merge dev。此时没有冲突，快速合并成功。但是：我们在dev分支中的commit记录都没有了！！！ 解决办法，禁用fast-forwardgit merge --no-ff -m &#39;禁用fast-farword合并&#39; dev这样就会重新做一次新的提交。 –no-ff指的是强行关闭fast-forward方式。fast-forward方式就是当条件允许的时候，git直接把HEAD指针指向合并分支的头，完成合并。属于“快进方式”，不过这种情况如果删除分支，则会丢失分支信息。因为在这个过程中没有创建commitgit merge –squash 是用来把一些不必要commit进行压缩，比如说，你的feature在开发的时候写的commit很乱，那么我们合并的时候不希望把这些历史commit带过来，于是使用–squash进行合并，此时文件已经同合并后一样了，但不移动HEAD，不提交。需要进行一次额外的commit来“总结”一下，然后完成最终的合并。总结：–no-ff：不使用fast-forward方式合并，保留分支的commit历史–squash：使用squash方式合并，把多次分支commit历史压缩为一次 bug分支使用场景 我们正在dev分支上开发，突然接到任务说时让我们赶紧修复一个bug。可是我们当前的工作还没有做完，还不能提交。怎么办？ 我们可以把工作暂时保存起来。git stash就把我们的工作现场给保护起来了。git status一看，工作区都是干净的。1234567891011121314比如bug时在master分支下面，先git checkout master，然后创建bug分支git checkout -b bug001vim main.gogit add mian.gogit commit -m &quot;修复bug001&quot;git checkout mastergit merge --no-ff -m &apos;修复bug001合并&apos; bug001git branch -d bug001// 修复完成后，继续回到dev分支干活git status //工作区干净git stash list //列出保存的工作现场// 恢复现场git stash pop git status //已经回来了 修改bug时，先回到出现bug的分支上面。 分支管理小结 git基本操作小结 git常用操作github清空历史提交记录1234567891011121314151617181920212223241.Checkout git checkout --orphan latest_branch2. Add all the files git add -A3. Commit the changes git commit -am &quot;commit message&quot;4. Delete the branch git branch -D master5.Rename the current branch to master git branch -m master6.Finally, force update your repository git push -f origin master 修改commit提示已经git add,git commit，还没有git push ,如何修改commit信息？12git commit –amend在打开的vim编辑器中修改信息即可]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识堆栈之大白话堆栈]]></title>
    <url>%2F2018%2F12%2F20%2Fstudy-%E7%BC%96%E7%A8%8B%E8%BE%BE%E4%BA%BA-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%913%E6%9C%9F%E5%AD%A6%E4%B9%A0-2018-12-20-%E5%88%9D%E8%AF%86%E5%A0%86%E6%A0%88%E4%B9%8B%E5%A4%A7%E7%99%BD%E8%AF%9D%E5%A0%86%E6%A0%88%2F</url>
    <content type="text"><![CDATA[什么是堆栈引出堆栈在学习堆栈之前，我们需要从之前寄存器和内存中引出堆栈，我们要思考堆栈有什么必要性？现在假设我们需要一块内存，它可以满足如下功能 1.主要用于临时存储一些数据 能够记录存储了多少数据 可以很方便的找到需要的数据 对于第一条，有人说直接放寄存器不就可以了吗？但是如果我们有2个字节的数据，有5个字节的数据，都好说。但是如果我有几百，几千个数据呢？寄存器明显就不行了 还好有高人还有在我们之前，有那么多厉害的人。有人设计出这样一块内存，虽然简单，但却刚好满足了上面我们的三个需求。为了满足第二条，我们直接top-base；对于第三条，比如我们存储了500个数据，我们需要第50个，我们直接base+50个单位的偏移就可以找到。突然又需要第200个数据，base+200单位的偏移就是。这里的单位是指byte 还需要注意一点，在window系统中堆栈是往低位扩展了，起初会选择一个值比较大的位置作为base，然后每次往低位扩展，top不断变小。 实验，自己实现堆栈 1.我们使用32位寄存器EBX和EDX作为栈顶和栈底 。2.为了实验的方便，主要是DTDebug显示的方便。我们每次操作都操作4字节 压入数据我们就选中内存地址0019FF74吧12MOV EBX,0019FF74 //栈底的内存地址（base）MOV EDX,0019FF74 //栈顶的内存地址（top） 接下来我们有三种实现方式 方式一：先存储数据，再移动栈顶12MOV DWORD PTR ds:[EDX-4],0xAAAAAAAASUB EDX,4 方式二：先移动栈顶，再存储数据12SUB EDX,4MOV DWORD PTR DS:[EDX],0xBBBBBBBB 方法三先存储数据，再用LEA12mov dword ptr ds:[edx-4],0xCCCCCCCClea edx, dword ptr ds:[edx-4] 第二句话为什么不是这样lea edx,byte ptr ds:[edx-4]，暂时没有明白?不就是取地址吗？为了一定要4个字节呢？ 方法四：先lea，再存储数据 读取数据读取第N个数 方式一 方式二 弹出数据不光要读取栈顶的数据，还需要将栈顶的位置进行移动 操作系统实现的堆栈push and pop堆栈是软件设计常用的概念。如果每次我们需要的时候，都需要自己手动实现，效率也太低了。为此，操作系统联合cpu给我们实现了堆栈。如何联合的呢？cpu提供两个32位的寄存器，ESP和EBP，一个用来存储宅顶，一个用来存储栈底。其实对于cpu来说，这两个寄存器和其他的寄存器并没有什么特殊的地方，只是操作系统按照自己的习惯把他两区别对待了。这两个就用来存储栈顶和栈底，相当于cpu和操作系统的之间的约定。（突然想到了协议） 那之前我们所有的操作就可以再两个命令代替了12入栈用push出战用POP push和pop操作时，寄存器ESP变化宽度ESP中存储的是栈顶的位置，其实就是栈顶的内存编号。根据上一小节，我们每push一次，ESP中的值应该-4；每pop一次，ESP中值应该+4. question：ESP中的值，每次变化都是4吗？ 这个也是要分情况 push + 立即数,ESP中的内存编号-4push 0x1 push + 寄存器push al // 8位，不允许这样操作push ax // 16位，ESP中的内存编号-2 push + 内存push r8 push 8位的内存是不允许的push r16 push ESP中的内存编号-2push r32 psuh ESP中的内存编号-4 pop is same with push PUSHAD ADN POPADPUASHAD:把8个通用寄存器中的值存储到堆栈中。 然后我们可以随意的操作修改寄存器，当我们又需要恢复寄存器的时候： POPAD ,一个指令就解决问题 这里涉及到一个知识点，堆栈平衡，我们后续再讨论]]></content>
      <categories>
        <category>滴水逆向三期视频教程</category>
      </categories>
      <tags>
        <tag>滴水逆向</tag>
        <tag>汇编</tag>
        <tag>堆栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内存读写-内存寻址]]></title>
    <url>%2F2018%2F12%2F16%2Fstudy-%E7%BC%96%E7%A8%8B%E8%BE%BE%E4%BA%BA-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%913%E6%9C%9F%E5%AD%A6%E4%B9%A0-2018-12-16-%E5%86%85%E5%AD%98%E8%AF%BB%E5%86%99-%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80%2F</url>
    <content type="text"><![CDATA[DTDebug再介绍 左下角就是内存数据窗口。最下面是命令行窗口。我们可以输入命令查看某一块内存的数据db 0x0019FF74,然后enter，就可以查看到这个内存中的数据 存储数据的顺序问题我们往内存地址0x0019FF74中写入数据,当前0xmov dword ptr ds:[0x0019FF74],0x12345678F8执行内存数据区域显示的数据和堆栈区显示的数据不一致，why? 数据的存储时有顺序的，数据在内存中，总是高位在前，低位在后。 0x0019FF74 存储的是780x0019FF75 存储的是560x0019FF76 存储的是340x0019FF77 存储的是12 内存寻址通过前面很多的练习，我们可以发现，设计到内存读写最关键的就是，找到内存地址，也就是内存编号寻找地址有哪些格式呢，主要有下面5种 下面的所有操作中，我们一定要注意MOV和LEA的区别。 mov的前后操作数不能都是内存单元 mov是操作内存中的值lea是操作内存的地址 [立即数] 演示初始状态我们添加两条指令执行后的结果如果大家有迷惑，到底[0019FF74]位置存储的是12还是78？我们可以用命令证实一下：12mov dword ptr ds:[0x19FF74],0x12345678mov byte ptr ds:[0x19FF74],0x00 结果说明byte ptr ds[0x19FF74]存储的是78 LEA获取内存编号再实验一下：初始状态添加三条命令第二条运行完毕第三条运行完毕 [reg] reg代表寄存器 可以是8个通用寄存器中的任意一个 [reg+立即数] [reg+reg*{1,2,4,8}] 注意这里只能是1、2、4、8，不能是其他的任何数字 [reg+reg*{1,2,4,8}+立即数]]]></content>
      <categories>
        <category>滴水逆向三期视频教程</category>
      </categories>
      <tags>
        <tag>滴水逆向</tag>
        <tag>汇编</tag>
        <tag>内存读写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python爬虫005：本地代理proxy请求]]></title>
    <url>%2F2018%2F12%2F15%2Fstudy-python%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B-2018-12-15-python%E7%88%AC%E8%99%AB005%EF%BC%9A%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%90%86proxy%2F</url>
    <content type="text"><![CDATA[post请求1234567#encoding:utf-8import urllib2data="first=true&amp;p=1&amp;kd=python"header=&#123;'User-Agent':'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36'&#125;request = urllib2.Request("https://www.lagou.com/jobs/positionAjax.json",headers=header)request.add_data(data) #这行代码就决定了这是一个post请求print urllib2.urlopen(request).read() 这段是模拟拉勾网的请求，但是返回的提示一直是请求过去频繁。说明代码还是有问题的 postcgi暂时不明白，感觉应该是一种post协议吧。希望知道者告知，感激不尽。 为什么有些post请求也可以在url开到请求的的数据？待解决中，只知道确实是有些post请求参数也是现实的url中]]></content>
      <categories>
        <category>python分布式爬虫教程</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>post</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python爬虫004：模拟手机百度请求]]></title>
    <url>%2F2018%2F12%2F15%2Fstudy-python%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B-2018-12-15-python%E7%88%AC%E8%99%AB004%EF%BC%9A%E6%A8%A1%E6%8B%9F%E6%89%8B%E6%9C%BA%E7%99%BE%E5%BA%A6%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[post请求1234567#encoding:utf-8import urllib2data="first=true&amp;p=1&amp;kd=python"header=&#123;'User-Agent':'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36'&#125;request = urllib2.Request("https://www.lagou.com/jobs/positionAjax.json",headers=header)request.add_data(data) #这行代码就决定了这是一个post请求print urllib2.urlopen(request).read() 这段是模拟拉勾网的请求，但是返回的提示一直是请求过去频繁。说明代码还是有问题的 postcgi暂时不明白，感觉应该是一种post协议吧。希望知道者告知，感激不尽。 为什么有些post请求也可以在url开到请求的的数据？待解决中，只知道确实是有些post请求参数也是现实的url中]]></content>
      <categories>
        <category>python分布式爬虫教程</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>手机代理proxy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python爬虫003：urllib post请求]]></title>
    <url>%2F2018%2F12%2F15%2Fstudy-python%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B-2018-12-15-python%E7%88%AC%E8%99%AB003%EF%BC%9Aurllib-post%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[post请求1234567#encoding:utf-8import urllib2data="first=true&amp;p=1&amp;kd=python"header=&#123;'User-Agent':'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36'&#125;request = urllib2.Request("https://www.lagou.com/jobs/positionAjax.json",headers=header)request.add_data(data) #这行代码就决定了这是一个post请求print urllib2.urlopen(request).read() 这段是模拟拉勾网的请求，但是返回的提示一直是请求过去频繁。说明代码还是有问题的 postcgi暂时不明白，感觉应该是一种post协议吧。希望知道者告知，感激不尽。 为什么有些post请求也可以在url开到请求的的数据？待解决中，只知道确实是有些post请求参数也是现实的url中]]></content>
      <categories>
        <category>python分布式爬虫教程</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>post</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python爬虫002：代理user-agent和response信息、get请求]]></title>
    <url>%2F2018%2F12%2F14%2Fstudy-python%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B-2018-12-14-python%E7%88%AC%E8%99%AB002-%E4%BB%A3%E7%90%86user-agent%E5%92%8Cresponse%E4%BF%A1%E6%81%AF%E3%80%81get%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[response网络详细信息python2中urllib和urllib2的区别参考地址：https://blog.csdn.net/qq_34327480/article/details/79161794 在python2中，urllib和urllib2都是接受URL请求的相关模块，但是提供了不同的功能。两个最显著的不同如下：1、urllib2可以接受一个Request类的实例来设置URL请求的headers2、urllib仅可以接受URL。这意味着，你不可以伪装你的User Agent字符串等。 python3使用urllib123456789#py3import urllib.request#pycharm go declaration to search source codedef download(url): response = urllib.request.urlopen(url, timeout = 5) print(type(response))# class http.client.httpresponseprint(response.info()) #class http.client.HTTPMessageprint(download("http://ww.baidu.com")) python2使用urllib2python2里面没有urllib.reqeust,我们直接用urllib2替换即可还有开头的coding:utf-81234567891011121314151617#py2#coding:utf-8import urllib2def download(url): response = urllib2.urlopen(url, timeout = 5) print(type(response))# class http.client.httpresponse print(response.info()) #包含了网站的详细信息 print(response.read()) #read source coad#括号内是控制多少字符的问题#写爬虫记得try catchtry: print(download("http://ww.google.com"))except urllib2.URLError as e: print("网络异常", e) #抓住错误对象类型当作变量 或者123456import urllib2req = urllib2.Request(&apos;http://www.example.com/&apos;)req.add_header(&apos;Referer&apos;, &apos;http://www.python.org/&apos;)# Customize the default User-Agent header value:req.add_header(&apos;User-Agent&apos;, &apos;urllib-example/0.1 (Contact: . . .)&apos;)r = urllib2.urlopen(req) response信息再贴一下打印response.info()的信息1234567891011121314151617181920Bdpagetype: 1Bdqid: 0xe33c14ce00005740Cache-Control: privateContent-Type: text/htmlCxy_all: baidu+7b2f0340f919578bfe3264aa8c0016f8Date: Sun, 02 Dec 2018 03:03:24 GMTExpires: Sun, 02 Dec 2018 03:03:01 GMTP3p: CP=&quot; OTI DSP COR IVA OUR IND COM &quot;Server: BWS/1.1Set-Cookie: BAIDUID=00813CE4F82EFFA6488DB896F424E587:FG=1; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.comSet-Cookie: BIDUPSID=00813CE4F82EFFA6488DB896F424E587; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.comSet-Cookie: PSTM=1543719804; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.comSet-Cookie: delPer=0; path=/; domain=.baidu.comSet-Cookie: BDSVRTM=0; path=/Set-Cookie: BD_HOME=0; path=/Set-Cookie: H_PS_PSSID=1441_25810_21122_22159; path=/; domain=.baidu.comVary: Accept-EncodingX-Ua-Compatible: IE=Edge,chrome=1Connection: closeTransfer-Encoding: chunked 注意参数里面有一个Bdqid,这是百度给每个用户的唯一标识 response.read()查看全部网页源代码 response.read(100)查看网页源代码的前100个字节 写爬虫的时候多家try，catch agent就像大会狼冒充大白兔1234567891011#encoding: utf-8import urllib2def download(url): headers = &#123;"User Agent : "&#125; request = urllib2.Request(url, headers = headers) #发起请求 data = urllib2.urlopen(request).read() #打开请求，抓取数据 return dataurl = "https://sou.zhaopin.com/?jl=613&amp;kw=" + searchname + "&amp;kt=3"print download(url) 上面这段代码构造了一个request，在python2的情况下 常见的代理手机代理123456789101112131415161718192021222324252627282930safariiOS4.33–iPhoneUser-Agent:Mozilla/5.0(iPhone;U;CPUiPhoneOS4_3_3likeMacOSX;en-us)AppleWebKit/533.17.9(KHTML,likeGecko)Version/5.0.2Mobile/8J2Safari/6533.18.5safariiOS4.33–iPodTouchUser-Agent:Mozilla/5.0(iPod;U;CPUiPhoneOS4_3_3likeMacOSX;en-us)AppleWebKit/533.17.9(KHTML,likeGecko)Version/5.0.2Mobile/8J2Safari/6533.18.5safariiOS4.33–iPadUser-Agent:Mozilla/5.0(iPad;U;CPUOS4_3_3likeMacOSX;en-us)AppleWebKit/533.17.9(KHTML,likeGecko)Version/5.0.2Mobile/8J2Safari/6533.18.5AndroidN1User-Agent:Mozilla/5.0(Linux;U;Android2.3.7;en-us;NexusOneBuild/FRF91)AppleWebKit/533.1(KHTML,likeGecko)Version/4.0MobileSafari/533.1AndroidQQ浏览器ForandroidUser-Agent:MQQBrowser/26Mozilla/5.0(Linux;U;Android2.3.7;zh-cn;MB200Build/GRJ22;CyanogenMod-7)AppleWebKit/533.1(KHTML,likeGecko)Version/4.0MobileSafari/533.1AndroidOperaMobileUser-Agent:Opera/9.80(Android2.3.4;Linux;OperaMobi/build-1107180945;U;en-GB)Presto/2.8.149Version/11.10AndroidPadMotoXoomUser-Agent:Mozilla/5.0(Linux;U;Android3.0;en-us;XoomBuild/HRI39)AppleWebKit/534.13(KHTML,likeGecko)Version/4.0Safari/534.13BlackBerryUser-Agent:Mozilla/5.0(BlackBerry;U;BlackBerry9800;en)AppleWebKit/534.1+(KHTML,likeGecko)Version/6.0.0.337MobileSafari/534.1+WebOSHPTouchpadUser-Agent:Mozilla/5.0(hp-tablet;Linux;hpwOS/3.0.0;U;en-US)AppleWebKit/534.6(KHTML,likeGecko)wOSBrowser/233.70Safari/534.6TouchPad/1.0NokiaN97User-Agent:Mozilla/5.0(SymbianOS/9.4;Series60/5.0NokiaN97-1/20.0.019;Profile/MIDP-2.1Configuration/CLDC-1.1)AppleWebKit/525(KHTML,likeGecko)BrowserNG/7.1.18124WindowsPhoneMangoUser-Agent:Mozilla/5.0(compatible;MSIE9.0;WindowsPhoneOS7.5;Trident/5.0;IEMobile/9.0;HTC;Titan)UC无User-Agent:UCWEB7.0.2.37/28/999UC标准User-Agent:NOKIA5700/UCWEB7.0.2.37/28/999UCOpenwaveUser-Agent:Openwave/UCWEB7.0.2.37/28/999UCOperaUser-Agent:Mozilla/4.0(compatible;MSIE6.0;)Opera/UCWEB7.0.2.37/28/999 电脑代理12345678910111213141516171819202122232425262728293031323334353637383940safari5.1–MACUser-Agent:Mozilla/5.0(Macintosh;U;IntelMacOSX10_6_8;en-us)AppleWebKit/534.50(KHTML,likeGecko)Version/5.1Safari/534.50safari5.1–WindowsUser-Agent:Mozilla/5.0(Windows;U;WindowsNT6.1;en-us)AppleWebKit/534.50(KHTML,likeGecko)Version/5.1Safari/534.50IE9.0User-Agent:Mozilla/5.0(compatible;MSIE9.0;WindowsNT6.1;Trident/5.0IE8.0User-Agent:Mozilla/4.0(compatible;MSIE8.0;WindowsNT6.0;Trident/4.0)IE7.0User-Agent:Mozilla/4.0(compatible;MSIE7.0;WindowsNT6.0)IE6.0User-Agent:Mozilla/4.0(compatible;MSIE6.0;WindowsNT5.1)Firefox4.0.1–MACUser-Agent:Mozilla/5.0(Macintosh;IntelMacOSX10.6;rv:2.0.1)Gecko/20100101Firefox/4.0.1Firefox4.0.1–WindowsUser-Agent:Mozilla/5.0(WindowsNT6.1;rv:2.0.1)Gecko/20100101Firefox/4.0.1Opera11.11–MACUser-Agent:Opera/9.80(Macintosh;IntelMacOSX10.6.8;U;en)Presto/2.8.131Version/11.11Opera11.11–WindowsUser-Agent:Opera/9.80(WindowsNT6.1;U;en)Presto/2.8.131Version/11.11Chrome17.0–MACUser-Agent:Mozilla/5.0(Macintosh;IntelMacOSX10_7_0)AppleWebKit/535.11(KHTML,likeGecko)Chrome/17.0.963.56Safari/535.11傲游（Maxthon）User-Agent:Mozilla/4.0(compatible;MSIE7.0;WindowsNT5.1;Maxthon2.0)腾讯TTUser-Agent:Mozilla/4.0(compatible;MSIE7.0;WindowsNT5.1;TencentTraveler4.0)世界之窗（TheWorld）2.xUser-Agent:Mozilla/4.0(compatible;MSIE7.0;WindowsNT5.1)世界之窗（TheWorld）3.xUser-Agent:Mozilla/4.0(compatible;MSIE7.0;WindowsNT5.1;TheWorld)搜狗浏览器1.xUser-Agent:Mozilla/4.0(compatible;MSIE7.0;WindowsNT5.1;Trident/4.0;SE2.XMetaSr1.0;SE2.XMetaSr1.0;.NETCLR2.0.50727;SE2.XMetaSr1.0)360浏览器User-Agent:Mozilla/4.0(compatible;MSIE7.0;WindowsNT5.1;360SE)AvantUser-Agent:Mozilla/4.0(compatible;MSIE7.0;WindowsNT5.1;AvantBrowser)GreenBrowserUser-Agent:Mozilla/4.0(compatible;MSIE7.0;WindowsNT5.1) 模拟手机浏览器get模拟百度请求urllib的编码和解码浏览器的地址栏经常看到乱码的情况，这就是编码的问题12words=&#123;'wd':'徐晓峰'&#125;urllib.urlencode(words) #'wd=%E5%BE%90%E6%99%93%E5%B3%B0',注意这里是urllib不是urllib2 #coding:urf-8 import urllib import urllib2 url = 'http://www.baidu.com/s' word = {'wd':'徐晓峰'} newurl = url+'?'+urllib.urlencoding(word) reqeust = urllib2.Request(newurl) request.add_header("Connection":"keep-alive") #可以自由的添加头信息 print urllib2.urlopen(request).read()]]></content>
      <categories>
        <category>python分布式爬虫教程</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python爬虫001：python urllib读取网页]]></title>
    <url>%2F2018%2F12%2F14%2Fstudy-python%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B-2018-12-14-python%E7%88%AC%E8%99%AB001%EF%BC%9Aurllib%E8%AF%BB%E5%8F%96%E7%BD%91%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[正则表达式re加(),代表我们需要括号里面的东西不加(),表示全部内容我们都需要123456789import remystr = """&lt;span class \"search_yx_t j\"&gt; 共&lt;em&gt;5830&lt;/em&gt;个职位满足条件 &lt;span&gt;"""restr = "&lt;em&gt;(\\d+)&lt;/em&gt;"#d+表示和数字有关；():只要里面的对象regex = re.compile(restr, re, IGNORECASE)mylist = regex.findall(mystr) 读取网页的三种方式123456789101112131415161718#py2#enconding:utf-8import urllib2url = "http://www.baidu.com"#urlopen只能处理http，不可以处理httpsdef download1(url): return urllib2.urlopen(url).read()#读取全部网页def download2(url): return urllib2.urlopen(url).readlines()#读取每一行的网页数据，然后压入列表def download3(url): response = urllib2.orlopen(url)#网页抽象为文件 while True: line = response.readline()#读取一行 if not line: break python2 和python3的区别编码一般抓取英文数据用python2，抓取带中文的数据，就需要用python3 用python2打印中文是，需要在第一行encoding:utf-8 urllib2获取一个网页数据，urllib在python2和python3中有不同的表示 python2 12urllib2.urlopen(url).read()# urllib2只可以处理http，不可以处理https python3 1urllib2.request(url).read() python被网站屏蔽：referer有时候我们请求服务器的时候，服务器可以知道通过请求头中的referer参数，知道是谁在请求它服务器如果发现不是浏览器在请求他，二是python在请求他。直接502.可以直接拒绝我们的请求。 selenium我们需要这个东西来模拟浏览器。selenium可以操作我们的浏览器 抓取智联招聘基于selenium库和selenium.webdriver123456789101112131415161718192021222324import selenium #测试框架import selennium.webdriver #模拟浏览器import remystr = """&lt;span class \"search_yx_t j\"&gt; 共&lt;em&gt;5830&lt;/em&gt;个职位满足条件 &lt;span&gt;"""restr = "&lt;em&gt;(\\d+)&lt;/em&gt;"#d+表示和数字有关；():只要里面的对象regex = re.compile(restr, re. IGNORECASE)mylist = regex.findall(pagesource)def getnumberbyname(searchname): url = "https://sou.zhaopin.com/?jl=613&amp;kw=" + searchname + "&amp;kt=3" driver = selenium.webdriver.Firefox() #调用火狐浏览器 driver.get(url) #访问链接 pagesource = driver.page_source #抓取网页源代码 driver.close()#关闭 return mylist[0]# print getnumberbyname("python") 这是测试函数pythonlist = ["python", "python 运维", "python 测试", "python 数据", "python web"]for oystr in pythonlist: print pystr, getnumberbyname(pystr) 抓取51job123456789101112131415161718192021222324import selenium #测试框架import selennium.webdriver #模拟浏览器import remystr = """&lt;div class = "rt"&gt; 共67条职位 &lt;\div&gt;"""def getnumberbyname(searchname): #可能这里有一些混乱，手头没有python环境就没测试，大致就先这样吧 url="https://search.51job.com/list/240200,000000,0000,00,9,99,"+searchname +",2,1.htmllang=c&amp;stype=&amp;postchannel=0000&amp;workyear=99&amp;cotype=99&amp;degefrom=99&amp;jobterm=99&amp;companysize=99&amp;providesalary=99&amp;lonlat=0%2C0&amp;adius=-1&amp;ord_field=0&amp;confirmdate=9&amp;fromType=&amp;dibiaoid=0&amp;address=&amp;lin=&amp;specialarea=00&amp;from=&amp;welfare= driver = selenium.webdriver.Firefox() #调用火狐浏览器 driver.get(url) #访问链接 pagesource = driver.page_source #抓取网页源代码 restr = """(\\d+)""" #先抓大，再抓小；尤其是空白字 符出现的时候 regex = re.compile(restr, re.IGNORECASE) mylist = regex.findall(pagesource) newstr = mylist[0].strip() driver.close()#关闭 return mylist[0]pythonlist = ["python", "python 运维", "python 测试", "python 数据", "python web"]for oystr in pythonlist: print pystr, getnumberbyname(pystr)]]></content>
      <categories>
        <category>python分布式爬虫教程</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>urllib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内存读写]]></title>
    <url>%2F2018%2F12%2F13%2Fstudy-%E7%BC%96%E7%A8%8B%E8%BE%BE%E4%BA%BA-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%913%E6%9C%9F%E5%AD%A6%E4%B9%A0-2018-12-13-%E5%86%85%E5%AD%98%E8%AF%BB%E5%86%99%2F</url>
    <content type="text"><![CDATA[为什么需要内存？如果我们只需要这样的计算：1+2=? ,我们当然不需要内存。如果有十亿个数相加呢？寄存器明显不够用。所以就需要内存了 这里所说的内存 严格意义上并不是 内存条 ，但是现在可以这样理解，内存就在内存条中，内存条提供了一个很大的容器 从存储角度来看的话，寄存器和内存条没有什么区别，都是容器，都存储着一些列0、1这样的数字。 寄存器和内存的区别 如何定位内存？ 问题引出：cpu寄存器的数量是有限的，我们可以给每一个寄存器定义名字。但是内存很大，我们如何定义，方便我们找到呢？ 32位、64位计算机 32位计算机：误解：cpu寄存器的最大宽度是32位，所以是32位计算机。这种说法是不对的。32位指的是寻址编号。就是说计算机内部有32根线，每根线都可以代表0和1，每根线变化一下，就可以得到一个地址，就可以根据这个地址找到一块内存。32根线，也就是32位，就是寻找内存的范围。也就是寻址范围。这里的一块指的是8bit | 1byte 根据寻址范围，我们就相当于给内存起好编号了。注意编号都是以字节为单位. 计算最大内存123456732位计算机：2^32个内存编号，一个内存编号代表1byte2^32 byte2^32 / 1024 = 2^32 / 2^10 =2^22 KB2^22 / 1024 = 2^22 / 2^10 = 2^12 MB2^12 / 1024 = 2^12 / 2^10 = 2^2 GB = 4GB即使这里是4GB，不过一般我们看到的内存都是小于4GB的，这是有些系统固件会占用一部分内存。 这个问题仔细扣是不对的。因为计算机还可以扩展内存，正常情况下，计算如果按照32位的寻址规则的话，是4GB，但是计算机也可以打破这个寻址规则。其实，如何寻址，都是计算机自己内部定义的。 内存读写内存的格式内存的读写至少都是8位。涉及到内存，记住单位就是byte 内存地址和立即数mov 0x12345678,0xFFFF这条指令中，0x12345678到底是立即数，还是内存地址。不好区分，所以规定，我们用 []来表示内存mov [0x12345678],0xFFFF上面这条指令还是不好（不是不对）？ 因为0x12345678 表示1byte,而0xFFFF是2 byte.内存不像寄存器，超过的会直接抛弃，所以我们应该指定宽度，下面就是标准格式。 演示每个应用程序打开时，都会有一个4GB的空间DTDebug打开一个应用先认识一下我们的工具。 说明几点： 寄存器ESP一般就是用来处理堆栈的 右下角的堆栈区，我们初学者可以把他理解为内存 内存写MOV DWORD PTR DS:[8FFFFFFF],0x12345678执行报错。每个应用程序打开时，都会有一个4GB的空间，但是有部分地址我们时无法访问的。 怎么知道我们可以访问的地址呢？寄存器ESP中存放的地址肯定时可以访问的。我们更改一下指令MOV DWORD PTR DS:[0x0019FF74],0x12345678执行可以看到已经写入了。还有一个细节：[0x0019FF74]是1byte的地址，可是我们写入0x12345678,4byte,怎么回事？注意看堆栈区的内存标号：每四个才显示一个内存标号。其实我们的0x12345678是存在4个内存标号里的。 内存读MOV EAX,DWORD PTR DS:[0x13FFC4]`]]></content>
      <categories>
        <category>滴水逆向三期视频教程</category>
      </categories>
      <tags>
        <tag>滴水逆向</tag>
        <tag>汇编</tag>
        <tag>内存读写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进一步学习寄存器]]></title>
    <url>%2F2018%2F12%2F12%2Fstudy-%E7%BC%96%E7%A8%8B%E8%BE%BE%E4%BA%BA-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%913%E6%9C%9F%E5%AD%A6%E4%B9%A0-2018-12-12-%E8%BF%9B%E4%B8%80%E6%AD%A5%E5%AD%A6%E4%B9%A0%E5%AF%84%E5%AD%98%E5%99%A8%2F</url>
    <content type="text"><![CDATA[寄存器的种类现代计算机中，寄存器都是由CPU提供的，寄存器就在cpu里面。计算器按照存储宽度可以划分如下： 说明几点 1.不同的寄存器有不同的功能，这个我们暂时先不用管 寄存器是随着硬件不断发展变化的。现在已经有64位的寄存器了，将来可能还会有128位的寄存器 寄存器的结构可以看到，32位的寄存器中是嵌套着1个16位的寄存器，16位的寄存器嵌套着两个八位的寄存器。 大家可以找找规律，16位的寄存器名称就是把32位寄存器名称中的E给去掉了。而8位的寄存器，把16位寄存器划分为高位和低位，高位用H（high）表示，低位用L（lower）表示。 为什么要设计成这种嵌套关系？ 1.硬件不断发展的原因。将来要增加64位的寄存器，直接套在32位上就可以。既可以保持兼容，有可以自由扩展 存储不浪费。寄存器已经到32位了，我要存储8位的数据，那我们使用8位寄存器就可以。剩下的空间就可以给其他数据使用。 演示我们可以通过mov指令来演示一下这种嵌套关系12345#指令如下mov eax,0xAAAAAAAAmov ax,0xBBBBmov al,0xEEmov ah,0xHH 连续4次F8，执行4次。结果以此如下图：根据这个实验，大家就能形象出寄存器的结构 mov指令的用法立即数的概念 通常把在立即寻址方式指令中给出的数称为立即数。立即数可以是8位、16位或32位，该数值紧跟在操作码之后mov eax,0xAAAAAAAA 中 0xAAAAAAAA就是立即数 mov指令的用法 根据语法，我们可以写这样的指令mov eax,0xAAAAAAAA还可以写这样的指令mov eax,ebx 注意这里的mov和我们linux系统的mov是不一样的，linux系统的move是移动，而这里mov是拷贝 几个简单指令123456ADD 指令：加SUB 指令：减AND指令：逻辑与OR指令：逻辑或NOT指令：逻辑非XOR指令：逻辑异或 ADD指令演示ADD指令是源操作数与目标操作数进行逻辑与运算，运算结果再放到目标地址中我们写这样两条命令按F8后，发现eax中值为2，符合我们的预期再按F8后是没有执行吗？不是，如图我们可以再增加一体语句or eax,3执行后结果如图：]]></content>
      <categories>
        <category>滴水逆向三期视频教程</category>
      </categories>
      <tags>
        <tag>滴水逆向</tag>
        <tag>汇编</tag>
        <tag>通用寄存器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通用寄存器和初识汇编]]></title>
    <url>%2F2018%2F12%2F11%2Fstudy-%E7%BC%96%E7%A8%8B%E8%BE%BE%E4%BA%BA-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%913%E6%9C%9F%E5%AD%A6%E4%B9%A0-2018-12-11-%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C%E5%88%9D%E8%AF%86%E6%B1%87%E7%BC%96%2F</url>
    <content type="text"><![CDATA[寄存器初识不论如何存储，在计算机中，我们存储的都是0和1。再熟悉一点计算机的组成，我们就会知道，cpu和硬盘中都可以存储，我们可以理解为cpu和硬盘中都有一些容器。cpu中比较通用的就是 32位通用寄存器 32位通用寄存器的功能如下 这个需要我们牢牢的记住，但是我们也应该知道两点 说是寄存器，其实就是一个容器 这里所说的寄存器的主要功能，其实是操作系统给我们的建议功能。就像我们买一个牙刷缸，建议的功能肯定是刷牙。但是你非要用来喝茶，也是没有关系的。 学习汇编准备开发工具我们谁用滴水推荐的DTdebug工具。https://pan.baidu.com/s/1ck1ii_lsV9ZsAs-4FdjLmA这个是绿色软件，下载解压后直接打开就可以。注意两点 1.以管理身份运行 需要配置一下options这两个存储目录分别对应，我们解压后udd和plugin目录。 DTdebug界面file -&gt; open ,打开一个.exe文件，就可以看到各种汇编代码。 看右边，registers界面，就可以看到我们刚才说的32位通用寄存器中的几个容器。 EIP寄存器我们可以看到，左边黑色就表示cpu当前执行的位置，右边的EIP中位置和左边的相同，说明EIP中存储的就是当前程序的执行位置。 发送指令我们在左边的随意一个命令中双击，就会跳出操作指令的窗口。输入指令后，点击Assemble，就会执行相应的指令。 mov指令汇编指令都是由 操作码+操作数 组成。mov， 0x12就是把十六进制数0x12 移动到寄存器``中。 汇编学习，往后继续]]></content>
      <categories>
        <category>滴水逆向三期视频教程</category>
      </categories>
      <tags>
        <tag>滴水逆向</tag>
        <tag>汇编</tag>
        <tag>通用寄存器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据的宽度和逻辑运算]]></title>
    <url>%2F2018%2F12%2F10%2Fstudy-%E7%BC%96%E7%A8%8B%E8%BE%BE%E4%BA%BA-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%913%E6%9C%9F%E5%AD%A6%E4%B9%A0-2018-12-10-%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AE%BD%E5%BA%A6%E7%9A%84%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[数据的宽度我们需要知道，无论是我们平时看到的视频(avi,mp4)，还是图片png，jpg，在计算机中存储的时候，都是存储为0，1这个符号。 在之前我们的学习中，我们经常会听到原码、反码、补码等消息，这都是后人总结出来的一些概念，计算机本质是没有这些的。 就比如说有符号整型和无符号整型，计算机只知道自己存储的是0和1，是使用它的人自己规定这个是有符号还是无符号的。 我们先把存储比作是容器，如果容器只能装4bit，比如我们存了一个数ffff,我们再给这个数加1，会变成什么？ 答案是0.计算机和真实的世界是不一样的，存不下的时候，直接抛弃。 在有符号数据中，为什么用1表示负数？ 这都是什么这个数字的人决定的，计算机并不知道自己存储的是负数。 几个重要的计量单位(数据宽度)1231 byte = 8 bit1 word = 16 bit1 dword = 32 bit 二进制的逻辑运算逻辑运算就是CPU计算的本质，汇编语言并不是cpu计算的本质。（这块就设计到了电路的知识） 1234或 or |与 and &amp;异或 xor ^非 not ！ or，and，xor，not就是汇编语言的表示 CPU是如何计算2+3=？先用一个容器X：存放二进制的2：0010在用一个容器Y：存放二进制的3：0011 然后再用一个容器R：存放0010和0011异或的结果。CPU需要判断容器R中是否是最终的结果，是否还需要继续运算。怎么判断呢？ 让0010和0011进行与运算，与运算的结果向左移一位，&lt;&lt;1 ,如果结果是0，那说明上面容器R中的就是真正的结果。 如果不是0，就是容器R中的值放到X中，把刚才判断得到的结果放到Y中，重复上面的操作。 逻辑运算的两个应用 判断某个值第N位的值是多少？ 比如我们要判断第四位的值是多少，我们就构造一个第四位是1的数，然后与这个数进行与运算。如果结果&gt;0,表明第四位是1，不然第四位是0.因为我们构造的数除了第四位是1，其他都是0.与运算的话，除了第四位，其他的肯定都是0.]]></content>
      <categories>
        <category>滴水逆向三期视频教程</category>
      </categories>
      <tags>
        <tag>滴水逆向</tag>
        <tag>汇编</tag>
        <tag>逻辑运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编、进制学习]]></title>
    <url>%2F2018%2F12%2F09%2Fstudy-%E7%BC%96%E7%A8%8B%E8%BE%BE%E4%BA%BA-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%913%E6%9C%9F%E5%AD%A6%E4%B9%A0-2018-12-09-%E6%B1%87%E7%BC%96%E3%80%81%E8%BF%9B%E5%88%B6%2F</url>
    <content type="text"><![CDATA[进制的概念 二进制：由两个符号组成，分别用0和1表示，逢二进一。 四进制：由四个符号组成，分别用0、1、2、3表示，逢四进一。 八进制：由8个符号组成，分别用0、1、2、3、4、5、6、7表示，逢八进一。 十六进制：由16个符号组成，分别用0、1、2。。。。8、9、A、B、C、D、E、F表示，逢十六进一 由此我们可以得出。n进制：由n个符号组成，分别用n个符号表示，逢n进一。 忽略的地方表示8进制，我们就用0-8，8个数字来表示，那我们能不能用八个图片来表示？八个表情呢？ 答案是肯定的，我们可以用任何的符号来表示，并不局限于8个数字 用别的符号表示，有什么作用呢？ 这就涉及到密码学的问题了，比如两个人商量好，用微笑😊表情表示1，用伤心💔的表情表示0。那我收到两个微笑，两个伤心。😊😊💔💔，我就知道你发的是1100.但是别人就不只知道。如果我们在自己的项目中运用了自定义的元素，别人还以为我们运用了多么高深的加密算法。 进制的转化在以往的概念中，我们一般都是通过10进制作为中间桥梁来进行进制转化。这是没有必要的。往后，我们只需要熟练掌握二进制和16进制之间的转化就可以了。 2进制和16进制-进制转化表 二进制 十六进制 十进制 0000 00 0 0001 01 1 0010 02 2 0011 03 3 0100 04 4 0101 05 5 0110 06 6 0111 07 7 1000 08 8 1001 09 9 1010 0A 10 1011 0B 11 1100 0C 12 1101 0D 13 1110 0E 14 1111 0F 15 进制的运算当我们10进制运算16+9的时候，我们可以脱口而出25.我们是怎么做到的？仔细想了想，使我们从小就记住了两张表，一张加法运算表，一张乘法运算表。对于其他进制的运算，以往我们都是转化为10进制，来回转，最后算出结果。但这都偏离了进制的本质。 要想进行进制的运算，我们首先也应该构建两张表。然后进制的运算，我们就是单纯的查表。你说查表麻烦？那你可以选择把它记住，10进制的乘法表，大家不就是已经记住了吗？ 我们就以八进制为例 加法表的构建想要构建加法表，我们首先应该按照8进制从0写道100。0+1 ，我们就从0开始往后数1，就是11+3，我们就从1开始往后数3，就是46+4，我们就从4开始往后数4，就是7，10，11，12 ，就是12了 依次类推我们就会构建出八进制的加法表 乘法表的构建乘法表，当然是从加法表构建出来的。 2✖3，就是3+3，或者2+2+2=4+2，我们在加法表中一查就会知道结果 一次类推，我们也可以得出乘法表。 运算 加法表，乘法表都是单位数，那多位数的加减乘除该如何运算？ 多位数的加法我们可以参照加法表多位数的乘法我们可以参照乘法表多位数的减法，我们可以参照减法表多位数的除法，我们可以参照乘法表 但是切记，进制的运算，我们完全可以在其内部完成，不用在十进制之间来回转换。 自定义三进制的表示涉及到自定义符号的时候，我们一定要注意，0，1，2，3这些都不是数字，只是一个符号 如果我们用2，0，1分别表示三进制的三个元素，三进制表则可以表示如下。不要觉得很简单哦，自己能写出来才知道自己会不会 说明 2 0 1 02 00 01 能得出02就厉害了 12 10 11 注意进位的时候 022 020 021 我们要彻底忘掉十进制的概念，彻底忘掉0，1，2，3的概念。切记，0，1，2，3只是符号，而不是数字]]></content>
      <categories>
        <category>滴水逆向三期视频教程</category>
      </categories>
      <tags>
        <tag>滴水逆向</tag>
        <tag>汇编</tag>
        <tag>进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[真的会有那么两个人]]></title>
    <url>%2F2018%2F12%2F08%2Fpersonal-2018-12-08-%E7%9C%9F%E7%9A%84%E4%BC%9A%E6%9C%89%E4%B8%A4%E4%B8%AA%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[后来我发现，原来真的会有两个人，互相喜欢，互相惦记，互相忘不掉，确实不能在一起。忘不掉，放不下，却又回不去。]]></content>
      <categories>
        <category>个人</category>
      </categories>
      <tags>
        <tag>回忆</tag>
        <tag>心灵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[连回忆都留不住]]></title>
    <url>%2F2018%2F12%2F06%2Fpersonal-2018-12-06-%E8%BF%9E%E5%9B%9E%E5%BF%86%E9%83%BD%E7%95%99%E4%B8%8D%E4%BD%8F%2F</url>
    <content type="text"><![CDATA[百年孤独里说，无论走到哪里，都应该记住，过去都是假的，回忆是一条没有尽头的路。一切以往的春天都不复从来。就连那最坚韧而又狂乱的爱情归根结底也不过是一种转瞬即逝的现实。 感觉每天有好多东西要写，可以搭建博客之后，反而不知道自己要写什么了。 马上就要搬到上海了，工作上的调用。想到搬家，我很痛苦，那几天走在路上都是彷徨的。不过这几天我想通了，反正孤身一人，反正一无所有，反正也没有去过上海。那就走吧。 女朋友还在读研，前段时间来京几日。买了不少生活用品，女孩了总是喜欢买，不过这样才更有生活的气息。在搬走之前，把属于她的东西都寄给她。收拾屋子的时候，好多觉得用不到的东西都会扔掉，每件东西都有的她的气息，每件东西后面都有她的影子。不能给她一个家，连回忆都保留不住。深深伤感。]]></content>
      <categories>
        <category>个人</category>
      </categories>
      <tags>
        <tag>回忆</tag>
        <tag>心灵</tag>
      </tags>
  </entry>
</search>
