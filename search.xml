<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Golang 语言机制和其设计原则</title>
      <link href="/2019/04/24/study-%E7%BC%96%E7%A8%8B%E8%BE%BE%E4%BA%BA-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%913%E6%9C%9F%E5%AD%A6%E4%B9%A0-2019-04-24-Golang-%E8%AF%AD%E8%A8%80%E6%9C%BA%E5%88%B6%E5%92%8C%E5%85%B6%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
      <url>/2019/04/24/study-%E7%BC%96%E7%A8%8B%E8%BE%BE%E4%BA%BA-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%913%E6%9C%9F%E5%AD%A6%E4%B9%A0-2019-04-24-Golang-%E8%AF%AD%E8%A8%80%E6%9C%BA%E5%88%B6%E5%92%8C%E5%85%B6%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>golang微服务学习记录</title>
      <link href="/2019/04/19/golang-2019-04-19-golang%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/04/19/golang-2019-04-19-golang%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="gomicroservices"><a href="#gomicroservices" class="headerlink" title="gomicroservices"></a>gomicroservices</h1><p>微服务入门第一篇文章<br><a href="http://blog.cuicc.com/blog/2015/07/22/microservices/" target="_blank" rel="noopener">http://blog.cuicc.com/blog/2015/07/22/microservices/</a></p><p>本系列参考文章<br>中文地址</p><p><a href="https://wuyin.io/archives/page/2/" target="_blank" rel="noopener">https://wuyin.io/archives/page/2/</a></p><p><a href="https://studygolang.com/articles/12060" target="_blank" rel="noopener">https://studygolang.com/articles/12060</a></p><p>英文地址（优先推荐）</p><p><a href="https://ewanvalentine.io/microservices-in-golang-part-1/" target="_blank" rel="noopener">https://ewanvalentine.io/microservices-in-golang-part-1/</a></p><h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><ol><li>protoc.exe .\consignment.proto –go_out=./</li></ol><p>这样是错误的，没有写编译插件</p><ol start="2"><li>windows10上makefile的使用<br>下载软件 <a href="http://sourceforge.net/projects/mingw/files/latest/download?source=files" target="_blank" rel="noopener">http://sourceforge.net/projects/mingw/files/latest/download?source=files</a></li></ol><p>安装，把安装目录的<code>bin</code> 目录添加到环境变量。</p><p>然后把默认的编译器都安装上即可（其实只要选择编译器是勾选C Compiler 与C++ Compiler）</p><p>最后在MinGW的安装目录，打开bin文件夹，将mingw32-make.exe重命名为make.exe</p><ol start="3"><li>停止当前所有运行中的容器、删除镜像</li></ol><p><code>docker stop $(docker ps -aq)</code><br><code>docker rmi $(docker images -q)</code><br><code>docker container rm *</code> 删除一个处于终止状态的容器<br><code>docker container prune</code> 清除所有处于终止状态的容器 </p><ol start="4"><li>Git 多平台换行符问题(LF or CRLF)</li></ol><p>Git 多平台换行符问题(LF or CRLF)</p><p><a href="http://kuanghy.github.io/2017/03/19/git-lf-or-crlf" target="_blank" rel="noopener">http://kuanghy.github.io/2017/03/19/git-lf-or-crlf</a></p><h1 id="学习记录"><a href="#学习记录" class="headerlink" title="学习记录"></a>学习记录</h1><h1 id="dev1"><a href="#dev1" class="headerlink" title="dev1"></a>dev1</h1><p>这一节基本上还是grpc的内容</p><ol><li>微服务的介绍</li><li>grpc的使用介绍</li><li>protobuf的使用</li></ol><h2 id="consignment微服务"><a href="#consignment微服务" class="headerlink" title="consignment微服务"></a>consignment微服务</h2><ol><li>创建protobuf服务描述文件consignment.proto</li><li>用protoc把consignment.proto编译成go版本</li><li>创建grpc服务端</li></ol><p>关键代码<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">listener, err := net.Listen(<span class="string">"tcp"</span>, PORT)</span><br><span class="line">server := grpc.NewServer()</span><br><span class="line">pb.RegisterShippingServiceServer(server, &amp;service&#123;repo&#125;)</span><br><span class="line">server.Serve(listener)</span><br></pre></td></tr></table></figure></p><ol start="4"><li>创建grpc客户端</li></ol><p>关键代码<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">conn, err := grpc.Dial(ADDRESS, grpc.WithInsecure())</span><br><span class="line">client := pb.NewShippingServiceClient(conn)</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">resp, err := client.CreateConsignment(context.Background(), consignment)</span><br></pre></td></tr></table></figure></p><h1 id="dev2"><a href="#dev2" class="headerlink" title="dev2"></a>dev2</h1><h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><ol><li>Docker-从入门到实践<br><a href="https://yeasy.gitbooks.io/docker_practice/content/" target="_blank" rel="noopener">https://yeasy.gitbooks.io/docker_practice/content/</a></li></ol><p>docker只是容器技术的一种实现，比较流行的一种。不要把容器技术和docker混淆了。</p><h2 id="把consignment微服务容器化"><a href="#把consignment微服务容器化" class="headerlink" title="把consignment微服务容器化"></a>把consignment微服务容器化</h2><p>创建Dockerfile文件<br><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 若运行环境是 Linux 则需把 alpine 换成 debian</span></span><br><span class="line"><span class="comment"># 使用最新版 alpine 作为基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> alpine:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在容器的根目录下创建 app 目录</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /app</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 将工作目录切换到 /app 下</span></span></span><br><span class="line"><span class="bash">WORKDIR /app</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 将微服务的服务端运行文件拷贝到 /app 下</span></span></span><br><span class="line"><span class="bash">ADD consignment-service /app/consignment-service</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 运行服务端</span></span></span><br><span class="line"><span class="bash">CMD [<span class="string">"./consignment-service"</span>]</span></span><br></pre></td></tr></table></figure></p><p>为了使用方便，我们创建Makefile文件<br><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">build:</span><br><span class="line"><span class="comment"># 编译proto文件（当前应该是grpc，micro是后面加上go-micro之后的）</span></span><br><span class="line">protoc -I. --go_out=plugins=micro:. proto/consignment/consignment.proto</span><br><span class="line"><span class="comment"># 编译服务代码</span></span><br><span class="line">GOOS=linux GOARCH=amd64 go build</span><br><span class="line"><span class="comment"># 创建docker镜像</span></span><br><span class="line">docker build -t shippy-service-consignment .</span><br><span class="line"><span class="keyword">run</span><span class="bash">:</span></span><br><span class="line"><span class="bash"><span class="comment"># 启动docker容器</span></span></span><br><span class="line"><span class="bash">docker run -p 8010:8010 -e MICRO_SERVER_ADDRESS=:8010 shippy-service-consignment</span></span><br></pre></td></tr></table></figure></p><h2 id="go-micro"><a href="#go-micro" class="headerlink" title="go-micro"></a>go-micro</h2><blockquote><p>为什么需要go-micro，我们用grpc不就挺好吗？</p><ol><li>管理麻烦:我们在consignment/cli.go文件中，就是调用服务时，需要手动指定服务的ip和端口。当我们部署很多服务后，一个服务的IP或者端口发生变化，其他服务就都不能调用了。</li><li>服务发现：为了解决各个微服务间的调用问题，就需要服务发现。服务发现就相当于是一个注册中心，各个微服务启动时都到这里来记录自己的IP和端口，服务注销时，也把记录的IP和端口注销掉。go-micro刚好实现了这一点（不止这一点），我们就用go-micro来改造我们的服务。</li></ol></blockquote><h2 id="用go-micro改造consignment服务端"><a href="#用go-micro改造consignment服务端" class="headerlink" title="用go-micro改造consignment服务端"></a>用go-micro改造consignment服务端</h2><ol><li>首先consignment.proto 用protoc编译时，plugins插件改成了micro</li></ol><p>用插件 micro 插件编译后，之前.proto 定义的方法中的返回值现在移到了请求参数中。</p><ol start="2"><li>服务端代码也需要改</li></ol><p>主要代码<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server := micro.NewService(</span><br><span class="line">micro.Name(<span class="string">"shippy.service.consignmen"</span>),</span><br><span class="line">micro.Version(<span class="string">"latest"</span>),</span><br><span class="line">    )</span><br><span class="line">pb.RegisterShippingServiceHandler(server.Server(), &amp;service&#123;repo&#125;)</span><br><span class="line">server.Run()</span><br></pre></td></tr></table></figure></p><ol start="3"><li>监听地址没有写死</li></ol><p>查看代码发现，我们再go-micro服务启动的过程中，自始至终都没有出现服务监听的ip和端口。why ？</p><blockquote><p>go-mirco 会自动使用系统或命令行中变量 MICRO_SERVER_ADDRESS 的地址</p></blockquote><p>所以我们再Makefile中docker启动命令中，加了环境变量<code>-e MICRO_SERVER_ADDRESS=:8010</code></p><p>go-micro默认是使用mdns作为服务发现的，我们可以使用环境变量 <code>MICRO_REGISTRY=mdns</code> 来设置。在生产环境中，可以使用etcd来代替。</p><h2 id="用go-micro改造consignment客户端"><a href="#用go-micro改造consignment客户端" class="headerlink" title="用go-micro改造consignment客户端"></a>用go-micro改造consignment客户端</h2><p>主要代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">service := micro.NewService(micro.Name(<span class="string">"shippy.consignment.cli"</span>))</span><br><span class="line">service.Init()</span><br><span class="line"><span class="comment">// 这个名字 shippy.service.consignment 一定要写对啊</span></span><br><span class="line">client := pb.NewShippingServiceClient(<span class="string">"shippy.service.consignment"</span>, service.Client())</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">res, err := client.CreateConsignment(context.Background(), consignment)</span><br></pre></td></tr></table></figure><h2 id="用go-micro创建VesselService微服务"><a href="#用go-micro创建VesselService微服务" class="headerlink" title="用go-micro创建VesselService微服务"></a>用go-micro创建VesselService微服务</h2><h1 id="dev3"><a href="#dev3" class="headerlink" title="dev3"></a>dev3</h1><h2 id="yaml文件语法"><a href="#yaml文件语法" class="headerlink" title="yaml文件语法"></a>yaml文件语法</h2><p><a href="http://www.ruanyifeng.com/blog/2016/07/yaml.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/07/yaml.html</a></p><h2 id="docker-compose的使用"><a href="#docker-compose的使用" class="headerlink" title="docker-compose的使用"></a>docker-compose的使用</h2><p>之前，我们启动每一个微服务都需要有一个Makefile文件，如果微服务很多的话，管理起来很不方便。我们就需要一个统一管理:docker-compoose</p><p>为了使用docker-compose，我们几个服务的同级目录下创建了 <code>docker-compose.yaml</code> 文件。</p><ol><li>常用命令</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker-compose build</span><br><span class="line">docker-compose up <span class="comment">//加 -d  表示在后台运行</span></span><br><span class="line">docker-compose run *</span><br><span class="line">docker-compose down <span class="comment">//和run命令相对应</span></span><br><span class="line">docker-compose images <span class="comment">//列出compose文件包含的镜像</span></span><br><span class="line">docker-compose logs <span class="comment">//列出容器日志</span></span><br></pre></td></tr></table></figure><ol start="2"><li>基本参数</li></ol><p>-p :表示项目名，不指定的话，默认用所在目录作用项目名。</p><h2 id="mgo"><a href="#mgo" class="headerlink" title="mgo"></a>mgo</h2><p>最好的驱动 <code>go get gopkg.in/mgo.v2</code></p><p>简单的使用教程： <a href="https://www.itfanr.cc/2017/06/28/golang-connect-to-mongodb/" target="_blank" rel="noopener">https://www.itfanr.cc/2017/06/28/golang-connect-to-mongodb/</a></p><p>条件查询的示例：<a href="https://www.jianshu.com/p/b63e5cfa4ce5" target="_blank" rel="noopener">https://www.jianshu.com/p/b63e5cfa4ce5</a></p><h2 id="consignment服务重构"><a href="#consignment服务重构" class="headerlink" title="consignment服务重构"></a>consignment服务重构</h2><p>之前一个服务的代码，全部都写在main.go中。仓库repository，服务service逻辑，go-micro服务都在一起显得有点混乱。</p><p>现在我们加了mongoDb，想要数据持久化。</p><p>所以我们把代码拆分成几个文件：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">datastore.<span class="keyword">go</span> <span class="comment">// 创建与 MongoDB 的主回话</span></span><br><span class="line">repository.<span class="keyword">go</span> <span class="comment">// 实现与数据库进行的操作</span></span><br><span class="line">handler.<span class="keyword">go</span> <span class="comment">// 实现微服务的服务端，处理业务骆</span></span><br><span class="line">main.<span class="keyword">go</span> <span class="comment">// 注册 并启动服务</span></span><br></pre></td></tr></table></figure></p><h2 id="vessel-service重构"><a href="#vessel-service重构" class="headerlink" title="vessel-service重构"></a>vessel-service重构</h2><p>重构逻辑与consignment服务相同</p><h2 id="在docker-compose-yaml中引入MongoDB"><a href="#在docker-compose-yaml中引入MongoDB" class="headerlink" title="在docker-compose.yaml中引入MongoDB"></a>在docker-compose.yaml中引入MongoDB</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">services:</span><br><span class="line">  ...</span><br><span class="line">  datastore:</span><br><span class="line">    image: mongo</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="number">27017</span>:<span class="number">27017</span></span><br></pre></td></tr></table></figure><p>Note:mongoDB 的docker服务是<code>datastore</code>。这是用到了docker内置DNS机制。</p><p>进入到mongoDB终端操作，<code>docker exec -it d5ad8985ecdf bash</code>.通过git自带的终端报错，通过 power shell 正常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mongo</span><br><span class="line">show dbs</span><br><span class="line">use vessels</span><br><span class="line">show collections</span><br><span class="line">db.vessels.find()</span><br></pre></td></tr></table></figure><blockquote><p>我们的consignment服务，vessel服务中，需要使用MongoDB是，就可以直接这样设置<code>DB_HOST: &quot;datastore:27017&quot;</code></p></blockquote><h2 id="user-service"><a href="#user-service" class="headerlink" title="user-service"></a>user-service</h2><h3 id="首先需要引入docker-service：postgresql"><a href="#首先需要引入docker-service：postgresql" class="headerlink" title="首先需要引入docker service：postgresql"></a>首先需要引入docker service：postgresql</h3><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">database:</span><br><span class="line">  image: postgres</span><br><span class="line">  ports:</span><br><span class="line">    - <span class="number">5432</span>:<span class="number">5432</span></span><br></pre></td></tr></table></figure><p>Note1:这个docker 服务名：database,就表示我们在其他地方使用此postgresql，就可以用<code>database:5432</code>表示了</p><p>Note2：在我们后来启动user-service的时候，发现docker-compose.yaml中postgresql这样配置是不可以的。修改如下：<br><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">database:</span><br><span class="line">  image: postgres:<span class="number">9.5</span>.<span class="number">4</span></span><br><span class="line">  ports:</span><br><span class="line">    - <span class="number">5432</span></span><br></pre></td></tr></table></figure></p><h3 id="UserService服务"><a href="#UserService服务" class="headerlink" title="UserService服务"></a>UserService服务</h3><ol><li>定义proto文件</li><li>实现业务处理逻辑 handler.go</li><li>实现数据库的交互 repository.go</li></ol><p>这里我们使用了gorm：<a href="https://jasperxu.github.io/gorm-zh" target="_blank" rel="noopener">https://jasperxu.github.io/gorm-zh</a></p><ol start="4"><li>main.go</li></ol><blockquote><p>启动服务测试一下</p></blockquote><h3 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE"></a>NOTE</h3><ol><li>docker-compose启动user-service时，需要先exec到postgesql的docker容器中，进行数据库的初始化。</li></ol><p>中文教程中所说的，必须要先手动启动postgresql，没必要。写好依赖即可。</p><ol start="2"><li>启动user-cli<br><code>docker-compose.exe run user-cli --name=&quot;xuxiaofeng&quot; --email=&quot;13641537547@163.com&quot; --password=&quot;123456789&quot; --company=&quot;china&quot;</code></li></ol><p>报错：<br>Error response from daemon: OCI runtime create failed: container_linux.go:344: starting container process caused “exec: \”–name=xuxiaofeng\”: executable file not found in $PATH”: unknown</p><blockquote><p>原来是在run后面忘记加参数command了</p></blockquote><p>但是加上<code>command</code>也是不可以，解析不到我们传入的命令，导致数据都是空。</p><blockquote><p>最终解决：<br>把<code>user-cli\cli.go</code>文件中的cmd.Init()给去掉<br>运行命令中去掉command：<code>docker-compose.exe run user-cli --name=&quot;xuxiaofeng&quot; --email=&quot;13641537547@163.com&quot; --password=&quot;123456789&quot; --company=&quot;china&quot;</code> ,就成功了。也不知道为什么教程中那样可以成功。</p></blockquote><p>后来在执行<code>consignment-cli</code>的时候，也是报了同样的错误。</p><p>最后发现其实是<code>Dockerfile</code> 没有配置对。关键是 <code>ENTRYPOINT</code>命令。<br><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"./consignment-cli"</span>]</span></span><br><span class="line"><span class="bash">CMD [ <span class="string">"./consignment-cli"</span> ]</span></span><br></pre></td></tr></table></figure></p><p><a href="https://yeasy.gitbooks.io/docker_practice/image/dockerfile/entrypoint.html" target="_blank" rel="noopener">https://yeasy.gitbooks.io/docker_practice/image/dockerfile/entrypoint.html</a></p><h1 id="dev4"><a href="#dev4" class="headerlink" title="dev4"></a>dev4</h1><p>之前，在user-service中，我们用户密码都是明文的。这节中主要就是面加密，并且引入了JWT</p><p>首先是密码hash处理<code>golang.org/x/crypto/bcrypt</code></p><p>主要是下面两个函数<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hash处理用户密码</span></span><br><span class="line">hashedpwd, err := bcrypt.GenerateFromPassword([]<span class="keyword">byte</span>(req.Password), bcrypt.DefaultCost)</span><br><span class="line"><span class="comment">// 进行密码验证</span></span><br><span class="line"><span class="keyword">if</span> err := bcrypt.CompareHashAndPassword([]<span class="keyword">byte</span>(u.Password), []<span class="keyword">byte</span>(req.Password)); err != <span class="literal">nil</span> &#123;</span><br></pre></td></tr></table></figure></p><p>至于JWT，JWT是有自己的协议的。这里有一些介绍的文章。</p><p><a href="https://auth0.com/blog/json-web-token-signing-algorithms-overview/" target="_blank" rel="noopener">https://auth0.com/blog/json-web-token-signing-algorithms-overview/</a></p><blockquote><p>当然我们并不能说JWT就比传统的Token机制要好。这篇文章就详细描述了两者的优缺点<a href="http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/" target="_blank" rel="noopener">http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/</a></p></blockquote><p>JWT我们使用这个第三方包：github.com/dgrijalva/jwt-go</p><p>主要就是下面的代码<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 JWT 字符串解密为 CustomClaims 对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *TokenService)</span> <span class="title">Decode</span><span class="params">(tokenStr <span class="keyword">string</span>)</span> <span class="params">(*CustomClaims, error)</span></span> &#123;</span><br><span class="line">  t, err := jwt.ParseWithClaims(tokenStr, &amp;CustomClaims&#123;&#125;, <span class="function"><span class="keyword">func</span><span class="params">(token *jwt.Token)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> privateKey, <span class="literal">nil</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 解密转换类型并返回</span></span><br><span class="line">  <span class="keyword">if</span> claims, ok := t.Claims.(*CustomClaims); ok &amp;&amp; t.Valid &#123;</span><br><span class="line">    <span class="keyword">return</span> claims, <span class="literal">nil</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 User 用户信息加密为 JWT 字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *TokenService)</span> <span class="title">Encode</span><span class="params">(user *pb.User)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 三天后过期</span></span><br><span class="line">  expireTime := time.Now().Add(time.Hour * <span class="number">24</span> * <span class="number">3</span>).Unix()</span><br><span class="line">  claims := CustomClaims&#123;</span><br><span class="line">    user,</span><br><span class="line">    jwt.StandardClaims&#123;</span><br><span class="line">      Issuer:    <span class="string">"go.micro.srv.user"</span>, <span class="comment">// 签发者</span></span><br><span class="line">      ExpiresAt: expireTime,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">  jwtToken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)</span><br><span class="line">  <span class="keyword">return</span> jwtToken.SignedString(privateKey)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>jwt的hash算法大致可以分为两类。一类是对称加密，一类是非对称加密。前者使用同一个秘钥进行加解密，后者通常用公钥加密，私钥解密。</p></blockquote><p>有了token之后，在不同的微服务之间就可以用户认证了。好多方法都需要认证的时候，我们就需要类似中间件这样的东西了。</p><p>go-micro已经给我们提供了类似的功能</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">srv := micro.NewService(</span><br><span class="line">  <span class="comment">// 必须和 consignment.proto 中的 package 一致</span></span><br><span class="line">  micro.Name(<span class="string">"go.micro.srv.consignment"</span>),</span><br><span class="line">  micro.Version(<span class="string">"latest"</span>),</span><br><span class="line">  micro.WrapHandler(AuthWrapper), <span class="comment">// 这个就是中间件了</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="dev5"><a href="#dev5" class="headerlink" title="dev5"></a>dev5</h1><p>之前我们的服务之间耦合度还是比较高的，经常在一个服务中调用其他服务。一是不方便测试，而是服务增多的话，关系会比较混乱。</p><p>因此我们需要事件模型，也就是发布订阅模型。服务A完成一件事后，通知消息系统 <code>事件x</code> 已完成。它并不关心有多少个服务正在监听这个事件。其他的服务，谁需要这个事件，谁就到信息系统订阅这个事件。</p><p>这里面有三个重要点，一是消息系统（有好多开源的系统），二是发布事件，三是订阅事件。</p><p>这里我们使用的是 <code>go-micro NATS 插件</code>，go-micro已经把NATS插件集成到自身的系统中了。</p><blockquote><p>前提是我们需要用docker 运行一个NATS服务。</p></blockquote><h2 id="使用go实现的NATS"><a href="#使用go实现的NATS" class="headerlink" title="使用go实现的NATS"></a>使用go实现的NATS</h2><p>我们也可以不使用go-micro提供的NATS插件，直接就是用golang实现的NATS插件。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nc, _ := nats.Connect(nats.DefaultURL)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Simple Publisher</span></span><br><span class="line">nc.Publish(<span class="string">"user.created"</span>, userJsonString)</span><br></pre></td></tr></table></figure><p>事件订阅<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Simple Async Subscriber</span></span><br><span class="line">nc.Subscribe(<span class="string">"user.created"</span>, <span class="function"><span class="keyword">func</span><span class="params">(m *nats.Msg)</span></span> &#123;</span><br><span class="line">    user := convertUserString(m.Data)</span><br><span class="line">    <span class="keyword">go</span> sendEmail(user)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="go-micro内置Pubsub层"><a href="#go-micro内置Pubsub层" class="headerlink" title="go-micro内置Pubsub层"></a>go-micro内置Pubsub层</h2><p>其实我们无需任何第三方中间件，直接使用go-micro内置即可。</p><p><code>publisher := micro.NewPublisher(topic, srv.Client())</code></p><h1 id="dev6-API-网关"><a href="#dev6-API-网关" class="headerlink" title="dev6 API 网关"></a>dev6 API 网关</h1><p>这几之前，我们想请求微服务内部的接口，是没有办法通过HTTP请求的。</p><p>这节我们给它加一个HTTP API网关，之后我们就可以直接http请求了。</p><p>docker run -p 8080:8080 -e MICRO_REGISTRY=mdns microhq/micro api –handler=rpc –address=:8080 –namespace=shippy</p><p>curl -XPOST -H ‘Content-Type: application/json’ -d ‘{<br>            “service”: “shippy.auth”,<br>            “method”: “Auth.Create”,<br>            “request”: {<br>                “user”: {<br>                    “email”: “<a href="mailto:ewan.valentine89@gmail.com" target="_blank" rel="noopener">ewan.valentine89@gmail.com</a>“,<br>                    “password”: “testing123”,<br>                    “name”: “Ewan Valentine”,<br>                    “company”: “BBC”<br>                }<br>            }<br>    }’<br>    <a href="http://localhost:8080/rpc" target="_blank" rel="noopener">http://localhost:8080/rpc</a></p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> go-micro </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SSL/TLS 双向认证 -- SSLTLS工作原理</title>
      <link href="/2019/04/08/computer-network-2019-01-24-SSL%E3%80%81TLS-%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81-SSLTLS%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
      <url>/2019/04/08/computer-network-2019-01-24-SSL%E3%80%81TLS-%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81-SSLTLS%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>参考：<a href="https://blog.csdn.net/ustccw/article/details/76691248" target="_blank" rel="noopener">https://blog.csdn.net/ustccw/article/details/76691248</a><br><a href="https://www.barretlee.com/blog/2016/04/24/detail-about-ca-and-certs/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">https://www.barretlee.com/blog/2016/04/24/detail-about-ca-and-certs/?utm_source=tuicool&amp;utm_medium=referral</a></p><p>#CA &amp; SSL Server &amp; SSL Client 介绍</p><h2 id="SSL-TLS-工作流"><a href="#SSL-TLS-工作流" class="headerlink" title="SSL/TLS 工作流"></a>SSL/TLS 工作流</h2><p><img src="https://upload-images.jianshu.io/upload_images/422094-c88c548754577bcf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>CA: 证书授权中心( certificate authority)<br>似于国家出入境管理处一样，给别人颁发护照；也类似于国家工商管理局一样，给公司企业颁发营业执照。<br>CA的两大特性：<br>1) CA本身是受信任的 // 国际认可的<br>2) 给他受信任的申请对象颁发证书 </p><blockquote><p>也可以撤销证书？怎么撤销？</p></blockquote><blockquote><p>电脑中的证书<br>360浏览器: 选项/设置-&gt; 高级设置 -&gt; 隐私于安全 -&gt; 管理 HTTPS/SSL 证书 -&gt; 证书颁发机构<br>火狐浏览器: 首选项 -&gt; 高级 -&gt; 证书 -&gt; 查看证书 -&gt; 证书机构<br>chrome浏览器: 设置 -&gt; 高级 -&gt; 管理证书 -&gt; 授权中心<br>ubuntu: /etc/ssl/certs </p></blockquote><h3 id="ca-crt和server-crt的关系"><a href="#ca-crt和server-crt的关系" class="headerlink" title="ca.crt和server.crt的关系"></a>ca.crt和server.crt的关系</h3><p>1) SSL Server 自己生成一个 私钥/公钥对。server.key/server.pub // 私钥加密，公钥解密！<br>2) server.pub 生成一个请求文件 server.req. 请求文件中包含有 server 的一些信息，如域名/申请者/公钥等。<br>3) server 将请求文件 server.req 递交给 CA，CA验明正身后，将用 ca.key和请求文件加密生成 server.crt<br>4) 由于 ca.key 和 ca.crt 是一对, 于是 ca.crt 可以解密 server.crt. </p><blockquote><p>在实际应用中：如果 SSL Client 想要校验 SSL server.那么 SSL server 必须要将他的证书 server.crt 传给 client.然后 client 用 ca.crt 去校验 server.crt 的合法性。如果是一个钓鱼网站，那么CA是不会给他颁发合法server.crt证书的，这样client 用ca.crt去校验，就会失败。</p></blockquote><h2 id="单向认证、双向认证"><a href="#单向认证、双向认证" class="headerlink" title="单向认证、双向认证"></a>单向认证、双向认证</h2><p>单向认证指的是只有一个对象校验对端的证书合法性。<br>通常都是client来校验服务器的合法性。那么client需要一个ca.crt,服务器需要server.crt,server.key </p><blockquote><p>双向认证指的是相互校验，服务器需要校验每个client,client也需要校验服务器。<br>server 需要 server.key 、server.crt 、ca.crt<br>client 需要 client.key 、client.crt 、ca.crt</p></blockquote><h2 id="证书详细工作流"><a href="#证书详细工作流" class="headerlink" title="证书详细工作流"></a>证书详细工作流</h2><p><img src="https://upload-images.jianshu.io/upload_images/422094-867a61bb8c15defc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="SSL-TLS单向认证流程"><a href="#SSL-TLS单向认证流程" class="headerlink" title="SSL/TLS单向认证流程"></a>SSL/TLS单向认证流程</h2><p><img src="https://upload-images.jianshu.io/upload_images/422094-2b299544afca9ffb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="SSL-TLS双向认证流程"><a href="#SSL-TLS双向认证流程" class="headerlink" title="SSL/TLS双向认证流程"></a>SSL/TLS双向认证流程</h2><p>和单向认证几乎一样，只是在client认证完服务器证书后，client会将自己的证书client.crt传给服务器。服务器验证通过后，开始秘钥协商。 </p><h2 id="证书等格式说明"><a href="#证书等格式说明" class="headerlink" title="证书等格式说明"></a>证书等格式说明</h2><h3 id="crt-key-req-csr-pem-der等拓展名都是什么东东？"><a href="#crt-key-req-csr-pem-der等拓展名都是什么东东？" class="headerlink" title="crt/key/req/csr/pem/der等拓展名都是什么东东？"></a>crt/key/req/csr/pem/der等拓展名都是什么东东？</h3><p>crt 表示证书, .key表示私钥, .req 表示请求文件,.csr也表示请求文件, .pem表示pem格式，.der表示der格式。<br>文件拓展名你可以随便命名。只是为了理解需要而命名不同的拓展名。但文件中的信息是有格式的，和exe，PE格式一样,证书有两种格式。<br>pem格式和der格式。所有证书，私钥等都可以是pem,也可以是der格式，取决于应用需要。<br>pem和der格式可以互转</p><h3 id="证书和公钥关系"><a href="#证书和公钥关系" class="headerlink" title="证书和公钥关系"></a>证书和公钥关系</h3><p>证书中含有 申请者公钥、申请者的组织信息和个人信息、签发机构 CA的信息、有效时间、证书序列号等信息的明文，同时包含一个签名。如查看百度证书详细信息。</p><h2 id="SSL-TLS和-Openssl-mbedtls是什么关系？"><a href="#SSL-TLS和-Openssl-mbedtls是什么关系？" class="headerlink" title="SSL/TLS和 Openssl,mbedtls是什么关系？"></a>SSL/TLS和 Openssl,mbedtls是什么关系？</h2><p>SSL/TLS是一种工作原理，openssl和mbedtls是SSL/TLS的具体实现，很类似于 TCP/IP协议和socket之间的关系。</p><h1 id="本地生成SSL相关文件"><a href="#本地生成SSL相关文件" class="headerlink" title="本地生成SSL相关文件"></a>本地生成SSL相关文件</h1><p>建立一个CA(ca.crt + ca.key)，用这个CA给server和client分别颁发证书。<br>首先建四个文件</p><blockquote><p>ca目录：保存ca的私钥ca.key和证书ca.crt<br>certDER目录:将证书保存为二进制文件 ca.der client.der server.der<br>client目录: client.crt client.key </p></blockquote><h2 id="server目录-server-crt-server-key"><a href="#server目录-server-crt-server-key" class="headerlink" title="server目录:server.crt server.key"></a>server目录:server.crt server.key</h2><p>实际操作时注意目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//  private key generation</span><br><span class="line">openssl genrsa -out ca.key 1024</span><br><span class="line">openssl genrsa -out server.key 1024</span><br><span class="line">openssl genrsa -out client.key 1024</span><br><span class="line">//  cert requests</span><br><span class="line">openssl req -out ca.req -key ca.key -new</span><br><span class="line">openssl req -out server.req -key server.key -new</span><br><span class="line">openssl req -out client.req -key client.key -new </span><br><span class="line">//  generate the actual certs.</span><br><span class="line">openssl x509 -req -in ca.req -out ca.crt -sha1 -days 5000 -signkey ca.key</span><br><span class="line">openssl x509 -req -in server.req -out server.crt -sha1 -CAcreateserial -days 5000 -CA ca.crt -CAkey ca.key</span><br><span class="line">openssl x509 -req -in client.req -out client.crt -sha1 -CAcreateserial -days 5000  -CA ca.crt -CAkey ca.key</span><br></pre></td></tr></table></figure></p><p>验证<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl verify -CAfile ca/ca.crt server/server.crt</span><br><span class="line">openssl verify -CAfile ca/ca.crt client/client.crt</span><br></pre></td></tr></table></figure></p><p>注意：<br>如果<code>Common Name (e.g. server FQDN or YOUR name) []:</code>,填的和ca一样，会不通过。报错如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">openssl verify -CAfile ca/ca.crt server/server.crt </span><br><span class="line">server/server.crt: C = AU, ST = Some-State, O = Internet Widgits Pty Ltd, CN = req_distinguished_name</span><br><span class="line">error 18 at 0 depth lookup:self signed certificate</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssl/tls </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>grpc学习记录</title>
      <link href="/2019/04/08/golang-2019-04-08-grpc%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/04/08/golang-2019-04-08-grpc%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="learngrpc"><a href="#learngrpc" class="headerlink" title="learngrpc"></a>learngrpc</h1><p>grpc学习记录</p><ol><li>带入gRPC：gRPC及相关介绍</li><li>带入gRPC：gRPC Client and Server</li><li>带入gRPC：gRPC Streaming, Client and Server</li><li>带入gRPC：TLS 证书认证</li><li>带入gRPC：基于 CA 的 TLS 证书认证</li><li>带入gRPC：Unary and Stream interceptor</li><li>带入gRPC：让你的服务同时提供 HTTP 接口</li><li>带入gRPC：对 RPC 方法做自定义认证</li><li>带入gRPC：gRPC Deadlines</li><li>带入gRPC：分布式链路追踪 gRPC+Opentracing+Zipkin</li></ol><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://github.com/EDDYCJY/blog" target="_blank" rel="noopener">https://github.com/EDDYCJY/blog</a></p><p>其中有些地方和参考文章不同，但最终实现效果是一样的。</p><h1 id="比较好的参考"><a href="#比较好的参考" class="headerlink" title="比较好的参考"></a>比较好的参考</h1><p>grpc入门必读：gRPC Go: Beyond the basics  </p><p><a href="https://blog.gopheracademy.com/advent-2017/go-grpc-beyond-basics/" target="_blank" rel="noopener">https://blog.gopheracademy.com/advent-2017/go-grpc-beyond-basics/</a></p><p>这个人的几篇文章都值得参考下<br>[Tutorial, Part 1] How to develop Go gRPC microservice with HTTP/REST endpoint, middleware, Kubernetes deployment, etc.<br><a href="https://medium.com/@amsokol.com/tutorial-how-to-develop-go-grpc-microservice-with-http-rest-endpoint-middleware-kubernetes-daebb36a97e9" target="_blank" rel="noopener">https://medium.com/@amsokol.com/tutorial-how-to-develop-go-grpc-microservice-with-http-rest-endpoint-middleware-kubernetes-daebb36a97e9</a></p><h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p>方便自己回忆，不构成参考</p><h2 id="grpc介绍"><a href="#grpc介绍" class="headerlink" title="grpc介绍"></a>grpc介绍</h2><p>服务端主要代码<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lis, err := net.Listen(<span class="string">"tcp"</span>, fmt.Sprintf(<span class="string">":%d"</span>, *port))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">"failed to listen: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">grpcServer := grpc.NewServer()</span><br><span class="line">...</span><br><span class="line">pb.RegisterSearchServer(grpcServer, &amp;SearchServer&#123;&#125;)</span><br><span class="line">grpcServer.Serve(lis)</span><br></pre></td></tr></table></figure></p><p>客户端主要代码<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> opts []grpc.DialOption</span><br><span class="line">...</span><br><span class="line">conn, err := grpc.Dial(*serverAddr, opts...)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatalf(<span class="string">"fail to dial: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line">client := pb.NewSearchClient(conn)</span><br></pre></td></tr></table></figure></p><h2 id="Simple-RPC"><a href="#Simple-RPC" class="headerlink" title="Simple RPC"></a>Simple RPC</h2><p>代码在demo2</p><ol><li>protoc 的简单命令要掌握，protoc help看下就差不多了</li></ol><h2 id="流式-grpc"><a href="#流式-grpc" class="headerlink" title="流式 grpc"></a>流式 grpc</h2><p>代码在demo3-stream</p><p>流式（stream）适用场景：</p><ol><li>实时</li><li>大规模数据</li></ol><p>具体是选择流式grpc还是普通grpc要根据自己的实际业务来决定</p><h2 id="给rpc加上tls证书认证"><a href="#给rpc加上tls证书认证" class="headerlink" title="给rpc加上tls证书认证"></a>给rpc加上tls证书认证</h2><p>代码主要集中在demo4-stream-tls</p><blockquote><p>在看这部分代码之前，强烈建议先读下面文章<br><a href="https://www.barretlee.com/blog/2015/10/05/how-to-build-a-https-server/" target="_blank" rel="noopener">https://www.barretlee.com/blog/2015/10/05/how-to-build-a-https-server/</a><br>后来发现。这篇文章里讲到的中间人攻击部分感觉不准确。密钥协商时第三次必须用公钥加密就好，只有服务端得私钥才可以解开。这样就已经可以防止中间人攻击了，因为即使中间人拿到了数据，他们无法解密。<br><a href="https://www.wosign.com/info/https_tls_ssl_http.htm" target="_blank" rel="noopener">https://www.wosign.com/info/https_tls_ssl_http.htm</a><br><a href="https://www.barretlee.com/blog/2016/04/24/detail-about-ca-and-certs/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">https://www.barretlee.com/blog/2016/04/24/detail-about-ca-and-certs/?utm_source=tuicool&amp;utm_medium=referral</a><br><a href="https://blog.csdn.net/ustccw/article/details/76691248" target="_blank" rel="noopener">https://blog.csdn.net/ustccw/article/details/76691248</a></p></blockquote><p>任何个体/组织都可以扮演 CA 的角色，只不过难以得到客户端的信任。浏览器默认信任的CA大厂有好几个。</p><blockquote><p>这里插一点签名验签的理解:签名验签作用有验证身份，确保数据没有被篡改。首先你用hash函数将原始数据进行哈希得到摘要，然后用私钥签名（hash+私钥），我用对应的公钥验签，先是用公钥进行解密（公钥+签名）得到hash，然后对原始数据进行哈希，对比自己解密之后得到的数据，如果相同，验签成功。说明这个签名确实是你签名的。</p></blockquote><blockquote><p>如果攻击者修改了原始数据，没有改签名。那我用你的公钥解密签名后得到的hash就和原始数据的hash不同了。验签失败。这样就确保了数据没有被篡改。</p></blockquote><blockquote><p>如果攻击者修改了原始数据，并且用自己私钥进行签名，那我用你的公钥解密签名后还是和原始数据的hash对不上（只有用攻击者的公钥解密签名才能对上），验签失败。这样既能确保数据没有被篡改，也能确保签名着的身份。<br>如果攻击者修改了原始数据，并且用自己的私钥签名。并且把我本地存储的你的公钥也悄悄替换成他的了。那我验签成功了。 攻击成功了，怎么办？<br>这就需要CA证书的作用了。你拿你的公钥到CA认证下得到证书。以后给我发送消息时，把证书也附加上。我用ca根证书就可以验证你的证书了。<br>这样一般攻击者就没有办法了。</p></blockquote><p>刚开始的时候，对这节内容和下节内容感觉到很迷惑。基于tls和基于ca的tls，后来看到这句话才恍然大悟啊。</p><blockquote><p>用户证书的制作流程和CA证书的制作是一样的，只是CA是自签发动作，而用户证书是由CA使用私钥签发而已。</p></blockquote><h3 id="困惑1"><a href="#困惑1" class="headerlink" title="困惑1"></a>困惑1</h3><p>为什么请求时，client端也需要配置证书和服务器名？<br>可以说明的文章：<a href="https://forfuncsake.github.io/post/2017/08/trust-extra-ca-cert-in-go-app/" target="_blank" rel="noopener">https://forfuncsake.github.io/post/2017/08/trust-extra-ca-cert-in-go-app/</a></p><p>为了怕这个文章丢失，已经把它复制到demo4-stream-tls里面了。</p><p>按照文章所说，我们进行了一些测试，测试记录在本小节[demo4-stream-tls]的readme.md中记录</p><h2 id="给grpc加上ca证书"><a href="#给grpc加上ca证书" class="headerlink" title="给grpc加上ca证书"></a>给grpc加上ca证书</h2><p>这里的tls是基于ca的。所以服务端给客户端传输证书的过程中被攻击的弊端就消除了。</p><h3 id="实验1"><a href="#实验1" class="headerlink" title="实验1"></a>实验1</h3><p>ca证书（ca.pem）我们可以使用系统的。</p><p>在下面这篇文章中可以学习，我们可以直接使用系统的证书。<br><a href="https://forfuncsake.github.io/post/2017/08/trust-extra-ca-cert-in-go-app/" target="_blank" rel="noopener">https://forfuncsake.github.io/post/2017/08/trust-extra-ca-cert-in-go-app/</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get the SystemCertPool, continue with an empty pool on error</span></span><br><span class="line">rootCAs, _ := x509.SystemCertPool()</span><br><span class="line"><span class="keyword">if</span> rootCAs == <span class="literal">nil</span> &#123;</span><br><span class="line">rootCAs = x509.NewCertPool()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个相当于是把系统的证书进行了一次拷贝，如果我们想要添加证书，可以在拷贝得到的<code>rootCAs</code> 中添加。</p><p><strong>或者是我们提前把证书添加到系统证书路径中[参考demo4-stream-tls]，然后把系统证书进行一次拷贝</strong></p><h2 id="grpc-拦截器（interceptor）-gt-中间件"><a href="#grpc-拦截器（interceptor）-gt-中间件" class="headerlink" title="grpc 拦截器（interceptor）-&gt; 中间件"></a>grpc 拦截器（interceptor）-&gt; 中间件</h2><p>本节内容在demo6-interceptor</p><p>有两种拦截器</p><ol><li>grpc.UnaryInterceptor 一元拦截器</li><li>grpc.StreamInterceptor 流拦截器</li></ol><p>GRPC 本身居然只能设置一个拦截器，要实现过个拦截器怎么办？</p><blockquote><p>我们需要<a href="https://github.com/grpc-ecosystem/go-grpc-middleware这个开源项目" target="_blank" rel="noopener">https://github.com/grpc-ecosystem/go-grpc-middleware这个开源项目</a></p></blockquote><p>这个项目中有一些</p><p>感觉interceptor的实现，和http框架gin的中间件是很类似的。</p><h2 id="demo7-sample-http"><a href="#demo7-sample-http" class="headerlink" title="demo7-sample-http"></a>demo7-sample-http</h2><p>我们先实现不带tls的</p><p>其实是多了一个判断转发，server是指<code>grpcServer</code>，mux是一个<code>http.ServeMux</code><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">http.ListenAndServe(port, http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> r.ProtoMajor == <span class="number">2</span> &amp;&amp; strings.Contains(r.Header.Get(<span class="string">"Content-Type"</span>), <span class="string">"application/grpc"</span>) &#123;</span><br><span class="line">server.ServeHTTP(w, r)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">mux.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure></p><p>这个通过浏览器访问时可以的，但是通过client.go访问就会出问题。</p><p>因为client.go访问需要进入到 <code>server.ServeHTTP(w, r)</code>,这个方法必须接受tls的连接。</p><p>所以这节的grpc是不能用的</p><h2 id="demo7-sample-https"><a href="#demo7-sample-https" class="headerlink" title="demo7-sample-https"></a>demo7-sample-https</h2><p>通过给通信加上tls证书，我们解决了上节的问题。</p><h2 id="grpc-自定义验证"><a href="#grpc-自定义验证" class="headerlink" title="grpc 自定义验证"></a>grpc 自定义验证</h2><p>比如我们要验证token。</p><p>其实对于比较常见的认证，我们做个拦截器也是挺好的。</p><h2 id="grpc-Deadline"><a href="#grpc-Deadline" class="headerlink" title="grpc Deadline"></a>grpc Deadline</h2><p>主要是放着请求阻塞对服务器造成的危害</p><p>设置deadline主要是在客户端</p><p><code>context.WithDeadline()</code></p><h2 id="gprc-Opentracing-Zipkin"><a href="#gprc-Opentracing-Zipkin" class="headerlink" title="gprc + Opentracing + Zipkin"></a>gprc + Opentracing + Zipkin</h2><p>分布式链路追踪</p><p>代码主要在demo10-Opentracing-Zipkin和 <code>demo10-Opentracing-Zipkin2</code></p><h2 id="grpc-网关"><a href="#grpc-网关" class="headerlink" title="grpc 网关"></a>grpc 网关</h2><p>相当于给grpc提供了对应restful访问接口。</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> grpc </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>golang中有趣的三个点...</title>
      <link href="/2019/04/04/golang-2019-04-04-golang%E4%B8%AD%E6%9C%89%E8%B6%A3%E4%B8%89%E4%B8%AA%E7%82%B9/"/>
      <url>/2019/04/04/golang-2019-04-04-golang%E4%B8%AD%E6%9C%89%E8%B6%A3%E4%B8%89%E4%B8%AA%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test</span><span class="params">(num ...<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表示函数<code>Test</code> 可以接受多个<code>int</code> 类型的参数</p><h1 id="将切片拆分"><a href="#将切片拆分" class="headerlink" title="将切片拆分"></a>将切片拆分</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">Test(s...)</span><br></pre></td></tr></table></figure><p>这里就是把切片<code>s</code>拆分成多个元素传入了</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 语法糖 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>rust by example 学习记录</title>
      <link href="/2019/03/27/rust-2019-03-27-rust-by-example-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/03/27/rust-2019-03-27-rust-by-example-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>文章不是教程，只是记录一些自己可能忘记的代码片段.<br>中文：<br><a href="https://rustwiki.org/zh-CN/rust-by-example/" target="_blank" rel="noopener">https://rustwiki.org/zh-CN/rust-by-example/</a><br>英文：<br><a href="https://doc.rust-lang.org/stable/rust-by-example/f" target="_blank" rel="noopener">https://doc.rust-lang.org/stable/rust-by-example/f</a></p><blockquote><p>中文读起来很快，如果有些地方感觉不知所云，看不懂，一定要打开英文看看，看英文就是慢点，但是一段话到底是在讲什么，很透彻。</p></blockquote><h1 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h1><p>结构体、枚举[使用use，C风格用法，测试实例：链表]、常量</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 隐藏未使用代码警告的属性</span></span><br><span class="line"><span class="meta">#![#[allow(dead_code)]</span></span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `to_owned()` 从一个字符串 slice 创建一个具有所有权的 `String`。</span></span><br><span class="line"><span class="keyword">let</span> dave     = Person::Info &#123; name: <span class="string">"Dave"</span>.to_owned(), height: <span class="number">72</span> &#125;;</span><br></pre></td></tr></table></figure><p>一个使用enum的例子<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Person</span></span> &#123;</span><br><span class="line">    Engineer,</span><br><span class="line">    Scientist,</span><br><span class="line">    Height(<span class="built_in">i32</span>),</span><br><span class="line">    Weight(<span class="built_in">i32</span>),</span><br><span class="line">    Info &#123; name: <span class="built_in">String</span>, height: <span class="built_in">i32</span> &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">inspect</span></span>(p: Person) &#123;</span><br><span class="line"><span class="comment">// 明确地 `use` 各个名称使他们直接可用而不需要手动加上作用域。</span></span><br><span class="line">    <span class="keyword">use</span> Person::&#123;Engineer&#125;;</span><br><span class="line">    <span class="keyword">match</span> p &#123;</span><br><span class="line">    <span class="comment">// 上面使用use了，所以这里可以不用加作用域了</span></span><br><span class="line">        Engineer =&gt; <span class="built_in">println!</span>(<span class="string">"is a engineer"</span>),</span><br><span class="line">        Person::Scientist =&gt; <span class="built_in">println!</span>(<span class="string">"is a scientist"</span>),</span><br><span class="line">        Person::Height(i) =&gt; <span class="built_in">println!</span>(<span class="string">"has a height of &#123;&#125;."</span>, i),</span><br><span class="line">        Person::Weight(i) =&gt; <span class="built_in">println!</span>(<span class="string">"has a weight of &#123;&#125;"</span>, i),</span><br><span class="line">        Person::Info &#123; name, height &#125; =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"&#123;&#125; is &#123;&#125; tall!"</span>, name, height);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> person = Person::Height(<span class="number">18</span>);</span><br><span class="line">    <span class="keyword">let</span> amira = Person::Weight(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">let</span> dave = Person::Info &#123;name:<span class="string">"Dive"</span>.to_owned(),height:<span class="number">72</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> rebecca = Person::Scientist;</span><br><span class="line">    <span class="keyword">let</span> rohan = Person::Engineer;</span><br><span class="line">    inspect(person);</span><br><span class="line">    inspect(amira);</span><br><span class="line">    inspect(dave);</span><br><span class="line">    inspect(rebecca);</span><br><span class="line">    inspect(rohan);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>enum的一个常见用法就是创建链表</p></blockquote><h1 id="变量绑定"><a href="#变量绑定" class="headerlink" title="变量绑定"></a>变量绑定</h1><p>可变变量、作用域和隐藏、变量先声明</p><h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p>rust在基本类型之间没有提供隐式类型转化（implicit type conversion,coercion)(强制类型转化)。但是使用关键字<code>as</code>可以显式转化(explict type conversion,casting)</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>方法部分一个比较好的实例<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pair 含有的资源，两个堆分配的整型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pair</span></span>(<span class="built_in">Box</span>&lt;<span class="built_in">i32</span>&gt;,<span class="built_in">Box</span>&lt;<span class="built_in">i32</span>&gt;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Pair &#123;</span><br><span class="line">    <span class="comment">// 这个方法“消费”调用者对象的资源</span></span><br><span class="line">    <span class="comment">// self 为 `self:Self`的语法糖</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">destroy</span></span>(<span class="keyword">self</span>)&#123;</span><br><span class="line">        <span class="comment">// 解构 `self`</span></span><br><span class="line">        <span class="keyword">let</span> Pair(first,second)=<span class="keyword">self</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"destroy Pair(&#123;&#125;,&#123;&#125;)"</span>,first,second);</span><br><span class="line">        <span class="comment">// `first`和`second`离开作用域后释放</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> pair = Pair(<span class="built_in">Box</span>::new(<span class="number">1</span>),<span class="built_in">Box</span>::new(<span class="number">2</span>));</span><br><span class="line">    pair.destroy();</span><br><span class="line">    <span class="comment">// 报错！前面的 `destroy` 调用“消费了” `pair`</span></span><br><span class="line">    <span class="comment">//pair.destroy();</span></span><br><span class="line">    <span class="comment">// 试一试 ^ 将此行注释去掉</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="捕获"><a href="#捕获" class="headerlink" title="捕获"></a>捕获</h3><p>闭包本身是相当灵活的，可以实现按照所需功能来让闭包运行而不用类型标注。这允许变量捕获灵活地适应使用情况，有时是移动（moving）有时是借用(borrowing)<br>闭包可以捕获变量：</p><ul><li>通过引用：&amp;T</li><li>通过可变引用:&amp;mut T</li><li>通过值：T</li></ul><p>大白话：就是说闭包可以根据自己的使用需要来决定到底使用上面三种方式中的那种。并且优先使用<code>&amp;T</code>,不满足时才会使用下面的两种。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> std::mem;</span><br><span class="line">    <span class="keyword">let</span> color = <span class="string">"Green"</span>;</span><br><span class="line">    <span class="comment">// 闭包打印color，它会借用 &amp;color ，并将该借用和闭包存储到print变量中。</span></span><br><span class="line">    <span class="comment">// 它会一直保持借用状态直到 print 离开作用域。</span></span><br><span class="line">    <span class="comment">// println 只需要引用即可，所以他没有强加更多的限制（后面的两种）</span></span><br><span class="line">    <span class="keyword">let</span> print =|| <span class="built_in">println!</span>(<span class="string">"color :&#123;&#125;"</span>, color);</span><br><span class="line"></span><br><span class="line">    print(); <span class="comment">// 调用闭包 Green</span></span><br><span class="line">    print(); <span class="comment">// 调用闭包 Green</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 闭包要使count的值增加，可以使用&amp;mut count 或者 count</span></span><br><span class="line">    <span class="comment">// 但是&amp;mut count 限制更少，所以采用它，仅仅借用count[&amp;mut count]即可。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// inc 前面加 mut ，是因为一个可变的引用 `&amp;mut count`是存储在其内部。</span></span><br><span class="line">    <span class="comment">// 因此，调用该闭包转变成一个需要加`mut`的闭包</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> inc = ||&#123;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"count:&#123;&#125;"</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">    inc(); <span class="comment">// count:1</span></span><br><span class="line">    inc(); <span class="comment">// count:2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这行是报错的，因为你再次借用了。</span></span><br><span class="line">    <span class="comment">//let reborrow = &amp;mut count;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再实验一下： 不可复制类型（non-copy type）</span></span><br><span class="line">    <span class="keyword">let</span> movable = <span class="built_in">Box</span>::new(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// 因为下面的闭包中，mem::drop()要求使用T，所以这必须通过使用值来实现。</span></span><br><span class="line">    <span class="comment">// 如果是可复制类型，将会复制值到闭包而不会用到原始值，</span></span><br><span class="line">    <span class="comment">// 不可复制类型的话，就必须移动（move），因此变量movable 就被移动到了闭包中。</span></span><br><span class="line">    <span class="keyword">let</span> consume = ||&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"movable:&#123;&#125;"</span>, movable);</span><br><span class="line">        mem::<span class="built_in">drop</span>(movable);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// consume 消费（consume）了该变量，所以这只能调用一次。</span></span><br><span class="line">    consume() </span><br><span class="line"></span><br><span class="line">    <span class="comment">// consume()  报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作为输入参量"><a href="#作为输入参量" class="headerlink" title="作为输入参量"></a>作为输入参量</h3><p>闭包作为输入参数时，闭包的完整类型必须使用以下的其中一种 <code>trait</code> 来标注。他们的受限程序依次递减。</p><ul><li><code>Fn</code>：闭包捕获引用(<code>&amp;T</code>)</li><li><code>FnMut</code>:闭包捕获可变引用(<code>&amp;mut T</code>)</li><li><code>FnOnce</code>:闭包捕获值(T)</li></ul><p>假如想作为一个标记为<code>FnOnce</code>类型的参数，这意味着闭包可以捕获<code>&amp;T</code> ,<code>&amp;mut T</code>,<code>T</code>三种类型。但是编译器最终会选择哪个，取决于捕获的变量在闭包中如何使用。</p><p>This is because if a move is possiable ,then any type of borrow should also be possible.Note that the reverse is not true. if the parameter is annotated as <code>Fn</code>,then capturing variables by <code>&amp;mut T</code> or <code>T</code> are not allowed.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把闭包作为参数并调用它</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">apply</span></span>&lt;F&gt;(f:F)<span class="keyword">where</span></span><br><span class="line">    F:<span class="built_in">FnOnce</span>()&#123;</span><br><span class="line">    f();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把闭包作为参数，返回i32类型的值</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">apply_to_3</span></span>&lt;F&gt;(f:F) -&gt;<span class="built_in">i32</span> <span class="keyword">where</span> F:<span class="built_in">Fn</span>(<span class="built_in">i32</span>)-&gt;<span class="built_in">i32</span>&#123;</span><br><span class="line">    f(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> std::mem;</span><br><span class="line">    <span class="keyword">let</span> greeting = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="comment">// 不可复制的类型</span></span><br><span class="line">    <span class="comment">// `to_owned`从借用的数据中创建了自己有所有权的数据</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> farewell = <span class="string">"goodbye"</span>.to_owned();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 捕获两个变量：greeting 通过引用，farewell通过值。</span></span><br><span class="line">    <span class="keyword">let</span> diary = ||&#123;</span><br><span class="line">        <span class="comment">// greeting 通过引用：需要 `Fn` trait</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"i said &#123;&#125;"</span>, greeting);</span><br><span class="line">        <span class="comment">// 迫使 farewell 以可变引用的方式被捕获，这种情况需要 `FnMut` trait</span></span><br><span class="line">        farewell.push_str(<span class="string">"!!!"</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"then i screamed &#123;&#125;"</span>, farewell);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"now i can sleep"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 手动调用drop,迫使farewell以值的方式被捕获。这种情况需要 `FnOnce` trait</span></span><br><span class="line">        mem::<span class="built_in">drop</span>(farewell);</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 调用处理闭包的函数</span></span><br><span class="line">    apply(diary);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> double = |x| <span class="number">2</span>*x;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"2 double:&#123;&#125;"</span>, apply_to_3(double));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中，如果我们将<code>apply</code> 函数改变成下面的类型<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把闭包作为参数并调用它</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">apply</span></span>&lt;F&gt;(f:F)<span class="keyword">where</span></span><br><span class="line">    F:<span class="built_in">FnMut</span>()&#123;</span><br><span class="line">    f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>程序就不行了，因为声明<code>FnMut</code>类型已经限定了传入的闭包只能捕获<code>T</code> 和 <code>&amp;T</code> 的类型，而在闭包中<code>mem::drop(farewell);</code> 是需要捕获值的类型的。所以报错。</p><h3 id="闭包作为输出参量"><a href="#闭包作为输出参量" class="headerlink" title="闭包作为输出参量"></a>闭包作为输出参量</h3><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><h2 id="文件分层"><a href="#文件分层" class="headerlink" title="文件分层"></a>文件分层</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ tree .</span><br><span class="line">.</span><br><span class="line">|-- my</span><br><span class="line">|   |-- inaccessible.rs</span><br><span class="line">|   |-- mod.rs</span><br><span class="line">|   `-- nested.rs</span><br><span class="line">`-- split.rs</span><br></pre></td></tr></table></figure><p>在split.rs中<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此声明将会查找名为 `my.rs` 或 `my/mod.rs` 的文件，并将该文件的内容插入到</span></span><br><span class="line"><span class="comment">// 此作用域名为 `my` 的模块里面。</span></span><br><span class="line"><span class="keyword">mod</span> my;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"called `function()`"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="crate"><a href="#crate" class="headerlink" title="crate"></a>crate</h1><p>如果crate中有mod声明，那么模块文件的内容将会在运行编译之前与crate文件合并。换句话说，模块不会单独进行编译，只有crate进行编译。</p><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><h2 id="crate-1"><a href="#crate-1" class="headerlink" title="crate"></a>crate</h2><p><code>crate_type</code> 属性可以告知编译器 <code>crate</code>是一个二进制的可执行文件还是一个库（甚至是哪种类型的库），crate_time 属性可以设定 crate 的名称。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个 crate 是一个库文件</span></span><br><span class="line"><span class="meta">#![crate_type = <span class="meta-string">"lib"</span>]</span></span><br><span class="line"><span class="comment">// 库的名称为 “rary”</span></span><br><span class="line"><span class="meta">#![crate_name = <span class="meta-string">"rary"</span>]</span></span><br></pre></td></tr></table></figure></p><h2 id="cfg"><a href="#cfg" class="headerlink" title="cfg"></a>cfg</h2><p>例如控制代码在哪个系统上执行<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数仅当操作系统是 Linux 的时候才会编译</span></span><br><span class="line"><span class="meta">#[cfg(target_os = <span class="meta-string">"linux"</span>)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">are_you_on_linux</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"You are running linux!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h2><h2 id="实现-implementation"><a href="#实现-implementation" class="headerlink" title="实现 implementation"></a>实现 implementation</h2><h2 id="特性-trait"><a href="#特性-trait" class="headerlink" title="特性 trait"></a>特性 trait</h2><h1 id="作用域规则"><a href="#作用域规则" class="headerlink" title="作用域规则"></a>作用域规则</h1><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="显式标注"><a href="#显式标注" class="headerlink" title="显式标注"></a>显式标注</h3><p>编译器（有时也称为借用检查器）使用它来确保所有的借用都是有效的。<br><code>foo&lt;&#39;a,&#39;b&gt;</code></p><p>在这种情况下，foo的生命周期不能超出’a或’b的周期。</p>]]></content>
      
      
      <categories>
          
          <category> rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>正则表达式学习笔记</title>
      <link href="/2019/03/26/%E9%80%9A%E7%94%A8%E8%AE%A1%E7%AE%97%E6%9C%BA-2019-03-26-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/03/26/%E9%80%9A%E7%94%A8%E8%AE%A1%E7%AE%97%E6%9C%BA-2019-03-26-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>正则表达式学习(js)</p><h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>先拿数字举例</p><table><thead><tr><th style="text-align:center">符号</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:center">\d</td><td>数字</td></tr><tr><td style="text-align:center">\d?</td><td>0个或1个数字</td></tr><tr><td style="text-align:center">\d+</td><td>1个或多个数字</td></tr><tr><td style="text-align:center">\d*</td><td>0个或多个数字</td></tr><tr><td style="text-align:center">\d{3}</td><td>3个数字</td></tr><tr><td style="text-align:center">\d{3,5}</td><td>3个到5个数字</td></tr></tbody></table><p>几个常用的例子</p><ol><li><p>单词边界\b</p><p>比如我们就像匹配单词<code>is</code>,像<code>qishi</code>这样的不要匹配，我们就需要<code>\bis\b</code></p></li><li><p>点.表示任意字符</p><p>如果我们就需要匹配点.,那我们就需要转义<code>\.</code></p></li><li><p>匹配<code>//</code></p><p>网址中经常有<code>//</code>,要匹配这个，也需要转义<code>\/\/</code></p></li><li><p>分组()</p><p>分组之后，我们可以提取其中的内容</p></li><li><p>或者[]</p><p>在匹配日期中,<code>[-/]</code>,就可以要么匹配<code>-</code>,要么匹配<code>/</code></p></li><li><p>开头、结尾</p><p>^表示以什么开始，$表示以什么结束</p></li></ol><h1 id="正则对象"><a href="#正则对象" class="headerlink" title="正则对象"></a>正则对象</h1><p>创建一个正则对象</p><p><code>var reg = new RegExp(&#39;\\bis\\b&#39;,&#39;g&#39;)</code></p><p><code>\\</code>，第一个是为了转义，第二个是配合后面的<code>\b</code></p><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><ul><li>g: global 表示全文搜索</li><li>i: ignore case 忽略大小写。默认大小写敏感</li><li>m:multiple lines 多行搜索</li></ul><p>多行匹配就是让后面的行同样适用于第一行的规则。<br>没加换行修饰符</p><p><img src="https://upload-images.jianshu.io/upload_images/422094-a73e8b27dfb0be51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>第二行，第三行的都没有匹配到。</p><p>如果我们加上换行修饰符<br><img src="https://upload-images.jianshu.io/upload_images/422094-23ccaa0e96549f7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h1 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h1><p>正则表达式由两种基本字符组成，一类是原义文本字符，写什么就匹配什么，我们看到的就是要匹配的。第二类就是元字符，元字符就是在正则表达式中有特殊含义的非字母字符。<br><img src="https://upload-images.jianshu.io/upload_images/422094-463443030e6cc6bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1553516159529.png"></p><h1 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h1><p><img src="https://upload-images.jianshu.io/upload_images/422094-59a483e7f22a55de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1553516410201.png"></p><p>我们使用<code>[]</code>构造了一类字符，这一类字符中，可以是abc中的任意一个。</p><h1 id="字符类取反"><a href="#字符类取反" class="headerlink" title="字符类取反"></a>字符类取反</h1><p><img src="https://upload-images.jianshu.io/upload_images/422094-1045552de3854f01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1553516535536.png"></p><h1 id="范围类"><a href="#范围类" class="headerlink" title="范围类"></a>范围类</h1><p>如果我们要需要一个类，包括数字从5到9,我们需要这样<code>[5 6 7 8 9]</code>,如果数字多的话，会很麻烦<br>所以就需要范围类了<br><img src="https://upload-images.jianshu.io/upload_images/422094-595512eed6a0cf16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="连写"><a href="#连写" class="headerlink" title="连写"></a>连写</h2><p>[a-zA-Z],就把大小写都包括了。<br>如果我们不光包括大小写，还需要包括<code>-</code><br>[a-zA-Z-]，后面加一个<code>-</code>就可以了。</p><h1 id="js预定义类和边界"><a href="#js预定义类和边界" class="headerlink" title="js预定义类和边界"></a>js预定义类和边界</h1><p>上一节中，看到我们可以自定义类，这样已经方便了我们书写，但是还不够，为此，正则表达式还给我们提供了预定义类来匹配常见的字符类。<br><img src="https://upload-images.jianshu.io/upload_images/422094-8020d1d606440f54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/422094-98a681b50b95f746.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>我们可以自己构造：<br><code>ab[0-9][^\r\n]</code><br>也可以使用正则的预定义类<br><code>ab\d.</code></p><h2 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h2><p><img src="https://upload-images.jianshu.io/upload_images/422094-dcb5181896235361.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>举例</p><p><img src="https://upload-images.jianshu.io/upload_images/422094-79e496ba73c10c19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h1><p>我们希望匹配一个连续出现20次的数字的字符串</p><p><img src="https://upload-images.jianshu.io/upload_images/422094-446e7bc3d67fd311.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>好麻烦</p><p><img src="https://upload-images.jianshu.io/upload_images/422094-4767f9d50315ba3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h1 id="贪婪模式和非贪婪模式"><a href="#贪婪模式和非贪婪模式" class="headerlink" title="贪婪模式和非贪婪模式"></a>贪婪模式和非贪婪模式</h1><p><img src="https://upload-images.jianshu.io/upload_images/422094-5045f2f20ac27bad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>这个会匹配多少？<br>默认是贪婪模式，会都匹配。<br>如果我们想让它尽可能少的匹配，我们就设置为非贪婪模式。<br><img src="https://upload-images.jianshu.io/upload_images/422094-4b8fd7c0271e82e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>举例：<br><img src="https://upload-images.jianshu.io/upload_images/422094-14c37e86e7c94229.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h1 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h1><p>我们有这样的场景，匹配字符串<code>Byron</code>出现三次的场景。<br>学习了量词之后，我们可以这样：<code>Byron{3}</code><br>但是这并不是我们需要的，因为它代表的是<code>n</code>出现三次。<br><img src="https://upload-images.jianshu.io/upload_images/422094-3cba30a85a25d820.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="或"><a href="#或" class="headerlink" title="或"></a>或</h2><p><img src="https://upload-images.jianshu.io/upload_images/422094-9dfa38a6090f79c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上面的例子，如果我们只是想把或作用<code>on</code>或<code>Ca</code>，我们可以这样<br><img src="https://upload-images.jianshu.io/upload_images/422094-da513b5028a88d3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h2><p>场景：<br><img src="https://upload-images.jianshu.io/upload_images/422094-55c8ab9917639417.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>不光是<code>-</code>变成了<code>/</code>,日期的顺序也变了。</p><blockquote><p>我们要替换的内容还在字符串本身里面，就相当于变量的概念了。</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/422094-b1d4f60ae2ef83af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>note:如果没有分组的话，$就表示原义了。</p></blockquote><h2 id="忽略分组"><a href="#忽略分组" class="headerlink" title="忽略分组"></a>忽略分组</h2><p><img src="https://upload-images.jianshu.io/upload_images/422094-dbaa661b2ec79f85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="前瞻和后顾"><a href="#前瞻和后顾" class="headerlink" title="前瞻和后顾"></a>前瞻和后顾</h1><p><img src="https://upload-images.jianshu.io/upload_images/422094-1d82cc25062e60dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/422094-e0534667d4497f0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>举例<br><img src="https://upload-images.jianshu.io/upload_images/422094-c74e19287dabf807.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/422094-7a199dcb2f2afc0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>这里的<code>(?=\d)</code>不是正则部分，它是类型断言部分。</p>]]></content>
      
      
      <categories>
          
          <category> 正则表达式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>btcd的p2p网络（3）-连接ConnMgr-连接成功之后</title>
      <link href="/2019/03/18/%E6%AF%94%E7%89%B9%E5%B8%81%E7%B3%BB-btcd-2019-03-18-btcd%E7%9A%84p2p%E7%BD%91%E7%BB%9C%EF%BC%883%EF%BC%89-%E8%BF%9E%E6%8E%A5ConnMgr-%E8%BF%9E%E6%8E%A5%E6%88%90%E5%8A%9F%E4%B9%8B%E5%90%8E/"/>
      <url>/2019/03/18/%E6%AF%94%E7%89%B9%E5%B8%81%E7%B3%BB-btcd-2019-03-18-btcd%E7%9A%84p2p%E7%BD%91%E7%BB%9C%EF%BC%883%EF%BC%89-%E8%BF%9E%E6%8E%A5ConnMgr-%E8%BF%9E%E6%8E%A5%E6%88%90%E5%8A%9F%E4%B9%8B%E5%90%8E/</url>
      
        <content type="html"><![CDATA[<p>我们继续上一节，先简要回顾一下<br>我们主要通过一下几个步骤建立了一个连接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func (cm *ConnManager) Start() &#123;</span><br><span class="line">for i := atomic.LoadUint64(&amp;cm.connReqCount); i &lt; uint64(cm.cfg.TargetOutbound); i++ &#123;</span><br><span class="line">go cm.NewConnReq()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func (cm *ConnManager) NewConnReq() &#123;</span><br><span class="line">    ......</span><br><span class="line">c := &amp;ConnReq&#123;&#125;</span><br><span class="line">addr, err := cm.cfg.GetNewAddress()</span><br><span class="line">c.Addr = addr</span><br><span class="line">cm.Connect(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Connect assigns an id and dials a connection to the address of the</span><br><span class="line">// connection request.</span><br><span class="line">func (cm *ConnManager) Connect(c *ConnReq) &#123;</span><br><span class="line">    ......</span><br><span class="line">conn, err := cm.cfg.Dial(c.Addr)</span><br><span class="line">select &#123;</span><br><span class="line">case cm.requests &lt;- handleConnected&#123;c, conn&#125;:</span><br><span class="line">case &lt;-cm.quit:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在工作协程中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">func (cm *ConnManager) connHandler() &#123;</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">// pending holds all registered conn requests that have yet to</span><br><span class="line">// succeed.</span><br><span class="line">pending = make(map[uint64]*ConnReq)</span><br><span class="line"></span><br><span class="line">// conns represents the set of all actively connected peers.</span><br><span class="line">conns = make(map[uint64]*ConnReq, cm.cfg.TargetOutbound)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">for &#123;</span><br><span class="line">select &#123;</span><br><span class="line">case req := &lt;-cm.requests:</span><br><span class="line">switch msg := req.(type) &#123;</span><br><span class="line"></span><br><span class="line">case registerPending:</span><br><span class="line">connReq := msg.c</span><br><span class="line">connReq.updateState(ConnPending)</span><br><span class="line">pending[msg.c.id] = connReq</span><br><span class="line">close(msg.done)</span><br><span class="line">            // 连城成功后的处理</span><br><span class="line">case handleConnected:</span><br><span class="line">connReq := msg.c</span><br><span class="line"></span><br><span class="line">if _, ok := pending[connReq.id]; !ok &#123;</span><br><span class="line">if msg.conn != nil &#123;</span><br><span class="line">msg.conn.Close()</span><br><span class="line">&#125;</span><br><span class="line">log.Debugf(&quot;Ignoring connection for &quot;+</span><br><span class="line">&quot;canceled connreq=%v&quot;, connReq)</span><br><span class="line">continue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">connReq.updateState(ConnEstablished)</span><br><span class="line">connReq.conn = msg.conn</span><br><span class="line">conns[connReq.id] = connReq</span><br><span class="line">log.Debugf(&quot;Connected to %v&quot;, connReq)</span><br><span class="line">connReq.retryCount = 0</span><br><span class="line">cm.failedAttempts = 0</span><br><span class="line"></span><br><span class="line">delete(pending, connReq.id)</span><br><span class="line"></span><br><span class="line">if cm.cfg.OnConnection != nil &#123;</span><br><span class="line">go cm.cfg.OnConnection(connReq, msg.conn)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>我们接下来主要看的是，连接成功后干什么？</p></blockquote><p>我们就来找cm.cfg.OnConnection(),在编辑器中全局搜索之后发现，OnConnection()只有在<code>server.go</code>中配置了,<code>server.go</code>中<code>newServer()</code>方法中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cmgr, err := connmgr.New(&amp;connmgr.Config&#123;</span><br><span class="line">Listeners:      listeners,</span><br><span class="line">OnAccept:       s.inboundPeerConnected,</span><br><span class="line">RetryDuration:  connectionRetryInterval,</span><br><span class="line">TargetOutbound: uint32(targetOutbound),</span><br><span class="line">Dial:           btcdDial,</span><br><span class="line">OnConnection:   s.outboundPeerConnected,</span><br><span class="line">GetNewAddress:  newAddressFunc,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>就是这句<code>OnConnection:   s.outboundPeerConnected</code>,然后我们就去找<code>outboundPeerConnected</code>,发现<code>outboundPeerConnected</code>是一个函数，这和我们连接成功调用时是符合的：<code>go cm.cfg.OnConnection(connReq, msg.conn)</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// outboundPeerConnected is invoked by the connection manager when a new</span><br><span class="line">// outbound connection is established.  It initializes a new outbound server</span><br><span class="line">// peer instance, associates it with the relevant state such as the connection</span><br><span class="line">// request instance and the connection itself, and finally notifies the address</span><br><span class="line">// manager of the attempt.</span><br><span class="line">func (s *server) outboundPeerConnected(c *connmgr.ConnReq, conn net.Conn) &#123;</span><br><span class="line">sp := newServerPeer(s, c.Permanent)</span><br><span class="line">p, err := peer.NewOutboundPeer(newPeerConfig(sp), c.Addr.String())</span><br><span class="line">if err != nil &#123;</span><br><span class="line">srvrLog.Debugf(&quot;Cannot create outbound peer %s: %v&quot;, c.Addr, err)</span><br><span class="line">s.connManager.Disconnect(c.ID())</span><br><span class="line">&#125;</span><br><span class="line">sp.Peer = p</span><br><span class="line">sp.connReq = c</span><br><span class="line">sp.isWhitelisted = isWhitelisted(conn.RemoteAddr())</span><br><span class="line">sp.AssociateConnection(conn)</span><br><span class="line">go s.peerDoneHandler(sp)</span><br><span class="line">s.addrManager.Attempt(sp.NA())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们看到连接成功后，需要用到<code>peer</code>包来处理。请看下节的peer</p>]]></content>
      
      
      <categories>
          
          <category> btcd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> btcd </tag>
            
            <tag> p2p </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>堆栈图</title>
      <link href="/2019/03/18/study-%E7%BC%96%E7%A8%8B%E8%BE%BE%E4%BA%BA-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%913%E6%9C%9F%E5%AD%A6%E4%B9%A0-2019-03-18-%E5%A0%86%E6%A0%88%E5%9B%BE/"/>
      <url>/2019/03/18/study-%E7%BC%96%E7%A8%8B%E8%BE%BE%E4%BA%BA-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%913%E6%9C%9F%E5%AD%A6%E4%B9%A0-2019-03-18-%E5%A0%86%E6%A0%88%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>c语言逆向的思路：一块内容引出的C语言。<br>一切都是从内存出发，然后探讨C语言的各种知识。</p><blockquote><p>今天我们要分析的helloWorld.exe程序（其中包括四段程序，也就是四个函数）中的某个函数执行过程中的堆栈变化<br>exe程序<br>链接：<a href="https://pan.baidu.com/s/1ZXcCzmjk7vjz2DMICTH79g" target="_blank" rel="noopener">https://pan.baidu.com/s/1ZXcCzmjk7vjz2DMICTH79g</a><br>提取码：63su </p></blockquote><p>函数所在的内存地址：<code>0x00401168</code></p><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>1、打开exe文件，程序当前的执行位置不是<code>0x00401168</code>，<br>2、<code>ctrl + G</code>,输入<code>0x00401168</code>,就跳到了目的地，在此设置断点。<br>3、然后点击 运行 ，程序运行到<code>0x00401168</code> 就会停下。<br>堆栈分析从此开始</p><h1 id="记录初始状态"><a href="#记录初始状态" class="headerlink" title="记录初始状态"></a>记录初始状态</h1><p><img src="https://upload-images.jianshu.io/upload_images/422094-f04d2e9a646fe509.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>我们先记录下此时堆栈的状态。<br>ESP:0012FF34<br>EBP:0012FF80<br><img src="https://upload-images.jianshu.io/upload_images/422094-472df6699ddb25b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="记录初始状态、入栈"></p><h1 id="入栈参数"><a href="#入栈参数" class="headerlink" title="入栈参数"></a>入栈参数</h1><p>PUSH 2<br>PUSH 1<br>push操作的时候，只有堆栈的栈顶在发生变化，其他的不变（EIP当然变，每条指令都会变）<br>效果图如上</p><h1 id="call-调用"><a href="#call-调用" class="headerlink" title="call 调用"></a>call 调用</h1><blockquote><p>根据上一节我们学习的，call指令影响EIP和ESP。</p></blockquote><p>到call指令这一行，我们不能摁F8了，不然这个函数调用直接就完成了。我们分析就时在这个函数调用中，内存的堆栈变化。<br>这里我们要摁F7<br><img src="https://upload-images.jianshu.io/upload_images/422094-8e12c9a32320a3f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>ESP指向栈顶中存储的值其实就是地址：<code>0x401171</code>了。<br><code>0x401171</code>时怎么来的？<br>call指令所在的地址，加上指令的长度。</p><blockquote><p>从这里也可以看出，我们说函数的返回地址，说的就是call指令调用时，往栈中压入的值，就是函数执行结束后的返回地址。</p></blockquote><p>此时的JMP指令，不影响堆栈，我们直接摁ENTER跳到有用的指令处。<br><img src="https://upload-images.jianshu.io/upload_images/422094-c43d9c12347d3375.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/422094-1fa65166fbcf43e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="call调用、push EBP"></p><h1 id="PUSH-EBP"><a href="#PUSH-EBP" class="headerlink" title="PUSH EBP"></a>PUSH EBP</h1><p>把<code>栈底</code>压入到了堆栈中</p><h1 id="MOV-EBP，ESP"><a href="#MOV-EBP，ESP" class="headerlink" title="MOV EBP，ESP"></a>MOV EBP，ESP</h1><p><img src="https://upload-images.jianshu.io/upload_images/422094-3b9b35ac7051ce7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="SUB-ESP-40"><a href="#SUB-ESP-40" class="headerlink" title="SUB ESP,40"></a>SUB ESP,40</h1><p><img src="https://upload-images.jianshu.io/upload_images/422094-dfad69dce0316cc9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="保存现场"><a href="#保存现场" class="headerlink" title="保存现场"></a>保存现场</h1><p>PUSH EBX，ESI，EDI<br><img src="https://upload-images.jianshu.io/upload_images/422094-5a4501bee715de04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h1 id="LEA-EDI-DWORD-PTR-SS-EBP-40"><a href="#LEA-EDI-DWORD-PTR-SS-EBP-40" class="headerlink" title="LEA EDI,DWORD PTR SS:[EBP-40]"></a>LEA EDI,DWORD PTR SS:[EBP-40]</h1><p><img src="https://upload-images.jianshu.io/upload_images/422094-0137f9f60c2ac197.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="填充缓冲区"><a href="#填充缓冲区" class="headerlink" title="填充缓冲区"></a>填充缓冲区</h1><p><img src="https://upload-images.jianshu.io/upload_images/422094-c94664883e9794e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h1 id="处理最初push进的参数"><a href="#处理最初push进的参数" class="headerlink" title="处理最初push进的参数"></a>处理最初push进的参数</h1><p>其实这两行指令才是这个函数的最重要的指令，其他的基本上都是辅助指令。<br><img src="https://upload-images.jianshu.io/upload_images/422094-a273415ec70ffb30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="恢复现场"><a href="#恢复现场" class="headerlink" title="恢复现场"></a>恢复现场</h1><p><img src="https://upload-images.jianshu.io/upload_images/422094-34edc3db62747192.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="恢复堆栈：-MOV-ESP-EBP"><a href="#恢复堆栈：-MOV-ESP-EBP" class="headerlink" title="恢复堆栈： MOV ESP,EBP"></a>恢复堆栈： MOV ESP,EBP</h1><p><img src="https://upload-images.jianshu.io/upload_images/422094-7d0e1eae80855fcd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/422094-8bf0532d92b404bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="栈底恢复原始值：POP-EBP"><a href="#栈底恢复原始值：POP-EBP" class="headerlink" title="栈底恢复原始值：POP EBP"></a>栈底恢复原始值：POP EBP</h1><p><img src="https://upload-images.jianshu.io/upload_images/422094-461921a24e265a09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>注意此时，栈顶的位置还没有到原始值</p><h1 id="RET"><a href="#RET" class="headerlink" title="RET"></a>RET</h1><p>RET指令后跳转到ADD ESP,8，<br>栈顶向下偏移8，就恢复了栈顶最初的位置<br><img src="https://upload-images.jianshu.io/upload_images/422094-7131ab06163fca8b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/422094-a0bd1b19aa609920.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>在这个例子中，在函数调用的外面，恢复原始的堆栈的初始状态（堆栈平衡），这就是外平衡了</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>分析完内存堆栈变化，我们大概知道这个函数的功能就是计算两个数的加法，并且知道它时怎么加的。这就是逆向。</p>]]></content>
      
      
      <categories>
          
          <category> 滴水逆向三期视频教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滴水逆向 </tag>
            
            <tag> 汇编 </tag>
            
            <tag> 堆栈图 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JCC（比较指令）为堆栈图做准备</title>
      <link href="/2019/03/17/study-%E7%BC%96%E7%A8%8B%E8%BE%BE%E4%BA%BA-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%913%E6%9C%9F%E5%AD%A6%E4%B9%A0-2019-03-17-JCC%EF%BC%88%E6%AF%94%E8%BE%83%E6%8C%87%E4%BB%A4%EF%BC%89%E4%B8%BA%E5%AF%B9%E6%88%98%E5%9B%BE%E5%81%9A%E5%87%86%E5%A4%87/"/>
      <url>/2019/03/17/study-%E7%BC%96%E7%A8%8B%E8%BE%BE%E4%BA%BA-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%913%E6%9C%9F%E5%AD%A6%E4%B9%A0-2019-03-17-JCC%EF%BC%88%E6%AF%94%E8%BE%83%E6%8C%87%E4%BB%A4%EF%BC%89%E4%B8%BA%E5%AF%B9%E6%88%98%E5%9B%BE%E5%81%9A%E5%87%86%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<p>一说比较指令，我们就会想到编程语言中的逻辑判断（if）</p><h1 id="CMP指令"><a href="#CMP指令" class="headerlink" title="CMP指令"></a>CMP指令</h1><p>（想象下compare就好理解了）<br><img src="https://upload-images.jianshu.io/upload_images/422094-281fc380e591c62e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CMP指令常用表达式"><br>sub指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax ,100</span><br><span class="line">mov ecx,100</span><br><span class="line">sub eax,ecx</span><br></pre></td></tr></table></figure></p><p>执行之后，我们会发现<code>标志寄存器zf位变成了1</code>，eax变成了<code>0</code></p><p>cmp指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax ,100</span><br><span class="line">mov ecx,100</span><br><span class="line">cmp eax,ecx</span><br></pre></td></tr></table></figure></p><p>标志寄存器<code>z</code>f位和sub指令一样变成了1，但是<code>eax</code>并没有变化。<br>这才是真正的比较嘛</p><blockquote><p>z位=1 =&gt; 相等<br>s位=0  =&gt; 第一个数大于第二个数<br>s位=1  =&gt; 第一个数小于第二个数</p></blockquote><blockquote><p>cmp指令也能够直接比较寄存器和内存，但是必须确保两者的数据宽度相等。</p></blockquote><h1 id="TEST指令"><a href="#TEST指令" class="headerlink" title="TEST指令"></a>TEST指令</h1><p><img src="https://upload-images.jianshu.io/upload_images/422094-2b8bd355faa7bd95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>最后影响的标志寄存器还是<code>zf位</code>,比如检测EAX，如果EAX的位都是0，则zf位就会是1</p><h1 id="跳转决定"><a href="#跳转决定" class="headerlink" title="跳转决定"></a>跳转决定</h1><p><img src="https://upload-images.jianshu.io/upload_images/422094-d7155e65018af5d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>辅助理解的单词<br>J:JMP指令<br>N：not<br>E：equal</p><p>这些指令都是跳转指令，只是后面加了条件，标志寄存器中的值符合要求时才会进行跳转。</p>]]></content>
      
      
      <categories>
          
          <category> 滴水逆向三期视频教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滴水逆向 </tag>
            
            <tag> 汇编 </tag>
            
            <tag> 堆栈图 </tag>
            
            <tag> 比较指令 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JCC（修改EIP）为堆栈图做准备</title>
      <link href="/2019/03/17/study-%E7%BC%96%E7%A8%8B%E8%BE%BE%E4%BA%BA-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%913%E6%9C%9F%E5%AD%A6%E4%B9%A0-2019-03-17-JCC%EF%BC%88%E4%BF%AE%E6%94%B9EIP%EF%BC%89%E4%B8%BA%E5%A0%86%E6%A0%88%E5%9B%BE%E5%81%9A%E5%87%86%E5%A4%87/"/>
      <url>/2019/03/17/study-%E7%BC%96%E7%A8%8B%E8%BE%BE%E4%BA%BA-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%913%E6%9C%9F%E5%AD%A6%E4%B9%A0-2019-03-17-JCC%EF%BC%88%E4%BF%AE%E6%94%B9EIP%EF%BC%89%E4%B8%BA%E5%A0%86%E6%A0%88%E5%9B%BE%E5%81%9A%E5%87%86%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<h1 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h1><p>DTDEBUG中，我们可以设置断点，让程序指令一条一条的执行。<br>加断点的方式：点中需要打断点的位置，然后摁<code>F2</code> 就可以了。取消断点的话，也是同样的操作。</p><h1 id="JMP修改EIP的值"><a href="#JMP修改EIP的值" class="headerlink" title="JMP修改EIP的值"></a>JMP修改EIP的值</h1><p><img src="https://upload-images.jianshu.io/upload_images/422094-320cffd773601d7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>我们打开一个exe文件，就可以看出EIP中存储的值就是程序当前的执行位置。<br>如果想修改EIP的值该怎么办？<br><code>mov EIP 0x49F722</code><br><img src="https://upload-images.jianshu.io/upload_images/422094-9184c0d4793f4808.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="插入指令时，就提示我们不合法"></p><p>这时候JMP就派上用场了。<br><img src="https://upload-images.jianshu.io/upload_images/422094-e0f874b0da49f79a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>首先输入指令<code>JMP 0x49F722</code>,软件根据我们“跳跃”的跨度大小给添加一些多余的参数，比如<code>SHORT</code><br>再给<code>0x49F722</code>加个断点<br><img src="https://upload-images.jianshu.io/upload_images/422094-f8b036b1161068e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>为了便于测试，我们把无关的寄存器的值都修改一下。<br>注意看ESP、EBP的变化，重点观察EIP。</p><p>F8执行，<br><img src="https://upload-images.jianshu.io/upload_images/422094-952cb17a8764411c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>会发现只有EIP中的值变成了<code>0x49F722</code>，其他的值都没有变。<br>说明JMP指令达到了修改EIP中值的效果。</p><blockquote><p>补充：<br>1、jmp不是跳转，jmp只是修改了EIP的值，时CPU按照EIP中的值执行，CPU跳转了。<br>2、 JMP后面跟寄存器也是可以的。</p></blockquote><h1 id="call"><a href="#call" class="headerlink" title="call"></a>call</h1><p>call 是重点，后面堆栈图部分重点<br>我们构造这样的起始<br><img src="https://upload-images.jianshu.io/upload_images/422094-a410651a1978222c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>主要此时<br>EIP：0x0049f718<br>ESP:0019FF74<br>程序执行位置：0x0049F718<br>call 位置：0x0049F739</p><p>执行<br><img src="https://upload-images.jianshu.io/upload_images/422094-b5486d2a66e9faf2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p>两个位置都变了<br>1、EIP中变成了0x0049F739,这和刚才jmp的效果时相同的<br>2、ESP中的值也变了</p></blockquote><p>ESP不是堆栈吗？怎么也变了。<br>说明调用call的时候，往堆栈中压入东西了。<br>压入的是什么东西？<br>观察发现，是call指令的后一条指令的地址。这里可不是简单的+4哦，是call指令的地址+这条指令的长度。<br>为什么要把它压入堆栈中？<br>因为call指令一会还是要回去的。</p><h1 id="ret指令"><a href="#ret指令" class="headerlink" title="ret指令"></a>ret指令</h1><p>ret指令往往和call指令是同时出现的。</p><blockquote><p>call指令就相当于出去旅游，ret指令就是回来了<br>这么比喻的话，jmp指令就像老和尚云游去了，再也不回来了</p></blockquote><p>还是刚才的程序，我们再call跳转之后的位置加一个<code>ret</code>指令。<br><img src="https://upload-images.jianshu.io/upload_images/422094-efaef40f3a4c795f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>执行：<br><img src="https://upload-images.jianshu.io/upload_images/422094-73d14b702e679c10.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>堆栈也变化了，因为出栈了。<br>EIP中值也变了，指向了刚才call指令的下一个地址了。</p>]]></content>
      
      
      <categories>
          
          <category> 滴水逆向三期视频教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滴水逆向 </tag>
            
            <tag> 汇编 </tag>
            
            <tag> 修改EIP </tag>
            
            <tag> 堆栈图 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>golang开发HTTP，一篇文章就够了</title>
      <link href="/2019/03/14/golang-2019-03-14-golang%E5%BC%80%E5%8F%91HTTP%EF%BC%8C%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86/"/>
      <url>/2019/03/14/golang-2019-03-14-golang%E5%BC%80%E5%8F%91HTTP%EF%BC%8C%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<h1 id="创建HTTP服务"><a href="#创建HTTP服务" class="headerlink" title="创建HTTP服务"></a>创建HTTP服务</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> err := http.ListenAndServe(<span class="string">":12345"</span>,<span class="literal">nil</span>); err != <span class="literal">nil</span>&#123;</span><br><span class="line">        fmt.Println(<span class="string">"start http server fail:"</span>,err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有添加业务逻辑，所有访问都会 404 page not found</p><h1 id="添加-http-Handler"><a href="#添加-http-Handler" class="headerlink" title="添加 http.Handler"></a>添加 http.Handler</h1><p>就是添加页面业务处理<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter,r *http.Request)</span></span> &#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"hello world"</span>))</span><br><span class="line">&#125;)</span><br><span class="line">http.HandleFunc(<span class="string">"/abc"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter,r *http.Request)</span></span> &#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"hello world ,abc"</span>))</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err := http.ListenAndServe(<span class="string">":12345"</span>, <span class="literal">nil</span>);err != <span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"start http server faild:"</span>,err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>golang自带的路由功能比较弱<br>上面的代码除了请求路劲<code>/abc</code> 会匹配到第二个handler，其他的都匹配到了第一个<code>/</code><br>所以我们需要自己实现一个路由<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyHandler <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mh MyHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter,r *http.Request)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> r.URL.Path ==<span class="string">"/hello"</span>&#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"hello page"</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="comment">//这里的return是要加的，不然下面的代码也会执行了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> r.URL.Path == <span class="string">"/world"</span>&#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"world page"</span>))</span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line">&#125;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"root page"</span>))</span><br><span class="line"><span class="comment">// 可以继续写自己的路由匹配规则</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">http.Handle(<span class="string">"/"</span>, MyHandler&#123;&#125;)  <span class="comment">//note： 这里不是刚才的http.HandleFunc()了</span></span><br><span class="line"><span class="keyword">if</span> err := http.ListenAndServe(<span class="string">":12345"</span>, <span class="literal">nil</span>);err != <span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"start http server faild:"</span>,err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或者可以更简单一些<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := http.ListenAndServe(<span class="string">":12345"</span>, MyHandler&#123;&#125;);err != <span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"start http server faild:"</span>,err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="http-ServeMux-路由"><a href="#http-ServeMux-路由" class="headerlink" title="http.ServeMux 路由"></a>http.ServeMux 路由</h1><p>golang的<code>net/http</code>包给我们提供了一个路由<code>ServeMux</code>,h上面的方法<code>http.HandleFunc()</code>和<code>http.Handle()</code> 其实就是把路由规则注册到了默认的<code>ServeMux</code>上了，就是DefaultServeMux。我们可以看看源码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// DefaultServeMux is the default ServeMux used by Serve.</span></span><br><span class="line"><span class="keyword">var</span> DefaultServeMux = &amp;defaultServeMux</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> defaultServeMux ServeMux</span><br></pre></td></tr></table></figure></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle registers the handler for the given pattern</span></span><br><span class="line"><span class="comment">// in the DefaultServeMux.</span></span><br><span class="line"><span class="comment">// The documentation for ServeMux explains how patterns are matched.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handle</span><span class="params">(pattern <span class="keyword">string</span>, handler Handler)</span></span> &#123; DefaultServeMux.Handle(pattern, handler) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HandleFunc registers the handler function for the given pattern</span></span><br><span class="line"><span class="comment">// in the DefaultServeMux.</span></span><br><span class="line"><span class="comment">// The documentation for ServeMux explains how patterns are matched.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自己写一个ServeMux"><a href="#自己写一个ServeMux" class="headerlink" title="自己写一个ServeMux"></a>自己写一个ServeMux</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testhandler</span><span class="params">(w http.ResponseWriter,r *http.Request)</span></span>&#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"this is the ServeMux handler"</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">mux := http.NewServeMux()</span><br><span class="line">mux.HandleFunc(<span class="string">"/"</span>, testhandler)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := http.ListenAndServe(<span class="string">":12345"</span>, mux);err != <span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"start http server faild:"</span>,err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是由于golang自带的ServerMux路由规则过于简单，实践中一般都不会用。<br>推荐：<a href="https://github.com/gorilla/mux" target="_blank" rel="noopener">https://github.com/gorilla/mux</a></p><h1 id="http-Handler-http-HandlerFunc-中间件"><a href="#http-Handler-http-HandlerFunc-中间件" class="headerlink" title="http.Handler/http.HandlerFunc 中间件"></a>http.Handler/http.HandlerFunc 中间件</h1><p>golang的http处理过程不止一个http.handlerFunc,而是一组http.handleFunc<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler1</span><span class="params">(w http.ResponseWriter,r *http.Request)</span></span>&#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"handler1"</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler2</span><span class="params">(w http.ResponseWriter,r *http.Request)</span></span>&#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"handler2"</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeHandler</span><span class="params">(handlers ...http.HandlerFunc)</span><span class="title">http</span>.<span class="title">HandlerFunc</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter,r *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _,hander := <span class="keyword">range</span> handlers&#123;</span><br><span class="line">hander(w,r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">mux := http.NewServeMux()</span><br><span class="line">mux.HandleFunc(<span class="string">"/"</span>, makeHandler(handler1,handler2))</span><br><span class="line"><span class="keyword">if</span> err := http.ListenAndServe(<span class="string">":12345"</span>, mux);err != <span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"start http server faild:"</span>,err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们访问 <code>http://localhost:12345/</code>,就会看到 handler1和handler2都打印出来了。</p><p>框架<a href="https://github.com/urfave/negroni" target="_blank" rel="noopener">https://github.com/urfave/negroni</a> 基本上就是这种模式。</p><h1 id="request"><a href="#request" class="headerlink" title="request"></a>request</h1><p>一个http请求主要是客户端发过来的 <code>*http.Request</code> ，和返回给客户端的<code>http.reponseWriter</code><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handlerFunc</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>&#123;</span><br><span class="line">fmt.Println(r.Method) <span class="comment">//GET</span></span><br><span class="line">fmt.Println(r.URL) <span class="comment">///abc</span></span><br><span class="line">fmt.Println(r.URL.Path) <span class="comment">//abc</span></span><br><span class="line">fmt.Println(r.RemoteAddr) <span class="comment">//[::1]:62639</span></span><br><span class="line">fmt.Println(r.UserAgent()) <span class="comment">//Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.121 Safari/537.36</span></span><br><span class="line">fmt.Println(r.Header.Get(<span class="string">"Accept"</span>)) <span class="comment">//text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</span></span><br><span class="line">fmt.Println(r.Cookies()) <span class="comment">//[_ga=GA1.1.668973879.1547800734]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">mux := http.NewServeMux()</span><br><span class="line">mux.HandleFunc(<span class="string">"/"</span>, handlerFunc)</span><br><span class="line"><span class="keyword">if</span> err := http.ListenAndServe(<span class="string">":12345"</span>, mux);err != <span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"start http server faild:"</span>,err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>更过信息可查看官方文档</p><h1 id="表单数据"><a href="#表单数据" class="headerlink" title="表单数据"></a>表单数据</h1><p>（测试可以用postman测试）<br>请求传递的表单数据，存储在<code>*http.Request.Form</code> 和 <code>*http.Request.PostForm</code>中</p><h2 id="get请求"><a href="#get请求" class="headerlink" title="get请求"></a>get请求</h2><p><code>Get /?name=xuxiaofeng</code>,获取请求内容并打印到返回内容<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handlerFunc</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>&#123;</span><br><span class="line">name := r.FormValue(<span class="string">"name"</span>)</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(name))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">mux := http.NewServeMux()</span><br><span class="line">mux.HandleFunc(<span class="string">"/"</span>, handlerFunc)</span><br><span class="line"><span class="keyword">if</span> err := http.ListenAndServe(<span class="string">":12345"</span>, mux);err != <span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"start http server faild:"</span>,err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>http://localhost:12345/?name=xuxiaofeng</code>,就可以看到打印的内容</p><h2 id="post表单请求"><a href="#post表单请求" class="headerlink" title="post表单请求"></a>post表单请求</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handlerFunc</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>&#123;</span><br><span class="line">name1 := r.FormValue(<span class="string">"name"</span>)  <span class="comment">//FormValue(),如果name存在，也是获取第一个值【查源码就知道了】</span></span><br><span class="line">name2 := r.PostFormValue(<span class="string">"name"</span>) <span class="comment">// PostFormValue()也是同理，name存在是，也是获取第一个值</span></span><br><span class="line">name3 := r.Form.Get(<span class="string">"name"</span>)</span><br><span class="line">name4 := r.PostForm.Get(<span class="string">"name"</span>)</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(name1+name2+name3+name4))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">mux := http.NewServeMux()</span><br><span class="line">mux.HandleFunc(<span class="string">"/"</span>, handlerFunc)</span><br><span class="line"><span class="keyword">if</span> err := http.ListenAndServe(<span class="string">":12345"</span>, mux);err != <span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"start http server faild:"</span>,err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的四个值是相同的,但仅限于是post请求的情况下<br>如果我们这样请求<code>http://localhost:12345/?name=abc</code>,那<code>r.PostFromValue()</code> 和 <code>r.PostForm.Get(&quot;name&quot;)</code>都获取不到数据，带post的都获取不到数据。</p><h2 id="直接操作r-Form和r-PostForm"><a href="#直接操作r-Form和r-PostForm" class="headerlink" title="直接操作r.Form和r.PostForm"></a>直接操作r.Form和r.PostForm</h2><p>如果我们想直接操作r.Form<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handlerFunc</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>&#123;</span><br><span class="line">fmt.Println(r.Form[<span class="string">"name"</span>])</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"over"</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">mux := http.NewServeMux()</span><br><span class="line">mux.HandleFunc(<span class="string">"/"</span>, handlerFunc)</span><br><span class="line"><span class="keyword">if</span> err := http.ListenAndServe(<span class="string">":12345"</span>, mux);err != <span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"start http server faild:"</span>,err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们会发现，<code>fmt.Println(r.Form[&quot;name&quot;])</code>打印不出东西。看下面<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handlerFunc</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>&#123;</span><br><span class="line"><span class="comment">// 这里一定要记得 ParseForm，否则 r.Form 是空的</span></span><br><span class="line">    <span class="comment">// 调用 r.FormValue() 的时候会自动执行 r.ParseForm()</span></span><br><span class="line">r.ParseForm()</span><br><span class="line">fmt.Println(r.Form) <span class="comment">// map[name:[abc] age:[13]]</span></span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"over"</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">mux := http.NewServeMux()</span><br><span class="line">mux.HandleFunc(<span class="string">"/"</span>, handlerFunc)</span><br><span class="line"><span class="keyword">if</span> err := http.ListenAndServe(<span class="string">":12345"</span>, mux);err != <span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"start http server faild:"</span>,err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>表单数据存储在 r.Form，是 map[string][]string 类型，即支持一个表单域多个值的情况。r.FormValue() 只获取第一个值</p><h2 id="表单数据-lt-gt-结构体"><a href="#表单数据-lt-gt-结构体" class="headerlink" title="表单数据&lt;&gt;结构体"></a>表单数据&lt;&gt;结构体</h2><p>表单数据是简单的 kv 对应，很容易实现 kv 到 结构体的一一对应<br>这个库 <a href="https://github.com/mholt/binding" target="_blank" rel="noopener">https://github.com/mholt/binding</a> 就是干这个的<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id   <span class="keyword">int</span></span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span> <span class="title">FieldMap</span><span class="params">(req *http.Request)</span> <span class="title">binding</span>.<span class="title">FieldMap</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> binding.FieldMap&#123;</span><br><span class="line">        &amp;u.Id: <span class="string">"user_id"</span>,</span><br><span class="line">        &amp;u.Name: binding.Field&#123;</span><br><span class="line">            Form:     <span class="string">"name"</span>,</span><br><span class="line">            Required: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    user := <span class="built_in">new</span>(User)</span><br><span class="line">    errs := binding.Bind(r, user)</span><br><span class="line">    <span class="keyword">if</span> errs.Handle(w) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="body消息体"><a href="#body消息体" class="headerlink" title="body消息体"></a>body消息体</h1><blockquote><p>无论表单数据，还是上传的二进制数据，都是保存在 HTTP 的 Body 中的。操作 <em>http.Request.Body 可以获取到内容。但是注意 </em>http.Request.Body 是 io.ReadCloser 类型，只能一次性读取完整，<strong>第二次就是空的</strong>。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">httpHandler</span><span class="params">(w http.ResponseWriter,r *http.Request)</span></span>&#123;</span><br><span class="line">body,err := ioutil.ReadAll(r.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"read body error"</span>,err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(body))</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"receive request:"</span>))</span><br><span class="line">w.Write(body)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">mux := http.NewServeMux()</span><br><span class="line">mux.HandleFunc(<span class="string">"/"</span>, httpHandler)</span><br><span class="line"><span class="keyword">if</span> err := http.ListenAndServe(<span class="string">":12345"</span>, mux);err != <span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"start http server faild:"</span>,err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>根据HTTP协议，如果请求的<code>Content-Type: application/x-www-form-urlencoded</code>,body 中的数据就是类似 abc=123&amp;abc=abc&amp;abc=xyz 格式的数据，也就是常规的 表单数据。这些使用 r.ParseForm() 然后操作 r.Form 处理数据。如果是纯数据，比如文本abcdefg 、 JSON 数据等，你才需要直接操作 Body 的。比如接收 JSON 数据：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">Age  <span class="keyword">int</span>    <span class="string">`json:"age"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">httpHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">body, err := ioutil.ReadAll(r.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Panicf(<span class="string">"read body failed:%v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> u User</span><br><span class="line">json.Unmarshal(body, &amp;u)</span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, u)</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"receive data:"</span>))</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="keyword">string</span>(body)))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">mux := http.NewServeMux()</span><br><span class="line">mux.HandleFunc(<span class="string">"/"</span>, httpHandler)</span><br><span class="line"><span class="keyword">if</span> err := http.ListenAndServe(<span class="string">":12345"</span>, mux); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"start http server faild:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h1><p>上传的文件经过 Go 的解析保存在 *http.Request.MultipartForm 中,通过 r.FormFile() 去获取收到的文件信息和数据流，并处理：<br>服务端文件<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">httpHandlerFunc</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"><span class="comment">// 这里一定要记得 r.ParseMultipartForm(), 否则 r.MultipartForm 是空的</span></span><br><span class="line"><span class="comment">// 调用 r.FormFile() 的时候会自动执行 r.ParseMultipartForm()</span></span><br><span class="line">err := r.ParseMultipartForm(<span class="number">32</span> &lt;&lt; <span class="number">20</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"ParseMultipartForm error:%v"</span>, err)</span><br><span class="line">w.WriteHeader(<span class="number">500</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写明缓冲的大小。如果超过缓冲，文件内容会被放在临时目录中，而不是内存。过大可能较多占用内存，过小可能增加硬盘 I/O</span></span><br><span class="line"><span class="comment">// FormFile() 时调用 ParseMultipartForm() 使用的大小是 32 &lt;&lt; 20，32MB</span></span><br><span class="line">srcfile, srcfileheader, err := r.FormFile(<span class="string">"file"</span>) <span class="comment">// file 是上传表单域的名字</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"get upload file fail:"</span>, err)</span><br><span class="line">w.WriteHeader(<span class="number">500</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> srcfile.Close() <span class="comment">// 此时上传内容的 IO 已经打开，需要手动关闭！！</span></span><br><span class="line"><span class="comment">// fileHeader 有一些文件的基本信息</span></span><br><span class="line">fmt.Println(srcfileheader.Header.Get(<span class="string">"Content-Type"</span>))</span><br><span class="line"><span class="comment">// / 打开目标地址，把上传的内容存进去</span></span><br><span class="line">dstfile, err := os.OpenFile(<span class="string">"./test.jpg"</span>, os.O_CREATE|os.O_RDWR|os.O_TRUNC, <span class="number">0666</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"save upload file fail:"</span>, err)</span><br><span class="line">w.WriteHeader(<span class="number">500</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">_, err = io.Copy(dstfile, srcfile)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"copy to dstfile error:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"上传文件完成"</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">mux := http.NewServeMux()</span><br><span class="line">mux.HandleFunc(<span class="string">"/"</span>, httpHandlerFunc)</span><br><span class="line">http.ListenAndServe(<span class="string">":12345"</span>, mux)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用postman发现不能测试上传文件，就有golang写了一个上传文件的客户端<br>教程看这里：<a href="https://matt.aimonetti.net/posts/2013/07/01/golang-multipart-file-upload-example/" target="_blank" rel="noopener">https://matt.aimonetti.net/posts/2013/07/01/golang-multipart-file-upload-example/</a><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newUploadFileRequest</span><span class="params">(uri <span class="keyword">string</span>, params <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, paramName, path <span class="keyword">string</span>)</span> <span class="params">(*http.Request, error)</span></span> &#123;</span><br><span class="line">srcfile, err := os.Open(path)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> srcfile.Close()</span><br><span class="line">body := &amp;bytes.Buffer&#123;&#125;</span><br><span class="line">writer := multipart.NewWriter(body) <span class="comment">// writing to body</span></span><br><span class="line">part, err := writer.CreateFormFile(paramName, filepath.Base(path))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">io.Copy(part, srcfile)</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> params &#123;</span><br><span class="line">writer.WriteField(k, v)</span><br><span class="line">&#125;</span><br><span class="line">err = writer.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">req, err := http.NewRequest(<span class="string">"POST"</span>, uri, body)</span><br><span class="line">req.Header.Set(<span class="string">"Content-Type"</span>, writer.FormDataContentType())</span><br><span class="line"><span class="keyword">return</span> req, <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//path,_ := os.Getwd()</span></span><br><span class="line"><span class="comment">//path += "test.png"</span></span><br><span class="line">extraParams := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"title"</span>:       <span class="string">"My Document"</span>,</span><br><span class="line"><span class="string">"author"</span>:      <span class="string">"Matt Aimonetti"</span>,</span><br><span class="line"><span class="string">"description"</span>: <span class="string">"a picture for test file upload"</span>,</span><br><span class="line">&#125;</span><br><span class="line">request, err := newUploadFileRequest(<span class="string">"http://localhost:12345"</span>, extraParams, <span class="string">"file"</span>, <span class="string">"./111.jpg"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">client := &amp;http.Client&#123;&#125;</span><br><span class="line">resp, err := client.Do(request)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">body := &amp;bytes.Buffer&#123;&#125;</span><br><span class="line">_, err := body.ReadFrom(resp.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">resp.Body.Close()</span><br><span class="line">fmt.Println(resp.StatusCode)</span><br><span class="line">fmt.Println(resp.Header)</span><br><span class="line">fmt.Println(body)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上传之后就会发现根目录下多了个<code>test.jpg</code>文件，打开一看就是我们刚才上传的那个图片。</p><h2 id="上传多个文件"><a href="#上传多个文件" class="headerlink" title="上传多个文件"></a>上传多个文件</h2><p>上面的例子中，<code>r.FromFile(&quot;file&quot;)</code>只能获取单个文件（也就是第一个文件），如果想要获取多个文件就需要直接操作<code>r.MultipartForm</code>了。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">httpHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">r.ParseMultipartForm(<span class="number">32</span> &lt;&lt; <span class="number">20</span>)</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="keyword">var</span> file multipart.File</span><br><span class="line"><span class="keyword">for</span> _, fileheader := <span class="keyword">range</span> r.MultipartForm.File[<span class="string">"file"</span>] &#123;</span><br><span class="line"><span class="keyword">if</span> file, err := fileheader.Open(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"open file error:"</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">SaveFile(file) <span class="comment">// 仿照上面单个文件的操作，保存 file</span></span><br><span class="line">file.Close()   <span class="comment">// 操作结束一定要 Close，for 循环里不要用 defer file.Close()</span></span><br><span class="line">file = <span class="literal">nil</span></span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"save:"</span> + fileheader.Filename))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">mux := http.NewServeMux()</span><br><span class="line">mux.HandleFunc(<span class="string">"/"</span>, httpHandler)</span><br><span class="line"><span class="keyword">if</span> err := http.ListenAndServe(<span class="string">":12345"</span>, mux); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"start http server faild:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="responseWriter"><a href="#responseWriter" class="headerlink" title="responseWriter"></a>responseWriter</h1><p>http.ResponseWriter 是一个接口，你可以根据接口，添加一些自己需要的行为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type ResponseWriter interface &#123;</span><br><span class="line">    Header() Header // 添加返回头信息</span><br><span class="line">    Write([]byte) (int, error) // 添加返回的内容</span><br><span class="line">    WriteHeader(int) // 设置返回的状态码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>w.WriteHeader() 是一次性的，不能重复设置状态码，否则会有提示信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func HttpHandle(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">    w.WriteHeader(200) // 设置成功</span><br><span class="line">    w.WriteHeader(404) // 提示：http: multiple response.WriteHeader calls </span><br><span class="line">    w.WriteHeader(503) // 提示：http: multiple response.WriteHeader calls </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而且需要在 w.Write() 之前设置 w.WriteHeader()，否则是 200。（要先发送状态码，再发送内容）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func HttpHandle(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">    w.Write([]byte(&quot;Hello World&quot;))</span><br><span class="line">    w.WriteHeader(404) // 提示：http: multiple response.WriteHeader calls，因为 w.Write() 已发布 HTTP 200</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>http.ResponseWriter 接口过于简单，实际使用会自己实现 ResponseWriter 来使用，比如获取返回的内容：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyResponseWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">http.ResponseWriter</span><br><span class="line">bodyBytes *bytes.Buffer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆写 http.ResponseWriter 的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mrw MyResponseWriter)</span> <span class="title">Write</span><span class="params">(body []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">mrw.bodyBytes.Write(body)             <span class="comment">// 记录下返回的内容</span></span><br><span class="line"><span class="keyword">return</span> mrw.ResponseWriter.Write(body) <span class="comment">// 这里才是http真正的返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Body 获取记录的返回的内容，这个是自己添加的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mrw MyResponseWriter)</span> <span class="title">Body</span><span class="params">()</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> mrw.bodyBytes.Bytes()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">httpHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">mrw := MyResponseWriter&#123;</span><br><span class="line">ResponseWriter: w,</span><br><span class="line">bodyBytes:      bytes.NewBuffer(<span class="literal">nil</span>),</span><br><span class="line">&#125;</span><br><span class="line">mrw.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"text/html"</span>) <span class="comment">// 要输出HTML记得加头信息</span></span><br><span class="line">mrw.Write([]<span class="keyword">byte</span>(<span class="string">"&lt;h1&gt;the game of power!&lt;/h1&gt;"</span>))</span><br><span class="line">mrw.Write([]<span class="keyword">byte</span>(<span class="string">"the server receive some data"</span>))</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(mrw.Body()))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">mux := http.NewServeMux()</span><br><span class="line">mux.HandleFunc(<span class="string">"/"</span>, httpHandler)</span><br><span class="line"><span class="keyword">if</span> err := http.ListenAndServe(<span class="string">":12345"</span>, mux); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"start http server faild:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="输出其他内容"><a href="#输出其他内容" class="headerlink" title="输出其他内容"></a>输出其他内容</h1><p><code>net/http</code> 提供一些便利的方法可以输出其他的内容，比如 cookie:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func HttpHandle(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">    c := &amp;http.Cookie&#123;</span><br><span class="line">        Name:     &quot;abc&quot;,</span><br><span class="line">        Value:    &quot;xyz&quot;,</span><br><span class="line">        Expires:  time.Now().Add(1000 * time.Second),</span><br><span class="line">        MaxAge:   1000,</span><br><span class="line">        HttpOnly: true,</span><br><span class="line">    &#125;</span><br><span class="line">    http.SetCookie(w, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如服务端返回下载文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func HttpHandle(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">    http.ServeFile(w, r, &quot;download.txt&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或者是生成的数据流，比如验证码，当作文件返回：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func HttpHandle(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">    captchaImageBytes := createCaptcha() // 假设生成验证码的函数，返回 []byte</span><br><span class="line">    buf := bytes.NewReader(captchaImageBytes)</span><br><span class="line">    http.ServeContent(w, r, &quot;captcha.png&quot;, time.Now(), buf)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还有一些状态码的直接操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func HttpHandle(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">    http.Redirect(w, r, &quot;/abc&quot;, 302)</span><br><span class="line">&#125;</span><br><span class="line">func HttpHandle2(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">    http.NotFound(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>返回 JSON, XML 和 渲染模板的内容等的代码例子，可以参考 <a href="http://www.alexedwards.net/blog/golang-response-snippets" target="_blank" rel="noopener">HTTP Response Snippets for Go</a>。</p><h1 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h1><p>Go 1.7 添加了 context 包，用于传递数据和做超时、取消等处理。*http.Request 添加了 r.Context() 和 r.WithContext() 来操作请求过程需要的 context.Context 对象。</p><h2 id="传递数据"><a href="#传递数据" class="headerlink" title="传递数据"></a>传递数据</h2><p>context 可以在 http.HandleFunc 之间传递数据：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">httpHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">ctx := context.WithValue(r.Context(), <span class="string">"name"</span>, <span class="string">"权利的游戏"</span>) <span class="comment">// 写入 string 到 context</span></span><br><span class="line">handler2(w, r.WithContext(ctx))                        <span class="comment">// 传递给下一个 handleFunc</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler2</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">name, ok := r.Context().Value(<span class="string">"name"</span>).(<span class="keyword">string</span>) <span class="comment">// 取出的 interface 需要推断到 string</span></span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">name = <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"convert name:"</span> + name))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">mux := http.NewServeMux()</span><br><span class="line">mux.HandleFunc(<span class="string">"/"</span>, httpHandler)</span><br><span class="line"><span class="keyword">if</span> err := http.ListenAndServe(<span class="string">":12345"</span>, mux); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"start http server faild:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="处理超时的请求"><a href="#处理超时的请求" class="headerlink" title="处理超时的请求"></a>处理超时的请求</h2><p>利用 context.WithTimeout 可以创建会超时结束的 context，用来处理业务超时的情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">func HttpHandle(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">    ctx, cancelFn := context.WithTimeout(r.Context(), 1*time.Second)</span><br><span class="line"></span><br><span class="line">    // cancelFn 关掉 WithTimeout 里的计时器</span><br><span class="line">    // 如果 ctx 超时，计时器会自动关闭，但是如果没有超时就执行到 &lt;-resCh,就需要手动关掉</span><br><span class="line">    defer cancelFn()</span><br><span class="line"></span><br><span class="line">    // 把业务放到 goroutine 执行， resCh 获取结果</span><br><span class="line">    resCh := make(chan string, 1)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        // 故意写业务超时</span><br><span class="line">        time.Sleep(5 * time.Second)</span><br><span class="line">        resCh &lt;- r.FormValue(&quot;abc&quot;)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    // 看 ctx 超时还是 resCh 的结果先到达</span><br><span class="line">    select &#123;</span><br><span class="line">    case &lt;-ctx.Done():</span><br><span class="line">        w.WriteHeader(http.StatusGatewayTimeout)</span><br><span class="line">        w.Write([]byte(&quot;http handle is timeout:&quot; + ctx.Err().Error()))</span><br><span class="line">    case r := &lt;-resCh:</span><br><span class="line">        w.Write([]byte(&quot;get: abc = &quot; + r))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="带-context-的中间件"><a href="#带-context-的中间件" class="headerlink" title="带 context 的中间件"></a>带 context 的中间件</h2><p>Go 的很多 HTTP 框架使用 <code>context</code> 或者自己定义的 <code>Context</code> 结果作为 <code>http.Handler</code> 中间件之间数据传递的媒介，比如 <a href="https://github.com/rs/xhandler" target="_blank" rel="noopener">xhandler</a>:</p><h1 id="Hijack"><a href="#Hijack" class="headerlink" title="Hijack"></a>Hijack</h1><p>一些时候需要直接操作 Go 的 HTTP 连接时，使用 Hijack() 将 HTTP 对应的 TCP 取出。连接在 Hijack() 之后，HTTP 的相关操作会受到影响，连接的管理需要用户自己操作，而且例如 w.Write([]byte) 不会返回内容，需要操作 Hijack() 后的 *bufio.ReadWriter。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hiJackHandle</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">hj, ok := w.(http.Hijacker)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"the server do not support hijacker"</span>))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">conn, buf, err := hj.Hijack() <span class="comment">// 需要手动关闭连接</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Hijack error:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"继续用w返回内容"</span>)) <span class="comment">//error:http: response.Write on hijacked connection</span></span><br><span class="line"><span class="comment">// 返回内容需要</span></span><br><span class="line">buf.WriteString(<span class="string">"用buf返回的hello world"</span>)</span><br><span class="line">buf.Flush()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, hiJackHandle)</span><br><span class="line"><span class="keyword">if</span> err := http.ListenAndServe(<span class="string">":12345"</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"start http server faild:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>Hijack</code> 主要看到的用法是对 HTTP 的 Upgrade 时在用，比如从 HTTP 到 Websocket 时，<a href="https://github.com/golang/net/blob/master/websocket/server.go#L73" target="_blank" rel="noopener">golang.org/x/net/websocket</a>:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Server)</span> <span class="title">serveWebSocket</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">    rwc, buf, err := w.(http.Hijacker).Hijack()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"Hijack failed: "</span> + err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// The server should abort the WebSocket connection if it finds</span></span><br><span class="line">    <span class="comment">// the client did not send a handshake that matches with protocol</span></span><br><span class="line">    <span class="comment">// specification.</span></span><br><span class="line">    <span class="keyword">defer</span> rwc.Close()</span><br><span class="line">    conn, err := newServerConn(rwc, buf, req, &amp;s.Config, s.Handshake)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> conn == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"unexpected nil conn"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    s.Handler(conn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="http-Server-的使用细节"><a href="#http-Server-的使用细节" class="headerlink" title="http.Server 的使用细节"></a>http.Server 的使用细节</h1><p>上面所有的代码我都是用的 http.ListenAndServe 来启动 HTTP 服务。实际上执行这个过程的 <em>http.Server 这个结构。有些时候我们不是使用默认的行为，会给 </em>http.Server 定义更多的内容。</p><p>http.ListenAndServe 默认的 *http.Server 是没有超时设置的。一些场景下你必须设置超时，否则会遇到太多连接句柄的问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    server := &amp;http.Server&#123;</span><br><span class="line">        Handler:      MyHandler&#123;&#125;, // 使用实现 http.Handler 的结构处理 HTTP 数据</span><br><span class="line">        ReadTimeout:  10 * time.Second,</span><br><span class="line">        WriteTimeout: 10 * time.Second,</span><br><span class="line">    &#125;</span><br><span class="line">    // 监听 TCP 端口，把监听器交给 *http.Server 使用</span><br><span class="line">    ln, err := net.Listen(&quot;tcp&quot;, &quot;:12345&quot;)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        panic(&quot;listen :12345 fail:&quot; + err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    if err = server.Serve(ln); err != nil &#123;</span><br><span class="line">        fmt.Println(&quot;start http server fail:&quot;, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有朋友用 Beego 的时候希望同时监听两个端口提供一样数据操作的 HTTP 服务。这个需求就可以利用 *http.Server 来实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;net/http&quot;</span><br><span class="line"></span><br><span class="line">    &quot;github.com/astaxie/beego&quot;</span><br><span class="line">    &quot;github.com/astaxie/beego/context&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    beego.Get(&quot;/&quot;, func(ctx *context.Context) &#123;</span><br><span class="line">        ctx.WriteString(&quot;abc&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    go func() &#123; // server 的 ListenAndServe 是阻塞的，应该在另一个 goroutine 开启另一个server</span><br><span class="line">        server2 := &amp;http.Server&#123;</span><br><span class="line">            Handler: beego.BeeApp.Handlers, // 使用实现 http.Handler 的结构处理 HTTP 数据</span><br><span class="line">            Addr:    &quot;:54321&quot;,</span><br><span class="line">        &#125;</span><br><span class="line">        if err := server2.ListenAndServe(); err != nil &#123;</span><br><span class="line">            fmt.Println(&quot;start http server2 fail:&quot;, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    server1 := &amp;http.Server&#123;</span><br><span class="line">        Handler: beego.BeeApp.Handlers, // 使用实现 http.Handler 的结构处理 HTTP 数据</span><br><span class="line">        Addr:    &quot;:12345&quot;,</span><br><span class="line">    &#125;</span><br><span class="line">    if err := server1.ListenAndServe(); err != nil &#123;</span><br><span class="line">        fmt.Println(&quot;start http server1 fail:&quot;, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样访问 <a href="http://localhost:12345" target="_blank" rel="noopener">http://localhost:12345</a> 和 <a href="http://localhost:54321" target="_blank" rel="noopener">http://localhost:54321</a> 都可以看到返回 abc 的内容。</p><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>随着互联网安全的问题日益严重，许多的网站开始使用 HTTPS 提供服务。Go 创建一个 HTTPS 服务是很简便的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;net/http&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func handler(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">    fmt.Fprintf(w, &quot;Hello, HTTPS Server&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    http.HandleFunc(&quot;/&quot;, handler)</span><br><span class="line">    http.ListenAndServeTLS(&quot;:12345&quot;,</span><br><span class="line">        &quot;server.crt&quot;,</span><br><span class="line">        &quot;server.key&quot;, nil)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ListenAndServeTLS</code> 新增了两个参数 <code>certFile</code> 和 <code>keyFile</code>。HTTPS的数据传输是加密的。实际使用中，HTTPS利用的是对称与非对称加密算法结合的方式，需要加密用的公私密钥对进行加密，也就是 <code>server.crt</code> 和 <code>server.key</code> 文件。具体的生成可以阅读 <code>openssl</code> 的文档。</p><p>关于 Go 和 HTTPS 的内容，可以阅读 <strong>Tony Bai</strong> 的 <a href="http://tonybai.com/2015/04/30/go-and-https/" target="_blank" rel="noopener">Go 和 HTTPS</a>。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Go 的 <code>net/http</code> 包为开发者提供很多便利的方法的，可以直接开发不复杂的 Web 应用。如果需要复杂的路由功能，及更加集成和简便的 HTTP 操作，推荐使用一些 Web 框架。</p><p>各种 Web 框架 : <a href="https://github.com/avelino/awesome-go#web-frameworks" target="_blank" rel="noopener">awesome-go#web-frameworks</a></p><p>参考 <a href="http://fuxiaohei.me/2016/9/20/go-and-http-server.html" target="_blank" rel="noopener">http://fuxiaohei.me/2016/9/20/go-and-http-server.html</a></p><h1 id="另外参考"><a href="#另外参考" class="headerlink" title="另外参考"></a>另外参考</h1><h2 id="Server-Serve"><a href="#Server-Serve" class="headerlink" title="Server.Serve()"></a>Server.Serve()</h2><p>上面的文章中没有介绍这个用法<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">Serve</span><span class="params">(l net.Listener)</span> <span class="title">error</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>用法及其中原理可以参考：<a href="https://cizixs.com/2016/08/17/golang-http-server-side/" target="_blank" rel="noopener">https://cizixs.com/2016/08/17/golang-http-server-side/</a></p>]]></content>
      
      
      <categories>
          
          <category> golang学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>redis、nginx、postgresql日志系统</title>
      <link href="/2019/03/13/tools-2019-03-13-redis%E3%80%81nginx%E3%80%81postgresql%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/"/>
      <url>/2019/03/13/tools-2019-03-13-redis%E3%80%81nginx%E3%80%81postgresql%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>下面介绍的都是ubuntu16.04</p><h1 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h1><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@iZt4ndq9lezw03v80dtwykZ:/var/lib/redis# redis-server --version</span><br><span class="line">Redis server v=3.0.6 sha=00000000:0 malloc=jemalloc-3.6.0 bits=64 build=28b6715d3583bf8e</span><br></pre></td></tr></table></figure></p><p>在配置文件找到日志的相关配置<br><code>vim /etc/redis/redis.conf</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># warning (only very important / critical messages are logged)</span><br><span class="line">loglevel notice</span><br><span class="line"></span><br><span class="line"># Specify the log file name. Also the empty string can be used to force</span><br><span class="line"># Redis to log on the standard output. Note that if you use standard</span><br><span class="line"># output for logging but daemonize, logs will be sent to /dev/null</span><br><span class="line">logfile /var/log/redis/redis-server.log</span><br></pre></td></tr></table></figure></p><p>查看日志<br><code>tail -f /var/log/redis/redis-server.log</code></p><h2 id="持久化路径"><a href="#持久化路径" class="headerlink" title="持久化路径"></a>持久化路径</h2><p>在配置文件找到日志的相关配置<br><code>vim /etc/redis/redis.conf</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># The working directory.</span><br><span class="line">#</span><br><span class="line"># The DB will be written inside this directory, with the filename specified</span><br><span class="line"># above using the &apos;dbfilename&apos; configuration directive.</span><br><span class="line">#</span><br><span class="line"># The Append Only File will also be created inside this directory.</span><br><span class="line">#</span><br><span class="line"># Note that you must specify a directory here, not a file name.</span><br><span class="line">dir /var/lib/redis</span><br></pre></td></tr></table></figure></p><p>查看下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@iZt4ndq9lezw03v80dtwykZ:~# ll /var/lib/redis/</span><br><span class="line">total 12</span><br><span class="line">drwxr-x---  2 redis redis 4096 Mar 13 11:28 ./</span><br><span class="line">drwxr-xr-x 44 root  root  4096 Mar 10 02:39 ../</span><br><span class="line">-rw-rw----  1 redis redis  513 Mar 12 16:49 dump.rdb</span><br></pre></td></tr></table></figure></p><p>修改配置文件中<code>dir</code> 到自己指定的路径，然后移动<code>dump.rdb</code>到指定的路径内就可以了。</p>]]></content>
      
      
      <categories>
          
          <category> 日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> nginx </tag>
            
            <tag> postgresql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>go 运算符 ^</title>
      <link href="/2019/03/13/golang-2019-03-13-golang%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2019/03/13/golang-2019-03-13-golang%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="运算符"><a href="#运算符" class="headerlink" title="^运算符"></a>^运算符</h1><h2 id="作为二元运算符"><a href="#作为二元运算符" class="headerlink" title="作为二元运算符"></a>作为二元运算符</h2><p>^可以作为二元运算符，也可以作为一元运算符</p><p>^作二元运算符就是异或，相同为0，不相同为1</p><p>如1^1 =0, 0^0=0,1^0=1,0^1=1</p><p>0001 0100 ^ 0000 1111 = 0001 1011</p><p>故 20 ^ 15 =27</p><h2 id="作为一元运算符"><a href="#作为一元运算符" class="headerlink" title="作为一元运算符"></a>作为一元运算符</h2><p>^作一元运算符表示是按位取反</p><p>^0001 0100 = 1110 1011</p><p>故结果为235</p><p>请思想下面代码的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">     var    i  uint8  = 20</span><br><span class="line">     fmt.Println(^i,^20)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果是：235   -21</p><p>why?</p><p>其实原因很简单，一个是有符号的数一个是无符号的数<br>20在编译器中默认为int类型，故最高位是符号位，符号位取反，所以得到的结果是负数<br>串联理解：负数的二进制数怎么表示？<br>负数的二进制数是它对应的正数按位取反得到反码，再加上1得到的补码<br>例如：3的二进制为00000000 00000000 00000000 00000011<br>反码：            11111111 11111111 11111111 11111100<br>补码：反码加1：  11111111 11111111 11111111 11111101<br>故-3的二进制为11111111 11111111 11111111 11111101</p><p>所以，一个有符号位的^操作为 这个数+1的相反数 </p>]]></content>
      
      
      <categories>
          
          <category> golang学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 运算符 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>json-rpc</title>
      <link href="/2019/03/12/computer-network-2019-03-12-json-rpc%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/03/12/computer-network-2019-03-12-json-rpc%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h1><p>json-rpc 1.0 规范解读<br><a href="https://blog.csdn.net/KimmKing/article/details/43410253" target="_blank" rel="noopener">https://blog.csdn.net/KimmKing/article/details/43410253</a><br>(译) JSON-RPC 2.0 规范(中文版)<br><a href="http://wiki.geekdream.com/Specification/json-rpc_2.0.html" target="_blank" rel="noopener">http://wiki.geekdream.com/Specification/json-rpc_2.0.html</a></p><h2 id="1-0"><a href="#1-0" class="headerlink" title="1.0"></a>1.0</h2><p>请求<br><code>{ &quot;method&quot;: &quot;echo&quot;, &quot;params&quot;: [&quot;Hello JSON-RPC&quot;], &quot;id&quot;: 1}</code><br>响应<br><code>{ &quot;result&quot;: &quot;Hello JSON-RPC&quot;, &quot;error&quot;: null, &quot;id&quot;: 1}</code><br>多次通信的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--&gt; &#123;&quot;method&quot;: &quot;postMessage&quot;, &quot;params&quot;: [&quot;Hello all!&quot;], &quot;id&quot;: 99&#125;</span><br><span class="line">&lt;-- &#123;&quot;result&quot;: 1, &quot;error&quot;: null, &quot;id&quot;: 99&#125;</span><br><span class="line">&lt;-- &#123;&quot;method&quot;: &quot;handleMessage&quot;, &quot;params&quot;: [&quot;user1&quot;, &quot;we were just talking&quot;], &quot;id&quot;: null&#125;</span><br><span class="line">&lt;-- &#123;&quot;method&quot;: &quot;handleMessage&quot;, &quot;params&quot;: [&quot;user3&quot;, &quot;sorry, gotta go now, ttyl&quot;], &quot;id&quot;: null&#125;</span><br><span class="line">--&gt; &#123;&quot;method&quot;: &quot;postMessage&quot;, &quot;params&quot;: [&quot;I have a question:&quot;], &quot;id&quot;: 101&#125;</span><br><span class="line">&lt;-- &#123;&quot;method&quot;: &quot;userLeft&quot;, &quot;params&quot;: [&quot;user3&quot;], &quot;id&quot;: null&#125;</span><br><span class="line">&lt;-- &#123;&quot;result&quot;: 1, &quot;error&quot;: null, &quot;id&quot;: 101&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-0"><a href="#2-0" class="headerlink" title="2.0"></a>2.0</h2><p>rpc批量调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">--&gt; [</span><br><span class="line">    &#123;&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;sum&quot;, &quot;params&quot;: [1,2,4], &quot;id&quot;: &quot;1&quot;&#125;,</span><br><span class="line">    &#123;&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;notify_hello&quot;, &quot;params&quot;: [7]&#125;,</span><br><span class="line">    &#123;&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;subtract&quot;, &quot;params&quot;: [42,23], &quot;id&quot;: &quot;2&quot;&#125;,</span><br><span class="line">    &#123;&quot;foo&quot;: &quot;boo&quot;&#125;,</span><br><span class="line">    &#123;&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;foo.get&quot;, &quot;params&quot;: &#123;&quot;name&quot;: &quot;myself&quot;&#125;, &quot;id&quot;: &quot;5&quot;&#125;,</span><br><span class="line">    &#123;&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;get_data&quot;, &quot;id&quot;: &quot;9&quot;&#125;</span><br><span class="line">    ]</span><br><span class="line">&lt;-- [</span><br><span class="line">    &#123;&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;result&quot;: 7, &quot;id&quot;: &quot;1&quot;&#125;,</span><br><span class="line">    &#123;&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;result&quot;: 19, &quot;id&quot;: &quot;2&quot;&#125;,</span><br><span class="line">    &#123;&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;error&quot;: &#123;&quot;code&quot;: -32600, &quot;message&quot;: &quot;Invalid Request&quot;&#125;, &quot;id&quot;: null&#125;,</span><br><span class="line">    &#123;&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;error&quot;: &#123;&quot;code&quot;: -32601, &quot;message&quot;: &quot;Method not found&quot;&#125;, &quot;id&quot;: &quot;5&quot;&#125;,</span><br><span class="line">    &#123;&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;result&quot;: [&quot;hello&quot;, 5], &quot;id&quot;: &quot;9&quot;&#125;</span><br></pre></td></tr></table></figure></p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>json-rpc 1.0规范：通知必须将字段id设置为null。通知是不需要response的<br>json-rpc 2.0规范：通知request必须有<code>json-rpc</code>字段，并且没有id字段。<br>2.0 规定通知的话一定不要回复。<br>2.0规范容许id值设置为null，因此即使id为null，也不是一个通知。（通知直接就没有id，上面刚说了）</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1>]]></content>
      
      
      <categories>
          
          <category> 计算机网路 </category>
          
          <category> rpc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> json-rpc </tag>
            
            <tag> rpc </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>flutter常见问题总结</title>
      <link href="/2019/03/10/flutter-2019-03-09-flutter%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2019/03/10/flutter-2019-03-09-flutter%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="如何强制竖屏"><a href="#如何强制竖屏" class="headerlink" title="如何强制竖屏"></a>如何强制竖屏</h1><p>参考文章<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Run app</span><br><span class="line"> SystemChrome.setPreferredOrientations([DeviceOrientation.portraitUp]).then((_) &#123;</span><br><span class="line">   runApp(new StateContainer(child: new App()));</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flutter </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mysql数据库学习记录</title>
      <link href="/2019/03/09/database-2019-03-09-pg%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/03/09/database-2019-03-09-pg%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> students;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="number">100</span>+<span class="number">200</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> students <span class="keyword">where</span> score &gt;= <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> students <span class="keyword">where</span> score &gt;= <span class="number">80</span> <span class="keyword">and</span> gender = <span class="string">"M"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> students <span class="keyword">where</span> score &gt;= <span class="number">80</span> <span class="keyword">or</span> gender = <span class="string">"M"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> students <span class="keyword">where</span> <span class="keyword">not</span> class_id =<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> students <span class="keyword">where</span>  (score &lt;<span class="number">80</span> <span class="keyword">or</span> score &gt; <span class="number">90</span>) <span class="keyword">and</span> gender = <span class="string">"M"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#投影查询</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,class_id,score,<span class="keyword">name</span> <span class="keyword">from</span> students;</span><br><span class="line"></span><br><span class="line"><span class="comment">#排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span>,gender,score <span class="keyword">from</span> students <span class="keyword">order</span> <span class="keyword">by</span> score;  <span class="comment">#score由低到高</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span>,gender,score <span class="keyword">from</span> students <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#score有相同时，指定另外的列</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span>,gender,socre <span class="keyword">from</span> students <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>,gender;</span><br><span class="line"></span><br><span class="line"><span class="comment"># where + order by</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span>,gender,score <span class="keyword">from</span> students <span class="keyword">where</span> class_id =<span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分页查询 LIMIT &lt;M&gt; OFFSET &lt;N&gt;</span></span><br><span class="line"><span class="comment"># 结果集分页，每页三条记录</span></span><br><span class="line"><span class="comment"># offset 0:表示对结果集从0号记录开始</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span>,gender,socre <span class="keyword">from</span> students <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span> <span class="keyword">LIMIT</span> <span class="number">3</span> <span class="keyword">OFFSET</span> <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">#查询第二页</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span>,gender,score <span class="keyword">from</span> students <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span> <span class="keyword">LIMIT</span> <span class="number">3</span> <span class="keyword">OFFSET</span> <span class="number">3</span>;</span><br><span class="line"><span class="comment"># 查询第三页</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span>,gender,score <span class="keyword">from</span> students <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span> <span class="keyword">LIMIT</span> <span class="number">3</span> <span class="keyword">OFFSET</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------------</span></span><br><span class="line"><span class="comment"># 聚合查询</span></span><br><span class="line"><span class="comment"># 查询有多少行</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> students;</span><br><span class="line"><span class="comment">#等价于</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">id</span>) <span class="keyword">from</span> students;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他聚合函数 sum ,avg,max,min</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 男生的平均成绩</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">avg</span>(score) average <span class="keyword">from</span> students <span class="keyword">where</span> gender = <span class="string">"M"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分组聚合</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">num</span> <span class="keyword">from</span> students <span class="keyword">group</span> <span class="keyword">by</span> class_id ;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照class_id分组</span></span><br><span class="line"><span class="keyword">select</span> class_id,<span class="keyword">count</span>(*) <span class="keyword">num</span> <span class="keyword">from</span> students <span class="keyword">group</span> <span class="keyword">by</span> class_id;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多个列进行分组</span></span><br><span class="line"><span class="keyword">select</span> class_id,gender,<span class="keyword">count</span>(*) <span class="keyword">num</span> <span class="keyword">from</span> students <span class="keyword">group</span> <span class="keyword">by</span> class_id,gender;</span><br><span class="line"></span><br><span class="line"><span class="comment">#========================多表查询</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> students,classes;</span><br><span class="line">说明：</span><br><span class="line">students表的每一行与classes表的每一行都两两拼在一起返回。</span><br><span class="line">结果集的列数是students表和classes表的列数之和，行数是students表和classes表的行数之积。</span><br><span class="line">这种多表查询又称笛卡尔查询。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面查询的缺点，两张表中都有id列，都有name列</span></span><br><span class="line"><span class="keyword">select</span> students.id <span class="keyword">sid</span>,students.name sname,students.gender,students.score,classes.id cid,classes.name cname <span class="keyword">from</span> students,classes;</span><br><span class="line"></span><br><span class="line"><span class="comment">#看到上面我们students写得手疼</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    s.id <span class="keyword">sid</span>,</span><br><span class="line">    s.name,</span><br><span class="line">    s.gender,</span><br><span class="line">    s.score,</span><br><span class="line">    c.id cid,</span><br><span class="line">    c.name cname</span><br><span class="line"><span class="keyword">FROM</span> students s, classes c;</span><br><span class="line"></span><br><span class="line"><span class="comment">#====================多表查询使用where语句</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    s.id <span class="keyword">sid</span>,</span><br><span class="line">    s.name,</span><br><span class="line">    s.gender,</span><br><span class="line">    s.score,</span><br><span class="line">    c.id cid,</span><br><span class="line">    c.name cname</span><br><span class="line"><span class="keyword">FROM</span> students s, classes c</span><br><span class="line"><span class="keyword">WHERE</span> s.gender = <span class="string">'M'</span> <span class="keyword">AND</span> c.id = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># =================连接查询</span></span><br><span class="line">https://www.liaoxuefeng.com/wiki/001508284671805d39d23243d884b8b99f440bfae87b0f4000/001509167103179399448cb200549bdab7651a5e9167597000</span><br><span class="line">连接查询也是一种多表查询，连接查询对多个表进行join运算。</span><br><span class="line">简单来说，就是先确定一个主表作为结果集，然后把其他表的行有选择性地"连接"在主表结果集上。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有学生</span></span><br><span class="line"><span class="keyword">select</span> s.id,s.name,s.class_id,s.gender,s.score <span class="keyword">from</span> students s;</span><br><span class="line"></span><br><span class="line">我们希望结果集包含所在班级的名称，上面的只有`class_id`,没有班级的名称。</span><br><span class="line"><span class="comment"># 先使用内连接</span></span><br><span class="line"><span class="keyword">select</span> s.id,s.name,s.class_id,c.name class_name,s.gender,s.score </span><br><span class="line"><span class="keyword">from</span> students s</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> classes c</span><br><span class="line"><span class="keyword">on</span> s.class_id = c.id;</span><br><span class="line"></span><br><span class="line"><span class="comment"># inner join 查询的语法</span></span><br><span class="line">先确定主表，仍然使用FROM &lt;表1&gt;的语法；</span><br><span class="line">再确定需要连接的表，使用INNER JOIN &lt;表2&gt;的语法；</span><br><span class="line">然后确定连接条件，使用ON &lt;条件...&gt;，这里的条件是s.class_id = c.id，表示students表的class_id列与classes表的id列相同的行需要连接；</span><br><span class="line">可选：加上WHERE子句、ORDER BY等子句。</span><br></pre></td></tr></table></figure><p>有内连接有会有外连接，外连接分为<code>right outer join</code> 和 <code>left outer join</code>,<code>FULL OUTER JOIN</code>.</p><p>right outer join 会把右表中存在的行都返回，就可能会在结果集中出现一些行，来自左表中的数据全为NULL.<br>left outer join 会把左表中存在的行都返回.<br>FULL OUTER JOIN 会把两张表中存在的记录都选择出来，并且，自动把对方不存在的列填充为NULL。</p><p>几种连接方式最直观的方式，可以通过集合的关系直接表示出来。【可以点击上面的链接查看】</p>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> database </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>rust大纲</title>
      <link href="/2019/03/07/rust-2019-03-07-rust%E5%A4%A7%E7%BA%B2/"/>
      <url>/2019/03/07/rust-2019-03-07-rust%E5%A4%A7%E7%BA%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="使用结构体组织相关联的数据"><a href="#使用结构体组织相关联的数据" class="headerlink" title="使用结构体组织相关联的数据"></a>使用结构体组织相关联的数据</h1><h2 id="定义并实例化结构体"><a href="#定义并实例化结构体" class="headerlink" title="定义并实例化结构体"></a>定义并实例化结构体</h2><p>变量与字段名相同时的字段初始化简写语法<br>使用结构体更新语法从其他实例创建实例<br>使用没有命名字段的元组结构体来创建不同的类型<br>没有任何字段的类单元结构体<br>结构体数据所有权</p><h2 id="一个使用结构体的示例程序"><a href="#一个使用结构体的示例程序" class="headerlink" title="一个使用结构体的示例程序"></a>一个使用结构体的示例程序</h2><h2 id="方法语法"><a href="#方法语法" class="headerlink" title="方法语法"></a>方法语法</h2><p>定义方法<br>自动引用和解引用（automatic referencing and dereferencing）<br>关联函数（associated function）<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rec</span></span>&#123;</span><br><span class="line">    width:<span class="built_in">i32</span>,</span><br><span class="line">    height:<span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RecWithDebug</span></span> &#123;</span><br><span class="line">    width:<span class="built_in">i32</span>,</span><br><span class="line">    height:<span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RecWithMethod</span></span> &#123;</span><br><span class="line">    width:<span class="built_in">i32</span>,</span><br><span class="line">    height:<span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> RecWithMethod &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(&amp;<span class="keyword">self</span>)-&gt;<span class="built_in">i32</span>&#123;</span><br><span class="line">        <span class="keyword">self</span>.width*<span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 利用元组来实现面积</span></span><br><span class="line">    <span class="keyword">let</span> rec1 = (<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">let</span> res = area_tuple(rec1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>,res); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用结构体求面积</span></span><br><span class="line">    <span class="keyword">let</span> rec2 = Rec&#123;width:<span class="number">3</span>,height:<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>,area_struct(&amp;rec2));</span><br><span class="line">    <span class="comment">// println!("&#123;&#125;",rec2);  // error</span></span><br><span class="line">    <span class="comment">// println!("&#123;:?&#125;", rec2); // error</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可打印的结构体</span></span><br><span class="line">    <span class="keyword">let</span> rec3 = RecWithDebug&#123;height:<span class="number">3</span>,width:<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, rec3);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:#?&#125;"</span>,rec3 );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="keyword">let</span> rec4 = RecWithMethod&#123;height:<span class="number">3</span>,width:<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>,rec4.area() );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 利用元组求面积</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">area_tuple</span></span>(args:(<span class="built_in">i32</span>,<span class="built_in">i32</span>))-&gt;<span class="built_in">i32</span>&#123;</span><br><span class="line">    args.<span class="number">0</span> * args.<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 利用结构体求面积</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">area_struct</span></span>(rec:&amp;Rec)-&gt;<span class="built_in">i32</span>&#123;</span><br><span class="line">    rec.height*rec.width</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="枚举和匹配模式"><a href="#枚举和匹配模式" class="headerlink" title="枚举和匹配模式"></a>枚举和匹配模式</h1><p>枚举 enumerations/ enums</p><p>Option:一个特别有用的枚举，它代表一个值要么是某个值要么是什么都不是</p><h2 id="定义枚举"><a href="#定义枚举" class="headerlink" title="定义枚举"></a>定义枚举</h2>]]></content>
      
      
      <categories>
          
          <category> rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
            <tag> 大纲 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>rust所有权学习记录</title>
      <link href="/2019/03/05/rust-2019-03-05-rust%E6%89%80%E6%9C%89%E6%9D%83%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/03/05/rust-2019-03-05-rust%E6%89%80%E6%9C%89%E6%9D%83%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>边看边写，加深下记忆<br><img src="https://upload-images.jianshu.io/upload_images/422094-f1fcf8f562aa5fa5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/422094-0af488c84cb80abc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/422094-3992482bf832bc40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/422094-ea4198de200c76b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/422094-2ed652c4b29c4aba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/422094-a5f00ee12b1c6ac8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
            <tag> 所有权 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>计算机常用英语</title>
      <link href="/2019/03/05/%E9%80%9A%E7%94%A8%E8%AE%A1%E7%AE%97%E6%9C%BA-2019-03-05-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B8%B8%E7%94%A8%E8%8B%B1%E8%AF%AD/"/>
      <url>/2019/03/05/%E9%80%9A%E7%94%A8%E8%AE%A1%E7%AE%97%E6%9C%BA-2019-03-05-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B8%B8%E7%94%A8%E8%8B%B1%E8%AF%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="常见词汇"><a href="#常见词汇" class="headerlink" title="常见词汇"></a>常见词汇</h1><h2 id="rust"><a href="#rust" class="headerlink" title="rust"></a>rust</h2><p>出处：<a href="https://weathfold.gitbooks.io/rust-too-many-lists-zhcn/content/" target="_blank" rel="noopener">https://weathfold.gitbooks.io/rust-too-many-lists-zhcn/content/</a><br>如果你对应用程序进行性能剖析（profiling）<br>我没法忍受复杂度均摊（armortization）<br>这是用一个复合类型（sum type）</p><p>illegal recursive enum type; wrap the inner value in a box to make it representable 不合法的递归枚举类型；把值包装在一个box里让它变得可表示。</p><p>provides the simplest form of heap allocation in Rust<br>提供了Rust中最简单的堆内存分配的形式</p><p>每一个编程语言都有高效的处理重复概念的工具.在 Rust 中其工具之一就是 泛型（generics）<br>这是用一个复合类型（sum type）</p><h2 id="golang-reflect"><a href="#golang-reflect" class="headerlink" title="golang reflect"></a>golang reflect</h2><p>出处：<a href="https://studygolang.com/articles/2157" target="_blank" rel="noopener">https://studygolang.com/articles/2157</a></p><p>反射就是从接口值到反射对象，然后再反射回来。（Reflection goes from interface value to reflection object and back again.）</p><p>为了修改一个反射对象，值必须是settable的（To modify a reflection object, the value must be settable)</p><p>settability由反射对象是否保存原始项（original item）而决定。</p>]]></content>
      
      
      <categories>
          
          <category> computer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computr </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>flutter常用组件</title>
      <link href="/2019/03/03/flutter-2019-03-03-flutter%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6/"/>
      <url>/2019/03/03/flutter-2019-03-03-flutter%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="key"><a href="#key" class="headerlink" title="key"></a>key</h1><ol><li>和React的diff算法类似，在diff过程中如果有key的话，能够最大可能重用现在的节点。（提高性能）</li><li>key下面还有LocalKey和GlobalKey。</li><li>key可以来控制框架将在widget重建时与哪些其他widget匹配。</li><li>key可以唯一标识一个Widget，在列表类试图中尤为重要，因为他会让diff高效的计算出那些元素是新添加的，那些元素是被移除或交换位置的。<br>参考<br>知乎：flutter中的key到底有什么用？<br><a href="https://www.zhihu.com/question/268550818" target="_blank" rel="noopener">https://www.zhihu.com/question/268550818</a><br>Flutter中Widget之key原理探索<br><a href="https://zhuanlan.zhihu.com/p/41753551" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/41753551</a><h1 id="FocusScope转移焦点"><a href="#FocusScope转移焦点" class="headerlink" title="FocusScope转移焦点"></a>FocusScope转移焦点</h1>我们输入表单时，想要点击空白区域时</li></ol><h1 id="TextField-和-TextFormField"><a href="#TextField-和-TextFormField" class="headerlink" title="TextField 和 TextFormField"></a>TextField 和 TextFormField</h1><p>Flutter TextField详解<br><a href="https://juejin.im/post/5b6bdb406fb9a04f89785cb5" target="_blank" rel="noopener">https://juejin.im/post/5b6bdb406fb9a04f89785cb5</a><br>输入框及表单<br><a href="https://book.flutterchina.club/chapter3/input_and_form.html" target="_blank" rel="noopener">https://book.flutterchina.club/chapter3/input_and_form.html</a></p><h1 id="控制焦点"><a href="#控制焦点" class="headerlink" title="控制焦点"></a>控制焦点</h1><p><a href="https://book.flutterchina.club/chapter3/input_and_form.html" target="_blank" rel="noopener">https://book.flutterchina.club/chapter3/input_and_form.html</a></p>]]></content>
      
      
      <categories>
          
          <category> flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flutter </tag>
            
            <tag> fluuter Widget </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DAG资源</title>
      <link href="/2019/03/03/blockchain-DAG-2019-03-02-DAG%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/"/>
      <url>/2019/03/03/blockchain-DAG-2019-03-02-DAG%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<h1 id="比较好的资源"><a href="#比较好的资源" class="headerlink" title="比较好的资源"></a>比较好的资源</h1><p><a href="https://godag.github.io/" target="_blank" rel="noopener">https://godag.github.io/</a><br>golang实现的DAG<br><a href="https://github.com/garyyu/go-dag" target="_blank" rel="noopener">https://github.com/garyyu/go-dag</a></p>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> DAG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> DAG </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>开始学习flutter</title>
      <link href="/2019/03/02/flutter-2019-03-02-%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0flutter/"/>
      <url>/2019/03/02/flutter-2019-03-02-%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0flutter/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么学习flutter"><a href="#为什么学习flutter" class="headerlink" title="为什么学习flutter"></a>为什么学习flutter</h1><ol><li>自己的主业是后端，偶尔有时想做个移动端的小东西，不知道从何开始。</li><li>女朋友说她根本不知道我每天忙着在干什么。</li></ol><h1 id="flutter一些比较好的资源"><a href="#flutter一些比较好的资源" class="headerlink" title="flutter一些比较好的资源"></a>flutter一些比较好的资源</h1><p>好的资源很多，这里只是记录我自己学习过的一些内容。<br>学习过一次，忘记之后，再看相同的内容，效率会高很多</p><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><ol><li>从0开始写一个基于Flutter的开源中国客户端-Dart语法基础<br><a href="https://juejin.im/post/5b5005866fb9a04fea589561" target="_blank" rel="noopener">https://juejin.im/post/5b5005866fb9a04fea589561</a></li><li>构建移动端的手机号+验证码输入框<br><a href="https://www.jianshu.com/p/f7a9b8c84d26" target="_blank" rel="noopener">https://www.jianshu.com/p/f7a9b8c84d26</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flutter </tag>
            
            <tag> fluuter学习资源 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>grin（Mimblewimble）转账交易流程深入分析</title>
      <link href="/2019/02/27/grin-2019-02-27-grin%E4%BA%A4%E6%98%93%E6%B5%81%E7%A8%8B%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/"/>
      <url>/2019/02/27/grin-2019-02-27-grin%E4%BA%A4%E6%98%93%E6%B5%81%E7%A8%8B%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p><a href="https://grin-tech.org/" target="_blank" rel="noopener">Grin</a> is an exciting new cryptocurrency leveraging the MimbleWimble protocol. But tutorials on Grin are notoriously nondescript.</p><p>这篇文章旨在确切的分享<code>grin</code>的交易过程。<br><img src="https://upload-images.jianshu.io/upload_images/422094-fb8e18602a876986.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><hr><p>在<code>grin</code>中，一个输出就是一个<code>Pedersen Commitment</code>,任何输出都呈现下面的形式：<br><img src="https://upload-images.jianshu.io/upload_images/422094-f856c5bd6939ee85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="A Grin output, which is a Pedersen Commitment."></p><p><code>Pedersen Commitment(Pedersen 承诺)</code>用一种和聪明的方式隐藏了信息。如果你是刚听说<code>commitments（承诺）</code>， 那看到它把它理解成<code>shielded value(屏蔽值)</code>就可以了。</p><p>下面的内容来<a href="https://github.com/mimblewimble/grin/blob/master/doc/intro.md" target="_blank" rel="noopener">Grin wiki</a>，对理解这篇文章来说是很好的入门。</p><blockquote><p>• 如果选择一个很大的数<code>k</code>作为私钥，<code>k*H</code>就是对应的公钥。即使一个人知道公钥<code>k*H</code>值，想推导出<code>k</code>几乎不可能</p><p>• <code>r</code>是被用作致盲因子的私钥，<code>G</code>是椭圆曲线上的固定点，它们的乘积<code>r*G</code>是<code>r</code>在曲线上的公钥。</p><p>• <code>v</code> 是输入或输出的金额，<code>H</code>是椭圆曲线上的另一个固定点。</p><p><code>(k+j)*H = k*H + j*H</code>，<code>k</code>和<code>j</code>都是私钥。等式表明从两个私钥的和获取公钥<code>（k + j）* H</code>，等价于每个私钥的对应公钥的和 <code>（k * H + j * H）</code></p></blockquote><p>更深入的密码学研究可以在这里<a href="https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/" target="_blank" rel="noopener">ECC primer</a>找到。但简而言之，要花费Grin的输出，你必须知道致盲因子（r）和Grin（v）的数量。要解构承诺来推断这些值是不可能的。你必须提前知道它们。</p><p>致盲因素的存在是因为有人支付给你这些grin，他也会知道<code>v</code>的值（他给你发送了多少grin）。但只有你（甚至都不是Grin的发送者）将会知道这个输出的致盲因子，因此只有你能够花掉这个输出。</p><p>假设此输出使用致盲因子20，此输出包含40 Grin。（注意： Grin的数量实际上是以原子单位<code>1 NanoGrin</code>的倍数发送的。在这里直接使用<code>grin</code>简化了）：</p><p><img src="https://upload-images.jianshu.io/upload_images/422094-147c9a9b0d3120ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="In this output, the blinding factor is 20, and the amount of Grin is 40."></p><p>如果我们看<a href="https://grinexplorer.net/block/00000317907f10bc6dd3101574d2d4412839602381ed4c5365aafe3f2771fd94" target="_blank" rel="noopener">Grin 区块链浏览器</a>，输出不会像上面那样优雅的分解。就像我们所说的，这才是Grin真正输出的样子，</p><p><img src="https://upload-images.jianshu.io/upload_images/422094-f6ff8bcd2ea7ba7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="What a Grin output looks like (under the Commit column)."></p><p>再重复一次，从这个输出中推导出<code>20(致盲因子)</code>或者<code>40(grin 数量)</code>是不可能的。</p><h1 id="花费输出"><a href="#花费输出" class="headerlink" title="花费输出"></a>花费输出</h1><p>假设刚才展示的输出属于Alice。现在，Alice希望将40个Grin中的25个发送给Bob。为简单起见，我们会忽略挖矿费。</p><p>假如您有5美元，购买3美元的东西，您将获得2美元的找零。比特币交易是这样的，Grin也不例外。如果Alice想要从她40个未花费的Grin输出中向Bob发送25个Grin，她也会在同一笔交易中创建一个输出，把剩余的15个 Grin（她的零钱）返还自己。</p><p><img src="https://upload-images.jianshu.io/upload_images/422094-41b33980d9f42a1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alice identifies how much Grin she wants to send to Bob, and also her change."></p><p>这15个Grin将会返还Alice，这意味着只有她能够控制它并再次花费它。换句话说，Bob不应该花费Alice的找零。为此，Alice必须为她的找零输出创建一个新的致盲因子。假设Alice选择34。</p><p>Alice知道<code>r</code>（为她找零输出的致盲因子）和 <code>v</code>（她找零的grin的数量），她拥有创建找零输出（<code>co</code>）所需的一切。这将作为一个输出记录在区块链上，就像Alice创建的将25个Grin发送给Bob的输出一样。</p><p><img src="https://upload-images.jianshu.io/upload_images/422094-85f530d564597936.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alice’s change output."></p><p>正如我之前提到的，要花费任何输出，您必须知道该输出中使用的致盲因子。Alice知道她想要花费的输出中所使用的致盲因素（20），但她需要一种方法向所有人证明她知道。</p><p>这就是为什么她需要创建一个完全独立的计算，就是<em>致盲因子的和</em>。这涉及到Alice刚才为她的找零输出采用的致盲因子（34），并从中减去她想要花费的输出的致盲因子（20）。<br><img src="https://upload-images.jianshu.io/upload_images/422094-ab262f373c7d30bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alice’s sum of her blinding factors."></p><p><code>rs</code>（s表示发送者，现在是Alice）是Alice所有致盲因子的总和，现在的情况下它是14。（Note: I am intentionally leaving out kernel offsets）。</p><p>Alice做的就是创建一个随机的nonce <code>ks</code>（再次说明，s表示发送者）。她将使用这个随机的nonce来帮助她对这笔交易签名，我们稍后将会展示。Alice不会将实际的nonce发送给Bob。相反，她发送<code>ks•G</code>，这是对该nonce 的承诺。如前所述，通过将nonce乘以生成点<code>G</code>，Alice屏蔽了她实际的nonce值。</p><p>Alice将以下信息发送给Bob。实际上，Grin数据不会区分“Metadata”和“Data”字段，这里只是为了清楚的显示。<br><img src="https://upload-images.jianshu.io/upload_images/422094-bfc74a55e7b3423a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Everything Alice sends Bob in the first step of this Grin transaction."></p><p><strong>Metadata</strong>中的数据：</p><ul><li><strong>Amount to send:</strong> Alice想要发送给Bob的grin数量（现在是25）。</li><li><strong>TX UUID:</strong> Alice和Bob用于在来回发送数据时，标识此交易的唯一标识符。</li><li><strong>TX fee:</strong> 交易费（这篇文章先不讨论）。</li><li><strong>lock_height:</strong> 区块数，在此之后交易将有效。</li></ul><p><strong>Data</strong>中的数据</p><ul><li><strong>TX Inputs</strong>: Alice为她给Bob的交易的使用的未花费输入。</li><li><strong>co</strong>: Alice的找零输出</li><li><strong>ks • G</strong>: Alice的nonce变成对应的承诺通过乘以生成点<code>G</code>.</li><li><strong>rs • G*</strong>: Alice致盲因子的和对应的承诺通过乘以生成点<code>G</code>.</li></ul><p>Alice将所有这些发送给Bob，Bob继续下一步。</p><h1 id="Bob的回合"><a href="#Bob的回合" class="headerlink" title="Bob的回合"></a>Bob的回合</h1><p>一旦从Alice接收到该数据后，Bob将<strong>TX fee</strong>和<strong>lock_height</strong>连接起来以创建<strong>M</strong>，称为交易的“Message”。</p><p><img src="https://upload-images.jianshu.io/upload_images/422094-600ce62610a8b2c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="The “message” of the transaction."></p><p>Bob为他希望从Alice哪里收到的25个grin选择一个致盲因子<strong>rr</strong>（r表示接受者，在这里是Bob）。假设他选择 <strong>11</strong>。他还选择了他自己的随机的nonce <strong>kr</strong>（r表示接受者）。</p><p>就像Alice一样，Bob通过将每个值乘以生成点<strong>G</strong>来创建对这两个值的<em>承诺</em>。使用这些值，Bob 为此交易生成 <strong>Schnorr challenge</strong>，由变量<strong><code>e</code></strong>表示：</p><p><img src="https://upload-images.jianshu.io/upload_images/422094-c7215bd74d0df7e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="The Schnorr challenge for the transaction."></p><p><strong>Schnorr challenge</strong>由以下值的 <strong>SHA256 hash</strong>组成：</p><ul><li>交易的message。</li><li>Alice和Bob使用的nonce对应承诺的和。</li><li>Bob的致盲因子（为他25个grin的输出）对应的承诺 + Alice致盲因子和对应的承诺。</li></ul><p>Bob使用<strong>e</strong>为此交易生成他的<strong>Schnorr signature</strong> ，简称<strong>sr</strong>（r为收件人）。虽然它是Bob签名的全部，但我们称之为<strong>Bob方签名</strong>，因为它最终将被添加到<strong>Alice方签名</strong>中来创建整个交易的签名。<br><img src="https://upload-images.jianshu.io/upload_images/422094-4537913154cc27de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="The Schnorr challenge for the transaction."></p><p>当Alice最终收到<strong>sr</strong>时，她将无法从中推断出<strong>kr</strong>或<strong>rr</strong>的值。</p><h2 id="Bob将以下内容发送回Alice"><a href="#Bob将以下内容发送回Alice" class="headerlink" title="Bob将以下内容发送回Alice"></a>Bob将以下内容发送回Alice</h2><p><img src="https://upload-images.jianshu.io/upload_images/422094-0ff2cd0e060a4864.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Bob sends his partial signature, commitment to his nonce, and commitment to his blinding factor for his output back to Alice."><br>包括：</p><ul><li><strong>sr:</strong> Bob方的签名</li><li><strong>kr • G：</strong> Bob的nonce对应的承诺</li><li><strong>rr • G：</strong> Bob为他期望收到的25个grin选择的致盲因子对应的承诺。</li></ul><h1 id="最后一步：返回给Alice"><a href="#最后一步：返回给Alice" class="headerlink" title="最后一步：返回给Alice"></a>最后一步：返回给Alice</h1><p>Alice现在有所需的一切，她也需要计算<strong>e</strong>（这笔交易的Schnorr challenge）。在本地计算e之后，Alice就可以<strong>验证Bob方的签名</strong>。<br>回顾一下Bob方的签名<strong>sr</strong>,由一下组成：<br><img src="https://upload-images.jianshu.io/upload_images/422094-c11f26d0b940c7b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Bob’s partial signature for this transaction."></p><p>基于我们前面描述的椭圆曲线的性质，Alice可以将生成点<strong>G</strong> 引入等式的两边，等式任然成立。</p><p><img src="https://upload-images.jianshu.io/upload_images/422094-db5d42baf2f3beeb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alice multiples each side of the equation by generator point G."></p><p>由于Alice收到了Bob的<strong>kr • G</strong>（Bob的nonce对应的承诺）和<strong>rr•G</strong>（Bob为他期望收到的25个Grin选择的致盲因子对应的承诺），并且因为她已经在本地计算了<strong>e</strong>，所以Alice验证Bob方签名<strong>sr</strong>，通过简单地将它乘以生成器<strong>G</strong>并确保等式的右边等于该值。<br>通过这样做，Alice证明：</p><ol><li>Bob知道他将收到多少grin</li><li>Bob知道他的nonce</li><li>Bob知道他期望收到的25grin的致盲因子</li></ol><p>Alice并不知道Bob的nonce和他选择的致盲因子。</p><p>然后Alice生成自己方的签名：</p><p><img src="https://upload-images.jianshu.io/upload_images/422094-675d4cdfaedc8fbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alice generates her partial signature for the transaction."><br>Alice现在可以生成整个交易的签名，该签名包括她和Bob的签名：<br><img src="https://upload-images.jianshu.io/upload_images/422094-83fddb938cb10183.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>签名</strong>包括</p><ul><li>Alice和Bob方签名的和</li><li>Alice和Bob的nonces对应的承诺（他们都不知道对方真正的nonce）</li></ul><p>再简明一点，它可以是这样：</p><p><img src="https://upload-images.jianshu.io/upload_images/422094-e6bfac1f00c6fc85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="The signature for the transaction."></p><p>其中 <code>s = ss + sr</code>  ，<code>k = ks + kr</code>.</p><p>记住这个签名，它马上会很有意义。</p><h1 id="完成交易"><a href="#完成交易" class="headerlink" title="完成交易"></a>完成交易</h1><p>数字货币需要一个”memory” , 也就是说，当你向一个人转账后，你不能将同样的钱再发给别人。在Grin中，我们隐藏了发送的Grin数和接受者。那么我们怎么能证明没有钱被双花或者凭空产生呢？</p><p>在Grin交易中，当您从输入中减去所有输出时，剩余的Grin数应该等于0。回到刚才的5美元的比喻，有下面的公式：</p><blockquote><p>3 dollars to cashier (output) + 2 dollars in change back to me (output) - 5 dollar bill (input) = 0</p></blockquote><p>在Grin中，当交易合法时，相同的求和使<strong>v</strong>值总和为零。但是，我们如何在不知道<strong>value</strong>的情况下证明这一点？让我们看一下从Alice到Bob的交易中使用的输入和输出：</p><blockquote><p>（34•G）+（15•H）+（11•G）+（25•H） - （20•G） - （40•H）=（25•G）+（0•H）</p></blockquote><p>这里比较巧妙的属性是，当Grin金额抵消时（因为没有钱是凭空创造的），从输入中减去输出所剩下的全部是“<strong>the excess blinding factor</strong>” 的承诺，或者“<strong>kernel excess</strong>”。这个“<strong>the excess blinding factor</strong>”的承诺，现在是<strong>25•G</strong>，就是椭圆曲线上的公钥。</p><p>如果Grin交易的输出总和减去输入的总和会在曲线上产生有效的公钥，你便知道<strong>v</strong>值肯定已经抵消了。如果等式的右边不是<strong>n•G + 0•H</strong>的形式 【for some known value of <em>n</em>】 ，你便知道该交易无效。这意味着花费的金额大于输入金额（例如，您提供5美元的账单，向收银员支付3美元，并在找零中获得10美元），或者输入大于输出（例如，您提供5美元的账单，向收银员支付3美元，并且没有找零）。</p><p>记得之前的签名吗？<br><img src="https://upload-images.jianshu.io/upload_images/422094-a46e78f8c49fb186.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="The signature from the transaction."></p><p>这个签名实际上已经签署了我刚刚提到的<strong>excess blinding factor</strong>对应的承诺。这是如何做的？</p><p>如果你还记得，当你用生成器<strong>G</strong>乘以等式的两边时，这就是Bob方签名。</p><p><img src="https://upload-images.jianshu.io/upload_images/422094-959d5f16cf29a967.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Bob’s partial signature when you multiply both sides by generator G."></p><p>类似地，当你用生成器<strong>G</strong>乘以等式两边时，Alice方签名就是这样：<br><img src="https://upload-images.jianshu.io/upload_images/422094-1d43d6b0b44a3aef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Bob’s partial signature when you multiply both sides by generator G."><br>如果将两个方程式加在一起会发生什么？你会得到：</p><blockquote><p>sr•G + ss•G =（kr•G）+（ks•G）+（e•（rr•G + rs•G））</p></blockquote><p>请记住，<strong>rr</strong>是Bob的致盲因子，<strong>rs</strong>是Alice的盲目因子之和。还需要记住<code>rr•G + rs•G</code> 和 <code>(rr + rs)•G</code>是等价的。</p><p>Bob的致盲因子对应的承诺是<strong>11•G</strong>。Alice所有致盲因子的和对应的承诺是<code>14•G</code>。将它们加在一起得到<strong>25•G</strong>，这是交易的<strong> excess blinding factor</strong>对应的承诺。因此，添加<strong>sr</strong>和<strong>ss</strong>（ Bob和Alice各自的部分签名）证明了整个交易的有效性，因为它们加起来是<strong> excess blinding factor</strong>对应的承诺。<br>Further simplifying that equation, we get:<br>进一步简化该等式，我们得到：</p><blockquote><p>sr•G + ss•G = (k•G) + (e • (r•G))</p></blockquote><p>或者</p><blockquote><p>sr•G + ss•G = (k•G) + (e • (25•G))</p></blockquote><p>剩下要做的就是检查等式左侧等于右侧。</p><p>请记住，这个等式中的所有内容（双方签名的和，<strong>e</strong>中的所有内容，<strong> excess blinding factor</strong>对应的承诺，nonce和对应的承诺）都是公开可见的，因此任何人都可以进行此验证。我们不需要Alice和Bob的致盲因子来验证交易。By adding their partial signatures and verifying that they summed to the commitment to the excess blinding factor，我们证明：</p><ol><li>再花费Alice之前的输入时，没有钱凭空产生。</li><li>Alice and Bob both knew the blinding factors for their outputs when they created this transaction. This means the new outputs are spendable by them, and not lost to the abyss.Alice和Bob都知道他们的输出对应的致盲因子。这意味着他们可以花费新的输出，而不是丢失【这里翻译不好】</li></ol><p>我们用来验证交易的信息放在所谓的<strong>transaction kernel</strong>中了。</p><h1 id="交易核"><a href="#交易核" class="headerlink" title="交易核"></a>交易核</h1><p>除了输出之外，<strong>transaction kernel（交易核）</strong>是从Grin交易中产生的另一块信息。每个交易都会产生一个<strong>transaction kernel（交易核）</strong>，但是没有办法通过Grin区块链将输出和交易核关联起来。每个Grin交易都存在一个，它包含没有钱凭空产生的证明。</p><p>下面的信息存储来交易核中：</p><ul><li>交易的签名(s, k • G)</li><li>和“<strong>excess blinding factor</strong>” 相关联的公钥（这里指<strong>25•G</strong>），如上所述，它可以用来验证<strong>s</strong>。</li><li>交易的<strong>交易费</strong>和<strong>锁定高度</strong>(注意:如果这是Coinbase交易，那么这些交易都不存在).</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>After all this is said and done, the only things broadcast to the network from the transaction are:<br>完成所有这些之后，只把交易的以下内容向网络广播：</p><ul><li>所用的输入</li><li>新的输出</li><li>交易核</li><li>核偏移 (这篇文章没有讲到).</li></ul><p>None of the transaction metadata from earlier are relayed. Even better, some of this information may get discarded, too — but we will save that for another post.</p><p>希望这篇文章能够说明Grin交易是如何运作的。我遗漏了范围证明，内核偏移和交易费用。请留意更多关于Grin如何实现切入工作的帖子，多参与者交易的外观以及一些实验性功能。Look out for more posts on how cut-through works in Grin, what multi-participant transactions look like, and some experimental features.</p><hr><p><strong>原文链接:</strong> <a href="https://medium.com/@brandonarvanaghi/grin-transactions-explained-step-by-step-fdceb905a853" target="_blank" rel="noopener">https://medium.com/@brandonarvanaghi/grin-transactions-explained-step-by-step-fdceb905a853</a><br><strong>作者:</strong> <a href="https://medium.com/@brandonarvanaghi" title="Go to the profile of Brandon Arvanaghi" target="_blank" rel="noopener">Brandon Arvanaghi</a></p><p><strong>翻译&amp;校对:</strong> 徐晓峰</p>]]></content>
      
      
      <categories>
          
          <category> grin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> grin </tag>
            
            <tag> 交易 </tag>
            
            <tag> Mimblewimble </tag>
            
            <tag> 区块链blockchain </tag>
            
            <tag> 隐私交易 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Simple Golang HTTPS/TLS Examples</title>
      <link href="/2019/02/20/golang-2019-02-20-Simple-Golang-HTTPS-TLS-Examples/"/>
      <url>/2019/02/20/golang-2019-02-20-Simple-Golang-HTTPS-TLS-Examples/</url>
      
        <content type="html"><![CDATA[<h5 id="Generate-private-key-key"><a href="#Generate-private-key-key" class="headerlink" title="Generate private key (.key)"></a>Generate private key (.key)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Key considerations for algorithm &quot;RSA&quot; ≥ 2048-bit</span><br><span class="line">openssl genrsa -out server.key 2048</span><br><span class="line"></span><br><span class="line"># Key considerations for algorithm &quot;ECDSA&quot; ≥ secp384r1</span><br><span class="line"># List ECDSA the supported curves (openssl ecparam -list_curves)</span><br><span class="line">openssl ecparam -genkey -name secp384r1 -out server.key</span><br></pre></td></tr></table></figure><h5 id="Generation-of-self-signed-x509-public-key-PEM-encodings-pem-crt-based-on-the-private-key"><a href="#Generation-of-self-signed-x509-public-key-PEM-encodings-pem-crt-based-on-the-private-key" class="headerlink" title="Generation of self-signed(x509) public key (PEM-encodings .pem|.crt) based on the private (.key)"></a>Generation of self-signed(x509) public key (PEM-encodings <code>.pem</code>|<code>.crt</code>) based on the private (<code>.key</code>)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -x509 -sha256 -key server.key -out server.crt -days 3650</span><br></pre></td></tr></table></figure><hr><h4 id="Simple-Golang-HTTPS-TLS-Server"><a href="#Simple-Golang-HTTPS-TLS-Server" class="headerlink" title="Simple Golang HTTPS/TLS Server"></a>Simple Golang HTTPS/TLS Server</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="comment">// "fmt"</span></span><br><span class="line">    <span class="comment">// "io"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HelloServer</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">    w.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"text/plain"</span>)</span><br><span class="line">    w.Write([]<span class="keyword">byte</span>(<span class="string">"This is an example server.\n"</span>))</span><br><span class="line">    <span class="comment">// fmt.Fprintf(w, "This is an example server.\n")</span></span><br><span class="line">    <span class="comment">// io.WriteString(w, "This is an example server.\n")</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">"/hello"</span>, HelloServer)</span><br><span class="line">    err := http.ListenAndServeTLS(<span class="string">":443"</span>, <span class="string">"server.crt"</span>, <span class="string">"server.key"</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">"ListenAndServe: "</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Hint: visit, please do not forget to use https begins,otherwise chrome will download a file as follows:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -sL https://localhost:443 | xxd</span><br><span class="line">0000000: 1503 0100 0202 0a                        .......</span><br></pre></td></tr></table></figure><h4 id="TLS-transport-layer-security-—-Server"><a href="#TLS-transport-layer-security-—-Server" class="headerlink" title="TLS (transport layer security) — Server"></a>TLS (transport layer security) — <code>Server</code></h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"crypto/tls"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log.SetFlags(log.Lshortfile)</span><br><span class="line"></span><br><span class="line">    cer, err := tls.LoadX509KeyPair(<span class="string">"server.crt"</span>, <span class="string">"server.key"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    config := &amp;tls.Config&#123;Certificates: []tls.Certificate&#123;cer&#125;&#125;</span><br><span class="line">    ln, err := tls.Listen(<span class="string">"tcp"</span>, <span class="string">":443"</span>, config) </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> ln.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        conn, err := ln.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Println(err)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">go</span> handleConnection(conn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleConnection</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line">    r := bufio.NewReader(conn)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        msg, err := r.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Println(err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println</span>(msg)</span><br><span class="line"></span><br><span class="line">        n, err := conn.Write([]<span class="keyword">byte</span>(<span class="string">"world\n"</span>))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Println(n, err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TLS-transport-layer-security-—-Client"><a href="#TLS-transport-layer-security-—-Client" class="headerlink" title="TLS (transport layer security) — Client"></a>TLS (transport layer security) — <code>Client</code></h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"crypto/tls"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log.SetFlags(log.Lshortfile)</span><br><span class="line"></span><br><span class="line">    conf := &amp;tls.Config&#123;</span><br><span class="line">         <span class="comment">//InsecureSkipVerify: true,</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    conn, err := tls.Dial(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:443"</span>, conf)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">    n, err := conn.Write([]<span class="keyword">byte</span>(<span class="string">"hello\n"</span>))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(n, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">100</span>)</span><br><span class="line">    n, err = conn.Read(buf)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(n, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>(<span class="keyword">string</span>(buf[:n]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Perfect-SSL-Labs-Score-with-Go"><a href="#Perfect-SSL-Labs-Score-with-Go" class="headerlink" title="Perfect SSL Labs Score with Go"></a><a href="https://blog.bracelab.com/achieving-perfect-ssl-labs-score-with-go" target="_blank" rel="noopener">Perfect SSL Labs Score with Go</a></h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"crypto/tls"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mux := http.NewServeMux()</span><br><span class="line">    mux.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">        w.Header().Add(<span class="string">"Strict-Transport-Security"</span>, <span class="string">"max-age=63072000; includeSubDomains"</span>)</span><br><span class="line">        w.Write([]<span class="keyword">byte</span>(<span class="string">"This is an example server.\n"</span>))</span><br><span class="line">    &#125;)</span><br><span class="line">    cfg := &amp;tls.Config&#123;</span><br><span class="line">        MinVersion:               tls.VersionTLS12,</span><br><span class="line">        CurvePreferences:         []tls.CurveID&#123;tls.CurveP521, tls.CurveP384, tls.CurveP256&#125;,</span><br><span class="line">        PreferServerCipherSuites: <span class="literal">true</span>,</span><br><span class="line">        CipherSuites: []<span class="keyword">uint16</span>&#123;</span><br><span class="line">            tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,</span><br><span class="line">            tls.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,</span><br><span class="line">            tls.TLS_RSA_WITH_AES_256_GCM_SHA384,</span><br><span class="line">            tls.TLS_RSA_WITH_AES_256_CBC_SHA,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    srv := &amp;http.Server&#123;</span><br><span class="line">        Addr:         <span class="string">":443"</span>,</span><br><span class="line">        Handler:      mux,</span><br><span class="line">        TLSConfig:    cfg,</span><br><span class="line">        TLSNextProto: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="function"><span class="keyword">func</span><span class="params">(*http.Server, *tls.Conn, http.Handler)</span>, 0),</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line">    log.Fatal(srv.ListenAndServeTLS("tls.crt", "tls.key"))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Generation-of-self-sign-a-certificate-with-a-private-key-and-public-key-PEM-encodings-pem-crt-in-one-command"><a href="#Generation-of-self-sign-a-certificate-with-a-private-key-and-public-key-PEM-encodings-pem-crt-in-one-command" class="headerlink" title="Generation of self-sign a certificate with a private (.key) and public key (PEM-encodings .pem|.crt) in one command:"></a>Generation of self-sign a certificate with a private (<code>.key</code>) and public key (PEM-encodings <code>.pem</code>|<code>.crt</code>) in one command:</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ECDSA recommendation key ≥ secp384r1</span></span><br><span class="line"><span class="comment"># List ECDSA the supported curves (openssl ecparam -list_curves)</span></span><br><span class="line">openssl req -x509 -nodes -newkey ec:secp384r1 -keyout server.ecdsa.key -out server.ecdsa.crt -days 3650</span><br><span class="line"><span class="comment"># openssl req -x509 -nodes -newkey ec:&lt;(openssl ecparam -name secp384r1) -keyout server.ecdsa.key -out server.ecdsa.crt -days 3650</span></span><br><span class="line"><span class="comment"># -pkeyopt ec_paramgen_curve:… / ec:&lt;(openssl ecparam -name …) / -newkey ec:…</span></span><br><span class="line">ln -sf server.ecdsa.key server.key</span><br><span class="line">ln -sf server.ecdsa.crt server.crt</span><br><span class="line"></span><br><span class="line"><span class="comment"># RSA recommendation key ≥ 2048-bit</span></span><br><span class="line">openssl req -x509 -nodes -newkey rsa:2048 -keyout server.rsa.key -out server.rsa.crt -days 3650</span><br><span class="line">ln -sf server.rsa.key server.key</span><br><span class="line">ln -sf server.rsa.crt server.crt</span><br></pre></td></tr></table></figure><ul><li><code>.crt</code> — Alternate synonymous most common among *nix systems <code>.pem</code> (pubkey).</li><li><code>.csr</code> — Certficate Signing Requests (synonymous most common among *nix systems).</li><li><code>.cer</code> — Microsoft alternate form of <code>.crt</code>, you can use MS to convert <code>.crt</code> to <code>.cer</code> (<code>DER</code> encoded <code>.cer</code>, or <code>base64[PEM]</code> encoded <code>.cer</code>).</li><li><code>.pem</code> = The PEM extension is used for different types of X.509v3 files which contain ASCII (Base64) armored data prefixed with a «—– BEGIN …» line. These files may also bear the <code>cer</code> or the <code>crt</code> extension.</li><li><code>.der</code> — The DER extension is used for binary DER encoded certificates.</li></ul><h4 id="Generating-the-Certficate-Signing-Request"><a href="#Generating-the-Certficate-Signing-Request" class="headerlink" title="Generating the Certficate Signing Request"></a>Generating the Certficate Signing Request</h4><pre><code>openssl req -new -sha256 -key server.key -out server.csropenssl x509 -req -sha256 -in server.csr -signkey server.key -out server.crt -days 3650</code></pre><h2 id="ECDSA-amp-RSA-—-FAQ"><a href="#ECDSA-amp-RSA-—-FAQ" class="headerlink" title="ECDSA &amp; RSA — FAQ"></a>ECDSA &amp; RSA — FAQ</h2><ul><li>Validate the elliptic curve parameters <code>-check</code></li><li>List “ECDSA” the supported curves <code>openssl ecparam -list_curves</code></li><li>Encoding to explicit “ECDSA” <code>-param_enc explicit</code></li><li>Conversion form to compressed “ECDSA” <code>-conv_form compressed</code></li><li>“EC” parameters and a private key <code>-genkey</code></li></ul><h2 id="CA-Bundle-Path"><a href="#CA-Bundle-Path" class="headerlink" title="CA Bundle Path"></a>CA Bundle Path</h2><table><thead><tr><th>Distro</th><th>Package</th><th>Path to CA</th></tr></thead><tbody><tr><td>Fedora, RHEL, CentOS</td><td>ca-certificates</td><td>/etc/pki/tls/certs/ca-bundle.crt</td></tr><tr><td>Debian, Ubuntu, Gentoo, Arch Linux</td><td>ca-certificates</td><td>/etc/ssl/certs/ca-certificates.crt</td></tr><tr><td>SUSE, openSUSE</td><td>ca-certificates</td><td>/etc/ssl/ca-bundle.pem</td></tr><tr><td>FreeBSD</td><td>ca_root_nss</td><td>/usr/local/share/certs/ca-root-nss.crt</td></tr><tr><td>Cygwin</td><td>-</td><td>/usr/ssl/certs/ca-bundle.crt</td></tr><tr><td>macOS (MacPorts)</td><td>curl-ca-bundle</td><td>/opt/local/share/curl/curl-ca-bundle.crt</td></tr><tr><td>Default cURL CA bunde path (without –with-ca-bundle option)</td><td></td><td>/usr/local/share/curl/curl-ca-bundle.crt</td></tr><tr><td>Really old RedHat?</td><td></td><td>/usr/share/ssl/certs/ca-bundle.crt</td></tr></tbody></table><h2 id="Reference-Link"><a href="#Reference-Link" class="headerlink" title="Reference Link"></a>Reference Link</h2><ul><li><del><a href="https://web.archive.org/web/20160520182043/https://blog.bracelab.com/achieving-perfect-ssl-labs-score-with-go" target="_blank" rel="noopener">Achieving a Perfect SSL Labs Score with Go – <code>blog.bracelab.com</code></a></del></li><li><a href="http://superuser.com/a/226229/205366" target="_blank" rel="noopener">OpenSSL without prompt – <code>superuser.com</code> (Stack Exchange)</a></li><li><a href="https://gist.github.com/spikebike/2232102" target="_blank" rel="noopener">TLS server and client — <code>gist.github.com/spikebike</code></a></li><li><del><a href="https://web.archive.org/web/20150925030955/http://echo.labstack.com/guide" target="_blank" rel="noopener">Echo, a fast and unfancy micro web framework for Go — <code>echo.labstack.com/guide</code></a></del></li><li><a href="https://kjur.github.io/jsrsasign/sample-ecdsa.html" target="_blank" rel="noopener">https://kjur.github.io/jsrsasign/sample-ecdsa.html</a></li><li><a href="https://www.guyrutenberg.com/2013/12/28/creating-self-signed-ecdsa-ssl-certificate-using-openssl/" target="_blank" rel="noopener">Creating Self-Signed ECDSA SSL Certificate using OpenSSL – <code>guyrutenberg.com</code></a></li><li><a href="https://www.openssl.org/docs/manmaster/" target="_blank" rel="noopener">https://www.openssl.org/docs/manmaster/</a><ul><li><a href="https://www.openssl.org/docs/manmaster/man1/ecparam.html" target="_blank" rel="noopener">https://www.openssl.org/docs/manmaster/man1/ecparam.html</a></li><li><a href="https://www.openssl.org/docs/manmaster/man1/ec.html" target="_blank" rel="noopener">https://www.openssl.org/docs/manmaster/man1/ec.html</a></li><li><a href="https://www.openssl.org/docs/manmaster/man1/req.html" target="_blank" rel="noopener">https://www.openssl.org/docs/manmaster/man1/req.html</a></li></ul></li><li><a href="https://digitalelf.net/2016/02/creating-ssl-certificates-in-3-easy-steps/" target="_blank" rel="noopener">https://digitalelf.net/2016/02/creating-ssl-certificates-in-3-easy-steps/</a></li><li><a href="http://www.kaihag.com/https-and-go/" target="_blank" rel="noopener">HTTPS and Go – <code>kaihag.com</code></a></li><li><a href="https://blog.cloudflare.com/the-complete-guide-to-golang-net-http-timeouts/" target="_blank" rel="noopener">The complete guide to Go net/http timeouts – <code>blog.cloudflare.com</code></a></li><li><a href="https://gist.github.com/jtwaleson/1fdd77260bcb48377b6b" target="_blank" rel="noopener">Certificate fetcher in Go – <code>gist.github.com</code></a></li><li><a href="https://gist.github.com/d-schmidt/587ceec34ce1334a5e60" target="_blank" rel="noopener">How to redirect HTTP to HTTPS with a golang webserver – <code>gist.github.com</code></a></li><li><strong><a href="https://sourceforge.net/projects/xca/" target="_blank" rel="noopener">XCA - X Certificate and key management</a></strong></li><li>Package <a href="https://github.com/valyala/tcplisten" target="_blank" rel="noopener">tcplisten</a> provides customizable TCP <code>net.Listener</code> with various performance-related options </li><li><a href="https://github.com/bifurcation/mint" target="_blank" rel="noopener">https://github.com/bifurcation/mint</a> — minimal TLS 1.3 Implementation in Go</li><li><a href="https://github.com/cloudflare/tls-tris" target="_blank" rel="noopener">https://github.com/cloudflare/tls-tris</a> — crypto/tls, now with 100% more 1.3</li><li><a href="https://github.com/Xeoncross/secureserver" target="_blank" rel="noopener">https://github.com/Xeoncross/secureserver</a></li><li><a href="https://github.com/cloudflare/cfssl" target="_blank" rel="noopener">https://github.com/cloudflare/cfssl</a></li><li><a href="https://github.com/google/certificate-transparency" target="_blank" rel="noopener">https://github.com/google/certificate-transparency</a></li><li><a href="https://cipherli.st/" target="_blank" rel="noopener">https://cipherli.st/</a></li><li><a href="https://github.com/cmrunton/tls-dashboard" target="_blank" rel="noopener">https://github.com/cmrunton/tls-dashboard</a> — dashboard written in JavaScript &amp; HTML to check the remaining time before a TLS certificate expires.</li><li><a href="https://github.com/tomato42/tlsfuzzer" target="_blank" rel="noopener">https://github.com/tomato42/tlsfuzzer</a></li><li><a href="https://github.com/mozilla/tls-observatory" target="_blank" rel="noopener">https://github.com/mozilla/tls-observatory</a> (<a href="https://observatory.mozilla.org/" target="_blank" rel="noopener">https://observatory.mozilla.org/</a>)</li><li><a href="https://dev.ssllabs.com/ssltest/" target="_blank" rel="noopener">https://dev.ssllabs.com/ssltest/</a></li><li><a href="https://indieweb.org/HTTPS" target="_blank" rel="noopener">https://indieweb.org/HTTPS</a></li><li><a href="https://github.com/konklone/shaaaaaaaaaaaaa" target="_blank" rel="noopener">https://github.com/konklone/shaaaaaaaaaaaaa</a> (<a href="https://shaaaaaaaaaaaaa.com/" target="_blank" rel="noopener">https://shaaaaaaaaaaaaa.com/</a>)</li><li><a href="https://securityheaders.io/" target="_blank" rel="noopener">https://securityheaders.io/</a></li><li><a href="https://testssl.sh/" target="_blank" rel="noopener">https://testssl.sh/</a></li><li><a href="https://github.com/nabla-c0d3/sslyze" target="_blank" rel="noopener">https://github.com/nabla-c0d3/sslyze</a></li><li><a href="https://github.com/iSECPartners/sslyze" target="_blank" rel="noopener">https://github.com/iSECPartners/sslyze</a></li><li><a href="https://github.com/mozilla/cipherscan" target="_blank" rel="noopener">https://github.com/mozilla/cipherscan</a></li><li><a href="https://github.com/ssllabs/ssllabs-scan" target="_blank" rel="noopener">https://github.com/ssllabs/ssllabs-scan</a></li><li><a href="https://github.com/chromium/badssl.com" target="_blank" rel="noopener">https://github.com/chromium/badssl.com</a> (<a href="https://badssl.com" target="_blank" rel="noopener">https://badssl.com</a>)</li><li><a href="https://github.com/datatheorem/TrustKit" target="_blank" rel="noopener">https://github.com/datatheorem/TrustKit</a></li><li><a href="https://github.com/certifi/gocertifi" target="_blank" rel="noopener">https://github.com/certifi/gocertifi</a></li><li>…</li></ul><p>原文链接<a href="https://gist.github.com/denji/12b3a568f092ab951456" target="_blank" rel="noopener">https://gist.github.com/denji/12b3a568f092ab951456</a></p>]]></content>
      
      
      <categories>
          
          <category> golang学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> https </tag>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深入理解base64</title>
      <link href="/2019/02/20/%E9%80%9A%E7%94%A8%E8%AE%A1%E7%AE%97%E6%9C%BA-2019-02-20-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3base64/"/>
      <url>/2019/02/20/%E9%80%9A%E7%94%A8%E8%AE%A1%E7%AE%97%E6%9C%BA-2019-02-20-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3base64/</url>
      
        <content type="html"><![CDATA[<h1 id="base64"><a href="#base64" class="headerlink" title="base64"></a>base64</h1><h2 id="base64简单介绍"><a href="#base64简单介绍" class="headerlink" title="base64简单介绍"></a>base64简单介绍</h2><p>base64是一种可逆的编码方式。</p><blockquote><p>简单来说，base64一种用64个Ascii字符来表示任意二进制数据的方法，就是表示二进制数据，用自己设定的64个字符。主要用于将不可打印的字符转化成可打印的字符。<br>或者简单的说将二进制数据编码成Ascii字符。Base64是网络上最常用的传输8bit字节数据的编码方式之一</p></blockquote><h2 id="base64表"><a href="#base64表" class="headerlink" title="base64表"></a>base64表</h2><p>  Base64的原理其实很简单，首先，需要准备一个包含64个字符的表格（如下表），0～63分别对应了唯一一个字符，比如18对应的是S。<br><img src="https://upload-images.jianshu.io/upload_images/422094-2f97583c4c8cda01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="base64编码过程"><a href="#base64编码过程" class="headerlink" title="base64编码过程"></a>base64编码过程</h2><p>对二进制数据进行处理，每3个字节一组，一共3x8=24bit，将这24bit划分为4组，每组正好6个bit，6bit的数据刚好可以表示0～63的范围，也就可以对应上表的64个字符。这样我们就得到了4个数字作为索引，然后查表获得相应的4个字符，就得到了编码后的字符串。</p><p>比如现在要编码<code>Man</code>三个字符，我们需要先根据ascii编码转化成二进制数据，然后再对照<code>base64</code>编码，将二进制数据映射到base64字符上<br><img src="https://upload-images.jianshu.io/upload_images/422094-a807f9a4a0d9132f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="base64后面为什么会有等号"><a href="#base64后面为什么会有等号" class="headerlink" title="base64后面为什么会有等号(=)?"></a>base64后面为什么会有等号(=)?</h2><p>Base64编码会把3字节的二进制数据编码为4字节的文本数据，长度增加为原来的4/3。如果要编码的二进制数据不是3的倍数，最后会剩下1个或2个字节怎么办？<br>此时，需在原数据后面添加1个或2个零值字节，使其字节数是3的倍数。然后，在编码后的字符串后面添加1个或2个等号“=”，表示所添加的零值字节数。解码的时候，会自动去掉.</p><h2 id="base64优缺点"><a href="#base64优缺点" class="headerlink" title="base64优缺点"></a>base64优缺点</h2><p>优点：可以将二进制数据转换成可打印字符，方便传输数据；对数据进行简单的加密，肉眼安全。<br>缺点：内容编码后的体积会变大，编码和解码需要额外的工作量。</p><blockquote><p>它的使用场景有很多，比如将图片等资源文件以Base64编码形式直接放于代码中，使用的时候反Base64后转换成Image对象使用；有些文本协议不支持不可见字符的传递，只能转换成可见字符来传递信息。有时在一些特殊的场合，大多数消息是纯文本的，偶尔需要用这条纯文本通道传一张图片之类的情况发生的时候，就会用到Base64，比如多功能Internet 邮件扩充服务（MIME）就是用Base64对邮件的附件进行编码的。</p></blockquote><h1 id="base58"><a href="#base58" class="headerlink" title="base58"></a>base58</h1><h2 id="base58介绍"><a href="#base58介绍" class="headerlink" title="base58介绍"></a>base58介绍</h2><p>和通常base64编码一样，base58编码的作用也是将非可视字符可视化（ASCII化）</p><h2 id="和base64的区别"><a href="#和base64的区别" class="headerlink" title="和base64的区别"></a>和base64的区别</h2><p>不同的是base58编码去掉了几个看起来会产生歧义的字符，如 0 (零), O (大写字母O), I (大写的字母i) and l (小写的字母L) ，和几个影响双击选择的字符，如/, +。结果字符集正好58个字符(包括9个数字，24个大写字母，25个小写字母)</p><p>而且因为58 不是2的整次幂，所以没有使用类似base64编码中使用直接截取3个字符转4个字符（3<em>8=4</em>6 , 2的6次方刚好64）的方法进行转换，而是采用我们数学上经常使用的进制转换方法——辗转相除法（本质上，base64编码是64进制，base58是58进制）</p><h2 id="base58表"><a href="#base58表" class="headerlink" title="base58表"></a>base58表</h2><p><img src="https://upload-images.jianshu.io/upload_images/422094-6c30172aa992818a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>也就是字符1代表0，字符2代表1,字符3代表2…字符z代表57。然后回一下辗转相除法。</p><p>如要将1234转换为58进制；</p><p>第一步：1234除于58，商21，余数为16，查表得H</p><p>第二步：21除于58，商0，余数为21，查表得N</p><p>所以得到base58编码为：NH</p><h1 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h1><p>写代码时，可以直接跳入到<code>base64</code>和<code>base58</code>的<code>Encode()</code>和<code>Decode()</code>代码中看源码实现。</p>]]></content>
      
      
      <categories>
          
          <category> computer </category>
          
          <category> base编码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> base64 </tag>
            
            <tag> base58 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从Dart看js中的async和await</title>
      <link href="/2019/02/13/js-2019-02-13-%E4%BB%8EDart%E7%9C%8Bjs%E4%B8%AD%E7%9A%84async%E5%92%8Cawait/"/>
      <url>/2019/02/13/js-2019-02-13-%E4%BB%8EDart%E7%9C%8Bjs%E4%B8%AD%E7%9A%84async%E5%92%8Cawait/</url>
      
        <content type="html"><![CDATA[<p>今天看Dart的时候，看到下面的解释<br>原文地址：<a href="https://juejin.im/post/5b5005866fb9a04fea589561#heading-9" target="_blank" rel="noopener">https://juejin.im/post/5b5005866fb9a04fea589561#heading-9</a></p><p>Dart提供了类似ES7中的async await等异步操作，这种异步操作在Flutter开发中会经常遇到，比如网络或其他IO操作，文件选择等都需要用到异步的知识。<br>async和await往往是成对出现的，如果一个方法中有耗时的操作，你需要将这个方法设置成async，并给其中的耗时操作加上await关键字，如果这个方法有返回值，你需要将返回值塞到Future中并返回，如下代码所示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Future checkVersion() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> version = <span class="keyword">await</span> lookUpVersion();</span><br><span class="line">  <span class="comment">// Do something with version</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的代码使用Dart从网络获取数据并打印出来：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:http/http.dart'</span> <span class="keyword">as</span> http;</span><br><span class="line"></span><br><span class="line">Future&lt;<span class="built_in">String</span>&gt; getNetData() <span class="keyword">async</span>&#123;</span><br><span class="line">  http.Response res = <span class="keyword">await</span> http.<span class="keyword">get</span>(<span class="string">"http://www.baidu.com"</span>);</span><br><span class="line">  <span class="keyword">return</span> res.body;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  getNetData().then((str) &#123;</span><br><span class="line">    <span class="built_in">print</span>(str);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><p>既然<code>getNetData</code>方法中使用了<code>await</code>,为什么后面调用的时候还要使用<code>.then((){})</code> ?<br>我觉得是可以这样调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">  var res = getNetData();</span><br><span class="line">  print(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>大远解释<br>如果这样的话，会先<code>print</code>打印，打印出来为空。自己想打印的没有打印。<br>因为函数中的<code>await</code>，只能保证函数中包含<code>await</code>的代码和下它下一句代码之间是顺序执行的。其他的并不会影响到。<br>如果你在<code>getNetData</code>函数中，后面要使用res，<code>await</code>就可以保证函数内部等待<code>http.get</code>到结果后再执行。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> async\await </category>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dart </tag>
            
            <tag> js </tag>
            
            <tag> async\await </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>btcd的p2p网络（2）-连接connMgr</title>
      <link href="/2019/01/28/%E6%AF%94%E7%89%B9%E5%B8%81%E7%B3%BB-btcd-2019-01-28-btcd%E7%9A%84p2p%E7%BD%91%E7%BB%9C%EF%BC%882%EF%BC%89-%E8%BF%9E%E6%8E%A5connMgr/"/>
      <url>/2019/01/28/%E6%AF%94%E7%89%B9%E5%B8%81%E7%B3%BB-btcd-2019-01-28-btcd%E7%9A%84p2p%E7%BD%91%E7%BB%9C%EF%BC%882%EF%BC%89-%E8%BF%9E%E6%8E%A5connMgr/</url>
      
        <content type="html"><![CDATA[<p>p2p网络从底层到上层可以分为3层，<strong>地址</strong> <strong>连接</strong> <strong>节点</strong>，每一层都有自己的功能<br><em>声明：文章代码和源码有不一致地方</em><br>这篇文章简单记录下连接conn</p><h1 id="三个主要的结构体"><a href="#三个主要的结构体" class="headerlink" title="三个主要的结构体"></a>三个主要的结构体</h1><p>1、连接管理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// ConnManager providers a manager to handle network connections.</span><br><span class="line">type ConnManager struct &#123;</span><br><span class="line">// the following variables must only be used atomically</span><br><span class="line">// 记录自己主动连接其他节点的连接数量</span><br><span class="line">connReqCount uint64</span><br><span class="line">// 标识connmgr已经启动</span><br><span class="line">start int32</span><br><span class="line">// 标识connmgr已经结束</span><br><span class="line">stop int32</span><br><span class="line"></span><br><span class="line">// 设定相关的配置</span><br><span class="line">cfg Config</span><br><span class="line">// 用于同步connmgr的退出状态，调用方可以阻塞等待connmgr的工作协程退出</span><br><span class="line">wg sync.WaitGroup</span><br><span class="line">// 某个连接失败后，connmgr尝试选择新的peer地址连接的总次数</span><br><span class="line">failedAttempts uint64</span><br><span class="line">// 用于与connmgr工作协程通信的管道</span><br><span class="line">requests chan interface&#123;&#125;</span><br><span class="line">// 用于通知工作协程退出</span><br><span class="line">quit chan struct&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2、Config，配置参数<br>其实就是<code>connmgr</code>配置，本身就是<code>ConnManager</code>结构体的一个字段:<code>cfg</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// Config holds the configuration options related to the connection manager.</span><br><span class="line">type Config struct &#123;</span><br><span class="line">// Listeners define a slice of listeners for which the connection manager</span><br><span class="line">// will take ownership of(取得所有权) and accept connections. when a connection</span><br><span class="line">// is accepted,the OnAccept handler will be invoked with the connection. since</span><br><span class="line">// the connection manager takes ownership of these listeners,they will be closed</span><br><span class="line">// when the connection manager is stoped.</span><br><span class="line"></span><br><span class="line">// this field will not have any effect if the onAccept field is not also specified.</span><br><span class="line">// It may be nil if the caller does not wish to listen for</span><br><span class="line">// incoming connection</span><br><span class="line"></span><br><span class="line">Listeners []net.Listener //节点上所有等待外部连接的监听点;</span><br><span class="line">// OnAccept is a callback that is fired when an inbound connection is</span><br><span class="line">// accepted.  It is the caller&apos;s responsibility(责任、义务) to close the connection.</span><br><span class="line">// Failure to close the connection will result in the connection manager</span><br><span class="line">// believing the connection is still active and thus have undesirable</span><br><span class="line">// side effects such as still counting toward maximum connection limits.</span><br><span class="line">//</span><br><span class="line">// This field will not have any effect if the Listeners field is not</span><br><span class="line">// also specified since there couldn&apos;t possibly be any accepted</span><br><span class="line">// connections in that case.</span><br><span class="line">OnAccept func(net.Conn) // 节点应答并接受外部连接后的回调函数</span><br><span class="line">// TargetOutbound is the number of outbound network connections to</span><br><span class="line">// maintain. Defaults to 8.</span><br><span class="line">TargetOutbound uint32 // 节点主动向外连接peer的最大个数</span><br><span class="line">// RetryDuration is the duration to wait before retrying connection</span><br><span class="line">// requests. Defaults to 5s.</span><br><span class="line">RetryDuration time.Duration // 连接失败后发起重连的等待时间</span><br><span class="line">// OnConnection is a callback that is fired when a new outbound</span><br><span class="line">// connection is established.</span><br><span class="line">OnConnection func(*ConnReq, net.Conn) // 连接建立成功后的回调函数</span><br><span class="line">// OnDisconnection is a callback that is fired when an outbound</span><br><span class="line">// connection is disconnected.</span><br><span class="line">OnDisconnection func(*ConnReq) // 连接关闭后的回调函数</span><br><span class="line">// GetNewAddress is a way to get an address to make a network connection</span><br><span class="line">// to.  If nil, no new connections will be made automatically.</span><br><span class="line">// 连接失败后，ConnMgr可能会选择新的peer地址进行连接</span><br><span class="line">// GetNewAddress函数提供了获取新的peer地址的方法，它最终会调用addrManager中</span><br><span class="line">// 的GetAddress()来分配新地址。</span><br><span class="line">GetNewAddress func() (net.Addr, error)</span><br><span class="line">// Dial connects to the address on the named network.It cannot be nil.</span><br><span class="line">// 定义建立TCP连接的方式，是直接连接还是通过代理连接。</span><br><span class="line">Dial func(net.Addr) (net.Conn, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3、ConnReq 描述了一个连接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// ConnReq is the connection request to a network address. If permanent, the</span><br><span class="line">// connection will be retried on disconnection.</span><br><span class="line">// ConnReq 描述了一个连接</span><br><span class="line">type ConnReq struct &#123;</span><br><span class="line">// The following variables must only be used atomically.</span><br><span class="line">// 连接的序号，用于索引</span><br><span class="line">id uint64</span><br><span class="line">// 连接的目的地址</span><br><span class="line">Addr      net.Addr</span><br><span class="line">// 标识是否与Peer保持永久连接，如果为true，</span><br><span class="line">// 则连接失败后，继续尝试与该Peer连接，而不是选择新的Peer地址重新连接</span><br><span class="line">Permanent bool</span><br><span class="line">// 连接成功后，真实的net.Conn对象;</span><br><span class="line">conn       net.Conn</span><br><span class="line">// 连接的状态，有ConnPending、ConnEstablished、ConnDisconnected及ConnFailed等;</span><br><span class="line">state      ConnState</span><br><span class="line">// stateMtx: 保护state状态的读写锁;</span><br><span class="line">stateMtx   sync.RWMutex</span><br><span class="line">//retryCount: 如果Permanent为true，retryCount记录该连接重复重连的次数;</span><br><span class="line">retryCount uint32</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结合起来说，就是连接管理器<code>connmgr</code>按照自身的配置<code>config</code>，管理着一些连接<code>connReq</code></p><h1 id="启动ConnMgr"><a href="#启动ConnMgr" class="headerlink" title="启动ConnMgr"></a>启动ConnMgr</h1><p>我们先看<code>start()</code>函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// Start: launches(发起、发动)the connection manager and begins conecting to the network.</span><br><span class="line">func (cm *ConnManager) Start() &#123;</span><br><span class="line">// already started ?</span><br><span class="line">if atomic.AddInt32(&amp;cm.start, 1) != 1 &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">log.Trace(&quot;Connection manager started&quot;)</span><br><span class="line">cm.wg.Add(1)</span><br><span class="line">// 启动工作协程</span><br><span class="line">go cm.connHandler()</span><br><span class="line">// Start all the listeners so long as the caller requested</span><br><span class="line">// them and provided a callback to be invoked when connections are accepted.</span><br><span class="line">if cm.cfg.OnAccept != nil &#123;</span><br><span class="line">for _, listenr := range cm.cfg.Listeners &#123;</span><br><span class="line">cm.wg.Add(1)</span><br><span class="line">// 启动监听协程listenHandler，等待其他节点连接;</span><br><span class="line">go cm.listenHandler(listenr)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 启动建立连接的协程，选择Peer地址并主动连接;</span><br><span class="line">for i := atomic.LoadUint64(&amp;cm.connReqCount); i &lt; uint64(cm.cfg.TargetOutbound); i++ &#123;</span><br><span class="line">go cm.NewConnReq()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>主要是启动工作协程<code>cm.connHandler()</code>,<br>然后一方面监听其他节点的连接，<code>go cm.listenHandler(listenr)</code>这里面做的事情就是我们普通的<code>tcp</code>地址监听。<br>一方面主动去连接其他的节点: <code>cm.NewConnReq()</code><br>动态选择Peer并发起连接的过程就是在NewConnReq()中实现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// NewConnReq creates a new connection request and connects to the</span><br><span class="line">// corresponding(对应的) address.</span><br><span class="line">// 创建一个连接请求，然后连接对应的地址</span><br><span class="line">func (cm *ConnManager) NewConnReq() &#123;</span><br><span class="line">if atomic.LoadInt32(&amp;cm.stop) != 0 &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">if cm.cfg.GetNewAddress == nil &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">c := &amp;ConnReq&#123;&#125;</span><br><span class="line">atomic.StoreUint64(&amp;c.id, atomic.AddUint64(&amp;cm.connReqCount, 1))</span><br><span class="line">// Submit a request of a pending connection attempt to the connection</span><br><span class="line">// manager. By registering the id before the connection is even established,</span><br><span class="line">// we&apos;ll be able to later cancel the connection via the Remove method.</span><br><span class="line">done := make(chan struct&#123;&#125;)</span><br><span class="line">select &#123;</span><br><span class="line">case cm.requests &lt;- registerPending&#123;c, done&#125;:</span><br><span class="line">case &lt;-cm.quit:</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// wait for the registration to successfully add the pending conn req</span><br><span class="line">// to the conn manager&apos;s internal state.</span><br><span class="line">select &#123;</span><br><span class="line">case &lt;-done:</span><br><span class="line">case &lt;-cm.quit:</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">addr,err := cm.cfg.GetNewAddress()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">select &#123;</span><br><span class="line">case cm.requests &lt;- handleFailed&#123;c, err&#125;:</span><br><span class="line">case &lt;-cm.quit:</span><br><span class="line">&#125;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">c.Addr = addr</span><br><span class="line">cm.Connect(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先构造一个<code>ConnReq</code>:<code>c := &amp;ConnReq{}</code>,然后生成<code>registerPending{c, done}</code>,<br>把<code>registerPending</code>写入到connmgr的通道<code>case cm.requests &lt;- registerPending{c, done}</code></p><p>这里的<code>registerPending</code>结构体中还有一个通道<code>done</code>,<code>cm.requests</code>这个通道的另一端肯定有人会从里面读数据，处理完后会通过通道<code>done</code>返回信息。下面的<code>case &lt;-done:</code>就是在等待返回的信息。<br>谁在通道的另外一头读呢？<code>go cm.connHandler()</code>,下面这个图就是他们工作概况<br><img src="https://upload-images.jianshu.io/upload_images/422094-ed63ff88b2e3bfe6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>cm.connHandler()从通道<code>requests</code>中接受信息，处理完后通过通道<code>done</code>返回。然后就可以<code>cm.cfg.GetNewAddress()</code>得到一个连接的地址（这里用到了<code>addrMgr</code>）,然后连接<code>cm.Connect(c)</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// Connection assigns an id and dials a connection to the address of the connection request</span><br><span class="line">func (cm *ConnManager) Connect(c *ConnReq)&#123;</span><br><span class="line">if atomic.LoadInt32(&amp;cm.stop) != 0&#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">// TODO 再次检查一遍，相当于重复了NewConnReq（）的工作</span><br><span class="line">log.Debugf(&quot;Attempting to connect to %v&quot;, c)</span><br><span class="line">conn,err := cm.cfg.Dial(c.Addr)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">select &#123;</span><br><span class="line">case cm.requests &lt;- handleFailed&#123;c, err&#125;:</span><br><span class="line">case &lt;-cm.quit:</span><br><span class="line">&#125;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">select &#123;</span><br><span class="line">case cm.requests &lt;- handleConnected&#123;c, conn&#125;:</span><br><span class="line">case &lt;-cm.quit:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>连接主要就是这句代码<code>conn,err := cm.cfg.Dial(c.Addr)</code>,这个<code>Dial</code>就是在普通的<code>tcp</code>连接外包了一层，让我们有个选择，比如可以通过<em>代理</em>进行连接。</p><p>如果连接失败，<code>cm.requests &lt;- handleFailed{c, err}</code>；如果连接成功，<code>cm.requests &lt;- handleConnected{c, conn}</code>.<code>handleConnected{c, conn}:</code>和<code>handleFailed{c, err}:</code>这两个结构体都被构建，并且发送到<code>cm.requests</code></p><p>有连接就有断开<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func (cm *ConnManager) Disconnect(id uint64) &#123;</span><br><span class="line">if atomic.LoadInt32(&amp;cm.stop) != 0 &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">select &#123;</span><br><span class="line">case cm.requests &lt;- handleDisconnected&#123;id, true&#125;:</span><br><span class="line">case &lt;-cm.quit:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可<code>connect</code>也差不多，都是向<code>cm.requests</code>发了一个请求。</p><blockquote><p>看来，连接或者断开连接的主要处理逻辑在connHandler中，我们来看看它的实现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">// connHandler handles all connection related requests.  It must be run as a</span><br><span class="line">// goroutine.</span><br><span class="line">//</span><br><span class="line">// The connection handler makes sure that we maintain a pool of active outbound</span><br><span class="line">// connections so that we remain connected to the network.  Connection requests</span><br><span class="line">// are processed and mapped by their assigned ids.</span><br><span class="line">func (cm *ConnManager) connHandler() &#123;</span><br><span class="line">// pending holds all registered conn requests that hava yet to succeed.</span><br><span class="line">var pending = make(map[uint64]*ConnReq)</span><br><span class="line">// conns represents the set of all actively connected peers.</span><br><span class="line">var conns = make(map[uint64]*ConnReq, cm.cfg.TargetOutbound) // make map时，size可以省略，当你知道大小时，最好加上</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">for &#123;</span><br><span class="line">select &#123;</span><br><span class="line">case req := &lt;- cm.requests:</span><br><span class="line">switch msg:=req.(type) &#123;</span><br><span class="line">case registerPending:</span><br><span class="line">// TODO</span><br><span class="line">case handleConnected:</span><br><span class="line">connReq := msg.c</span><br><span class="line"></span><br><span class="line">if _, ok := pending[connReq.id]; !ok &#123;</span><br><span class="line">if msg.conn != nil &#123;</span><br><span class="line">msg.conn.Close()</span><br><span class="line">&#125;</span><br><span class="line">log.Debugf(&quot;Ignoring connection for &quot;+</span><br><span class="line">&quot;canceled connreq=%v&quot;, connReq)</span><br><span class="line">continue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">connReq.updateState(ConnEstablished)</span><br><span class="line">connReq.conn = msg.conn</span><br><span class="line">conns[connReq.id] = connReq</span><br><span class="line">log.Debugf(&quot;Connected to %v&quot;, connReq)</span><br><span class="line">connReq.retryCount = 0</span><br><span class="line">cm.failedAttempts = 0</span><br><span class="line"></span><br><span class="line">delete(pending, connReq.id)</span><br><span class="line"></span><br><span class="line">if cm.cfg.OnConnection != nil &#123;</span><br><span class="line">go cm.cfg.OnConnection(connReq, msg.conn)</span><br><span class="line">&#125;</span><br><span class="line">case handleDisconnected:</span><br><span class="line">// TODO</span><br><span class="line">case handleFailed:</span><br><span class="line">// TODO</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">case &lt;-cm.quit:</span><br><span class="line">break out</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cm.wg.Done()</span><br><span class="line">log.Trace(&quot;Connection handler done&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>在这里不停的处理<code>cm.requests</code>通道中的信息。我们看下连接成功的处理：<br>首先创建了两个变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// pending holds all registered conn requests that hava yet to succeed.</span><br><span class="line">var pending = make(map[uint64]*ConnReq)</span><br><span class="line">// conns represents the set of all actively connected peers.</span><br><span class="line">var conns = make(map[uint64]*ConnReq, cm.cfg.TargetOutbound) // make map时，size可以省略，当你知道大小时，最好加上</span><br></pre></td></tr></table></figure></p><p>连接成功后</p><ol><li>在<code>map变量 pending</code>中找有没有这个连接请求，如果没有则表明这不是我们要的连接。断开</li><li>更新<code>connReq</code>的状态，然后添加到<code>map conns</code>中</li><li>调用<code>go cm.cfg.OnConnection(connReq, msg.conn)</code></li></ol><p>两个peer之间的连接conn，还需要考虑其他的很多方面。但是还好，到现在我们至少可以简单的创建一个连接了。</p><h2 id="至于连接成功后调用cm-cfg-OnConnection-要干什么，我们后面再分析了。"><a href="#至于连接成功后调用cm-cfg-OnConnection-要干什么，我们后面再分析了。" class="headerlink" title="至于连接成功后调用cm.cfg.OnConnection()要干什么，我们后面再分析了。"></a>至于连接成功后调用<code>cm.cfg.OnConnection()</code>要干什么，我们后面再分析了。</h2><p>参考<br><a href="https://www.jianshu.com/p/d6484e5710ad" target="_blank" rel="noopener">https://www.jianshu.com/p/d6484e5710ad</a></p>]]></content>
      
      
      <categories>
          
          <category> btcd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> btcd </tag>
            
            <tag> p2p </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>两张图看懂http和https</title>
      <link href="/2019/01/24/computer-network-2019-01-24-%E4%B8%A4%E5%BC%A0%E5%9B%BE%E7%9C%8B%E6%87%82http%E5%92%8Chttps/"/>
      <url>/2019/01/24/computer-network-2019-01-24-%E4%B8%A4%E5%BC%A0%E5%9B%BE%E7%9C%8B%E6%87%82http%E5%92%8Chttps/</url>
      
        <content type="html"><![CDATA[<h1 id="http和https"><a href="#http和https" class="headerlink" title="http和https"></a>http和https</h1><p>http访问过程<br><img src="https://upload-images.jianshu.io/upload_images/422094-4649bc330f6270db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>https访问过程<br><img src="https://upload-images.jianshu.io/upload_images/422094-8e74d012bfef0dac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>几点说明：</p><blockquote><p>服务器端返回证书和公开密钥，公开密钥作为证书的一部分而存在</p></blockquote><h1 id="Connection-keep-alive"><a href="#Connection-keep-alive" class="headerlink" title="Connection: keep-alive"></a>Connection: keep-alive</h1><p>http请求头中，有一个字段<code>Connection: keep-alive</code></p><p>释放连接TCP连接<br>若connection 模式为close，则服务器主动关闭TCP 连接，客户端被动关闭连接，释放TCP 连接;</p><p>若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</p><p>大远的话：一个连接必须两端配合，要不要保持连接必须两边商量着来。不能服务端已经关闭连接了，客户端还请求。</p><h1 id="有keepalive了，还要websocket干什么？"><a href="#有keepalive了，还要websocket干什么？" class="headerlink" title="有keepalive了，还要websocket干什么？"></a>有keepalive了，还要websocket干什么？</h1><p>websocket是全双工通信，意味着服务端和客户端是平等的，都可以给对方发信息<br>http中keepalive只能保持一段时间，而且服务端是不能主动给客户端发信息的。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> https </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>btcd的p2p网络（1）-地址addrMrg</title>
      <link href="/2019/01/23/%E6%AF%94%E7%89%B9%E5%B8%81%E7%B3%BB-btcd-2019-01-23-btcd%E7%9A%84p2p%E7%BD%91%E7%BB%9C%EF%BC%881%EF%BC%89-%E5%9C%B0%E5%9D%80addrMgr/"/>
      <url>/2019/01/23/%E6%AF%94%E7%89%B9%E5%B8%81%E7%B3%BB-btcd-2019-01-23-btcd%E7%9A%84p2p%E7%BD%91%E7%BB%9C%EF%BC%881%EF%BC%89-%E5%9C%B0%E5%9D%80addrMgr/</url>
      
        <content type="html"><![CDATA[<p>p2p网络从底层到上层可以分为3层，<strong>地址</strong> <strong>连接</strong> <strong>节点</strong>，每一层都有自己的功能。<br>这一节主要介绍地址<br><em>声明：文章代码和源码有不一致地方</em></p><h1 id="btcd的p2p网络之地址"><a href="#btcd的p2p网络之地址" class="headerlink" title="btcd的p2p网络之地址"></a>btcd的p2p网络之地址</h1><p>主要有四个结构体,两两对应</p><blockquote><p>AddrManager<br>serializedAddrManager</p></blockquote><blockquote><p>KnownAddress<br>serializedKnownAddress</p></blockquote><p>我们先看<code>peer.json</code>中的内容,这个就是和<code>serializedAddrManager</code>的内容对应的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//peers.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;Version&quot;: 1,</span><br><span class="line">    &quot;Key&quot;: [233,19,87,131,183,155,......,231,78,82,150,10,102],</span><br><span class="line">    &quot;Addresses&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;Addr&quot;: &quot;109.157.120.169:8333&quot;,</span><br><span class="line">            &quot;Src&quot;: &quot;104.172.5.90:8333&quot;,</span><br><span class="line">            &quot;Attempts&quot;: 0,</span><br><span class="line">            &quot;TimeStamp&quot;: 1514967959,</span><br><span class="line">            &quot;LastAttempt&quot;: -62135596800,</span><br><span class="line">            &quot;LastSuccess&quot;: -62135596800</span><br><span class="line">        &#125;,</span><br><span class="line">        ......</span><br><span class="line">    ],</span><br><span class="line">    &quot;NewBuckets&quot;: [</span><br><span class="line">        [</span><br><span class="line">            &quot;[2001:0:9d38:78cf:3cb1:bb2:ab6f:e8b4]:8333&quot;,</span><br><span class="line">            &quot;196.209.239.229:8333&quot;,</span><br><span class="line">            ......</span><br><span class="line">            &quot;65.130.177.198:8333&quot;</span><br><span class="line">        ],</span><br><span class="line">        ......</span><br><span class="line">        [</span><br><span class="line">            &quot;125.227.159.115:8333&quot;,</span><br><span class="line">            ......</span><br><span class="line">            &quot;alhlegtjkdmbqsvt.onion:8333&quot;,</span><br><span class="line">            ......</span><br><span class="line">            &quot;79.250.188.226:8333&quot;</span><br><span class="line">        ]</span><br><span class="line">    ],</span><br><span class="line">    &quot;TriedBuckets&quot;: [</span><br><span class="line">        [</span><br><span class="line">            &quot;5.9.165.181:8333&quot;,</span><br><span class="line">            ......</span><br><span class="line">            &quot;5.9.17.24:8333&quot;</span><br><span class="line">        ],</span><br><span class="line">        [</span><br><span class="line">            &quot;95.79.50.90:8333&quot;,</span><br><span class="line">            ......</span><br><span class="line">            &quot;[2a02:c207:2008:9136::1]:8333&quot;</span><br><span class="line">        ]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="start"><a href="#start" class="headerlink" title="start()"></a>start()</h3><p>start()先从peer.json中加载，然后开启一个goroutine定期进行跟踪和添加地址。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func (a *AddrManager) Start()&#123;</span><br><span class="line">//alter stared ?</span><br><span class="line">if atomic.AddInt32(&amp;a.started,1) != 1&#123;</span><br><span class="line">log.Trace(&quot;AddrManager has stared&quot;)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">log.Trace(&quot;Starting address manager&quot;)</span><br><span class="line">// load peers we already know about from file</span><br><span class="line">// 从文件中加载peers</span><br><span class="line">a.loadPeers()</span><br><span class="line"></span><br><span class="line">// start the address ticker to save addresses periodically（定期）.</span><br><span class="line">a.wg.Add(1) // 在下面的goroutine中，a.wg.Done()之后，start才会结束</span><br><span class="line">go a.addressHandler()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们再看<code>a.loadPeers()</code>,主要是调用<code>deserializePeers</code>,就是把peer.json中的文件反序列化。主要是把<code>Addresses`</code>NewBuckets<code></code>TriedBuckets<code>,解析到</code>AddrManager<code>的</code>addrIndex<code></code>addrNew<code></code>addrTried`<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">func (a *AddrManager) deserializePeers(filePath string) error &#123;</span><br><span class="line">_, err := os.Stat(filePath)</span><br><span class="line">if os.IsNotExist(err) &#123;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line">r, err := os.Open(filePath)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return fmt.Errorf(&quot;opening file:%v error:%v&quot;, filePath, err)</span><br><span class="line">&#125;</span><br><span class="line">defer r.Close()</span><br><span class="line"></span><br><span class="line">var sam serializedAddrManager</span><br><span class="line">dec := json.NewDecoder(r)</span><br><span class="line">err = dec.Decode(&amp;sam)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return fmt.Errorf(&quot;error reading %s: %v&quot;, filePath, err)</span><br><span class="line">&#125;</span><br><span class="line">// 检查版本</span><br><span class="line">if sam.Version != serialisationVersion &#123;</span><br><span class="line">return fmt.Errorf(&quot;unknown version %v in serialized &quot;+</span><br><span class="line">&quot;addrmanager&quot;, sam.Version)</span><br><span class="line">&#125;</span><br><span class="line">copy(a.key[:], sam.Key[:])</span><br><span class="line">// 先解析Addresses</span><br><span class="line">for _, v := range sam.Addresses &#123;</span><br><span class="line">ka := new(KnownAddress)</span><br><span class="line">ka.na, err = a.DeserializeNetAddress(v.Addr)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return fmt.Errorf(&quot;failed to deserialize netaddress &quot;+</span><br><span class="line">&quot;%s: %v&quot;, v.Addr, err)</span><br><span class="line">&#125;</span><br><span class="line">ka.srcAddr, err = a.DeserializeNetAddress(v.Src)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return fmt.Errorf(&quot;failed to deserialize netaddress &quot;+</span><br><span class="line">&quot;%s: %v&quot;, v.Src, err)</span><br><span class="line">&#125;</span><br><span class="line">ka.attempts = v.Attempts</span><br><span class="line">ka.lastattempt = time.Unix(v.LastAttempt, 0)</span><br><span class="line">ka.lastsuccess = time.Unix(v.LastAttempt, 0)</span><br><span class="line">// 遍历sam.Addresses中的每一项，然后辨析成一个KnownAddress后，</span><br><span class="line">// 添加到addrManager.addrIndex,是一个map</span><br><span class="line">a.addrIndex[NetAddressKey(ka.na)] = ka</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 遍历解析Newbuckets</span><br><span class="line">for i := range sam.NewBuckets &#123;</span><br><span class="line">for _, val := range sam.NewBuckets[i] &#123;</span><br><span class="line">// 先看看addrIndex中有没有这个ip:port</span><br><span class="line">ka, ok := a.addrIndex[val]</span><br><span class="line">if !ok &#123;</span><br><span class="line">return fmt.Errorf(&quot;newbucket contains %s but &quot;+</span><br><span class="line">&quot;none in address list&quot;, val)</span><br><span class="line">&#125;</span><br><span class="line">// addrIndex中已经有了</span><br><span class="line">if ka.refs == 0 &#123;</span><br><span class="line">a.nNew ++</span><br><span class="line">&#125;</span><br><span class="line">ka.refs ++</span><br><span class="line">a.addrNew[i][val] = ka</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 遍历解析TriedBuckets</span><br><span class="line">for i := range sam.TriedBuckets &#123;</span><br><span class="line">for _, val := range sam.TriedBuckets[i] &#123;</span><br><span class="line">ka, ok := a.addrIndex[val]</span><br><span class="line">if !ok &#123;</span><br><span class="line">return fmt.Errorf(&quot;Newbucket contains %s but &quot;+</span><br><span class="line">&quot;none in address list&quot;, val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ka.tried = true</span><br><span class="line">a.nTried++</span><br><span class="line">// 一个bucket到这里就成了一个数组</span><br><span class="line">a.addrTried[i].PushBack(ka)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 检查,保证一个地址要么在 NewBuckets中，要么在TriedBuckets</span><br><span class="line">for k, v := range a.addrIndex &#123;</span><br><span class="line">if v.refs == 0 &amp;&amp; !v.tried &#123;</span><br><span class="line">return fmt.Errorf(&quot;address %s after serialisation &quot;+</span><br><span class="line">&quot;with no references&quot;, k)</span><br><span class="line">&#125;</span><br><span class="line">if v.refs &gt; 0 &amp;&amp; v.tried &#123;</span><br><span class="line">return fmt.Errorf(&quot;address %s after serialisation &quot;+</span><br><span class="line">&quot;which is both new and tried!&quot;, k)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>然后调用a.addressHandler()</strong>，主要逻辑就是定期保存地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// addressHandler is the main handler for the address manager.  It must be run</span><br><span class="line">// as a goroutine.</span><br><span class="line">func (a *AddrManager) addressHandler() &#123;</span><br><span class="line">dumpAddressTicker := time.NewTicker(dumpAddressInterval)</span><br><span class="line">defer dumpAddressTicker.Stop()</span><br><span class="line">out:</span><br><span class="line">for &#123;</span><br><span class="line">select &#123;</span><br><span class="line">case &lt;-dumpAddressTicker.C:</span><br><span class="line">a.savePeers()</span><br><span class="line">case &lt;-a.quit:</span><br><span class="line">break out</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a.savePeers()</span><br><span class="line">a.wg.Done()  // start方法中已经有wg.Add(1)在等着了</span><br><span class="line">log.Trace(&quot;Address handler done&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>a.savePeers(),大家可以查看源码</p><h2 id="updateAddress"><a href="#updateAddress" class="headerlink" title="updateAddress"></a>updateAddress</h2><p>节点直接交换getaddr和addr消息时，就会收到addr信息，调用<code>AddAddress()</code>是实际上都是调用<code>updateAddress</code><br>如果我们已经有了，就进行一些修改<br>如果我们没有，就添加，如果满了的话，就把老的给移除掉</p><h2 id="NewBucket到TriedBucket"><a href="#NewBucket到TriedBucket" class="headerlink" title="NewBucket到TriedBucket"></a>NewBucket到TriedBucket</h2><p>在节点获取地址，并建立peer连接成功后，会调用Good方法。就是说这个地址是好的，可以从NewBucket移到TriedBucket了。</p><h2 id="GetAddress"><a href="#GetAddress" class="headerlink" title="GetAddress"></a>GetAddress</h2><p>这个是供外面获取地址的方法</p><p>按照50%的记录随机从NewBucket或者TriedBucket中选择。随机选择bucket后，从中随机选择地址。选择出来的地址要判断一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">randval := a.rand.Intn(large)</span><br><span class="line">if float64(randval) &lt; (factor * ka.chance() * float64(large)) &#123;</span><br><span class="line">log.Tracef(&quot;Selected %v from new bucket&quot;,NetAddressKey(ka.na))</span><br><span class="line">return ka</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>决定是不是用这个选中地址，主要是由factor和ka.chance()决定。<br>facket依次递增<br>而ka.chance()则和这个地址的其他属性密切相关。比如上次尝试到现在间隔，失败的次数。</p><h2 id="我们完全可以去除这个包，设置几个固定的地址，但是这几个地址不能用后，我们的节点也就没法同步了。就不是p2p了。搞这么复杂，主要还是为了防止攻击。"><a href="#我们完全可以去除这个包，设置几个固定的地址，但是这几个地址不能用后，我们的节点也就没法同步了。就不是p2p了。搞这么复杂，主要还是为了防止攻击。" class="headerlink" title="我们完全可以去除这个包，设置几个固定的地址，但是这几个地址不能用后，我们的节点也就没法同步了。就不是p2p了。搞这么复杂，主要还是为了防止攻击。"></a>我们完全可以去除这个包，设置几个固定的地址，但是这几个地址不能用后，我们的节点也就没法同步了。就不是p2p了。搞这么复杂，主要还是为了防止攻击。</h2><p>AddLocalAddress<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// AddLocalAddress adds na to the list of known local addresses to advertise with the given priority.</span><br><span class="line">// 地址会先加到AddrManager.localAddresses</span><br><span class="line">func (a *AddrManager) AddLocalAddress(na *wire.NetAddress,priority AddressPriority)error&#123;</span><br><span class="line">// TODO 判断不是是公网路由</span><br><span class="line">a.lamtx.Lock()</span><br><span class="line">defer a.lamtx.Unlock()</span><br><span class="line">// 得到特定格式的ip：端口</span><br><span class="line">key := NetAddressKey(na)</span><br><span class="line">// 判断localAddresses有没有这个ip</span><br><span class="line">la,ok := a.localAddresses[key]</span><br><span class="line">if !ok || la.score &lt; priority&#123;</span><br><span class="line">if ok &#123;</span><br><span class="line">la.score = priority + 1</span><br><span class="line">&#125;else&#123;</span><br><span class="line">a.localAddresses[key] = &amp;localAddress&#123;</span><br><span class="line">na:na,</span><br><span class="line">score:priority,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> btcd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> btcd </tag>
            
            <tag> p2p </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>docker基本使用</title>
      <link href="/2019/01/18/%E8%BF%90%E7%BB%B4-docker-2019-01-18-docker%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/01/18/%E8%BF%90%E7%BB%B4-docker-2019-01-18-docker%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ubuntu16.04-jenkins-golang部署</title>
      <link href="/2019/01/16/%E8%BF%90%E7%BB%B4-cicd-2019-01-16-ubuntu16-04-jenkins-golang%E9%83%A8%E7%BD%B2/"/>
      <url>/2019/01/16/%E8%BF%90%E7%BB%B4-cicd-2019-01-16-ubuntu16-04-jenkins-golang%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="jenkins安装"><a href="#jenkins安装" class="headerlink" title="jenkins安装"></a>jenkins安装</h1><h2 id="首先安装java"><a href="#首先安装java" class="headerlink" title="首先安装java"></a>首先安装java</h2><p><strong>方式一</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:openjdk-r/ppa</span><br><span class="line"># 需要回车一下</span><br><span class="line">sudo apt-get update</span><br><span class="line">echo y|sudo apt-get install openjdk-8-jdk</span><br></pre></td></tr></table></figure></p><p><strong>方式二</strong><br>在官网下载对应版本<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a><br>解压到当前位置<code>tar -zxvf jdk-8u151-linux-x64.tar.gz</code><br>移动到opt路径下<code>sudo mv jdk-8u151-linux-x64.tar.gz /opt/</code><br>编辑环境变量<br><code>vim ~/.bashrc</code><br>添加以下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/opt/jdk1.8.0_151</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jart</span><br></pre></td></tr></table></figure></p><p><code>source ~/.bashrc</code><br>检测<br><code>java -version</code></p><h2 id="安装jenkins"><a href="#安装jenkins" class="headerlink" title="安装jenkins"></a>安装jenkins</h2><p>四部<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget -q -O - https://pkg.jenkins.io/debian/jenkins-ci.org.key | sudo apt-key add -</span><br><span class="line">sudo sh -c &apos;echo deb http://pkg.jenkins.io/debian-stable binary/ &gt; /etc/apt/sources.list.d/jenkins.list&apos;</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install jenkins</span><br></pre></td></tr></table></figure></p><blockquote><p>如果报错如下</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/422094-56589e82934b7e0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>解决办法<br>创建一条软连接<br><code>sudo ln -s /opt/jdk1.8.0_201/bin/java  /usr/bin/java</code><br><code>/opt/jdk1.8.0_201/bin/java</code>根据自己的安装目录确定</p><h1 id="jenkins使用"><a href="#jenkins使用" class="headerlink" title="jenkins使用"></a>jenkins使用</h1><h2 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h2><blockquote><p>安装目录/var/lib/jenkins<br>配置文件 /etc/sysconfig/jenkins<br>日志目录 /var/log/jenkins</p></blockquote><p>登录<br> <code>http://ip:8080</code><br>初始密码：<br><code>cat /var/lib/jenkins/secrets/initialAdminPassword</code><br>安装推荐的插件<br>创建第一个管理员</p><p>// TODO 还没有和golang结合</p>]]></content>
      
      
      <categories>
          
          <category> golang学习 </category>
          
          <category> jenkins部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> jenkins </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>go 性能测试</title>
      <link href="/2019/01/12/golang-go-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
      <url>/2019/01/12/golang-go-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> golang学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 性能测试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>http.request中读取数据为空|multiple response.WriteHeader</title>
      <link href="/2019/01/12/golang-2019-03-09-http-request%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E4%B8%BA%E7%A9%BA%E3%80%81multiple-response-WriteHeader/"/>
      <url>/2019/01/12/golang-2019-03-09-http-request%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E4%B8%BA%E7%A9%BA%E3%80%81multiple-response-WriteHeader/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/gin-gonic/gin/issues/1295" target="_blank" rel="noopener">https://github.com/gin-gonic/gin/issues/1295</a></p><p><a href="https://stackoverflow.com/questions/32008680/gin-go-lang-how-to-use-context-request-body-and-retain-it" target="_blank" rel="noopener">https://stackoverflow.com/questions/32008680/gin-go-lang-how-to-use-context-request-body-and-retain-it</a></p><p><a href="https://justinas.org/writing-http-middleware-in-go" target="_blank" rel="noopener">https://justinas.org/writing-http-middleware-in-go</a></p><h1 id="http-request中数据为空"><a href="#http-request中数据为空" class="headerlink" title="http.request中数据为空"></a>http.request中数据为空</h1><blockquote><p>获取request中的数据，是通过r.body.如果看源码的话就会发现，r.body就是一个io.reader（ReadCloser）.<br>为空，主要是因为我们有一个中间件，中间件已经把r.body给读完了。</p></blockquote><p>解决办法，无非就是给r.body重庆赋值呗，中间件读到的内容都给还回去。</p><h1 id="multiple-response-WriteHeader"><a href="#multiple-response-WriteHeader" class="headerlink" title="multiple response.WriteHeader"></a>multiple response.WriteHeader</h1><p>可能1：我们再一个http handler中开了go routinue<br>可能2：没有go routinue，多次往responseWriter中写数据。</p>]]></content>
      
      
      <categories>
          
          <category> golang学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>go 格式化打印-utf-8编码规则</title>
      <link href="/2019/01/11/golang-2019-01-11-go-%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%89%93%E5%8D%B0/"/>
      <url>/2019/01/11/golang-2019-01-11-go-%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%89%93%E5%8D%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">byte</span> = <span class="string">'?'</span></span><br><span class="line">fmt.Println(s) <span class="comment">//63</span></span><br><span class="line"><span class="comment">//输出 2/8/10 进制格式</span></span><br><span class="line">fmt.Printf(<span class="string">"%b,%o,%d\n"</span>, s, s, s) <span class="comment">// 111111,77,63</span></span><br><span class="line"><span class="comment">// 以16进制输出字符串</span></span><br><span class="line">fmt.Printf(<span class="string">"%x\n"</span>, <span class="string">"hex this"</span>)</span><br><span class="line"><span class="comment">// 输出数值所表示的 Unicode 字符</span></span><br><span class="line">fmt.Printf(<span class="string">"%c\n"</span>, <span class="number">63</span>)</span><br><span class="line"><span class="comment">//输出数值所表示的 Unicode 字符（带单引号）。对于无法显示的字符，将输出其转义字符。</span></span><br><span class="line">fmt.Printf(<span class="string">"%q\n"</span>, <span class="number">63</span>)</span><br><span class="line"><span class="comment">//输出 Unicode 码点（例如 U+1234，等同于字符串 "U+%04X" 的显示结果）</span></span><br><span class="line">fmt.Printf(<span class="string">"%U\n"</span>, <span class="number">63</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在线编码转换<br><a href="http://tools.jb51.net/transcoding/unicode_chinese" target="_blank" rel="noopener">http://tools.jb51.net/transcoding/unicode_chinese</a></p><p>汉字字符集编码查询<br><a href="http://www.qqxiuzi.cn/bianma/zifuji.php" target="_blank" rel="noopener">http://www.qqxiuzi.cn/bianma/zifuji.php</a></p><p>在线进制转换<br><a href="https://tool.lu/hexconvert/" target="_blank" rel="noopener">https://tool.lu/hexconvert/</a></p><p>在线Unicode和UTF编码转换<br><a href="https://www.qqxiuzi.cn/bianma/Unicode-UTF.php" target="_blank" rel="noopener">https://www.qqxiuzi.cn/bianma/Unicode-UTF.php</a></p><h1 id="格式化打印结构体"><a href="#格式化打印结构体" class="headerlink" title="格式化打印结构体"></a>格式化打印结构体</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line">type Manager struct &#123;</span><br><span class="line">User</span><br><span class="line">Name string</span><br><span class="line">&#125;</span><br><span class="line">type User struct &#123;</span><br><span class="line">ID int</span><br><span class="line">Name string</span><br><span class="line">Age int</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">u := User&#123;123,&quot;xixiaofeng&quot;,27&#125;</span><br><span class="line">m := Manager&#123;User:u,Name:&quot;第一个组织&quot;&#125;</span><br><span class="line">t := reflect.TypeOf(m)</span><br><span class="line">fmt.Printf(&quot;%v&quot;,t.Field(0))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点就是最后这句话<code>fmt.Printf(&quot;%v&quot;,t.Field(0))</code>,<br>如果格式化是<code>%v</code>,打印出是<code>{User  main.User  0 [0] true}</code><br>但是我们有时候需要完整的打印出结构体，方便观察<br><code>fmt.Printf(&quot;%#v&quot;,t.Field(0))</code><br><code>reflect.StructField{Name:&quot;User&quot;, PkgPath:&quot;&quot;, Type:(*reflect.rtype)(0x4af3e0), Tag:&quot;&quot;, Offset:0x0, Index:[]int{0}, Anonymous:true}</code></p><h1 id="UTF-8编码规则"><a href="#UTF-8编码规则" class="headerlink" title="UTF-8编码规则"></a>UTF-8编码规则</h1><p><a href="https://blog.csdn.net/sandyen/article/details/1108168" target="_blank" rel="noopener">https://blog.csdn.net/sandyen/article/details/1108168</a></p><h2 id="编码示例"><a href="#编码示例" class="headerlink" title="编码示例"></a>编码示例</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">rune</span> = <span class="string">'好'</span></span><br><span class="line">fmt.Printf(<span class="string">"%d\n"</span>,s) <span class="comment">// 22909</span></span><br><span class="line">buf := bytes.NewBufferString(<span class="string">"hello"</span>)</span><br><span class="line">fmt.Println(buf.Bytes()) <span class="comment">// [104 101 108 108 111]</span></span><br><span class="line">buf.WriteRune(s)</span><br><span class="line">fmt.Println(buf.Bytes()) <span class="comment">// [104 101 108 108 111 229 165 189]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>什么<code>好</code>会写入三个字节？<code>[229 165 189]</code><br>我们先看看<code>好</code>的编码方式<br><a href="http://tool.oschina.net/hexconvert" target="_blank" rel="noopener">http://tool.oschina.net/hexconvert</a><br><img src="https://upload-images.jianshu.io/upload_images/422094-a380bff48c7d1454.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/422094-aa84a5a7241a387b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/422094-1d32dd953fed3401.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>将Unicode编码597D转化为UTF-8编码<br><img src="https://upload-images.jianshu.io/upload_images/422094-6f0fc8bd12aabcfa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>可以看到utf-8编码是<code>E5A58D</code>,这是十六进制的，我们转为为10进制<br><img src="https://upload-images.jianshu.io/upload_images/422094-b481aa21a9f83e7c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p>我们要的是字节数组，所以需要将<code>11100101 10100101 10111101</code>拆成字节，然后再转化成10进制显示。</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/422094-a782028f1cd84566.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/422094-34dbf9d09a1963bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/422094-d64c6272e4a10b65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> golang学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 格式化打印 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>go bytes.Buffer</title>
      <link href="/2019/01/10/golang-2019-01-10-go-bytes-Buffer/"/>
      <url>/2019/01/10/golang-2019-01-10-go-bytes-Buffer/</url>
      
        <content type="html"><![CDATA[<h1 id="Buffer-介绍"><a href="#Buffer-介绍" class="headerlink" title="Buffer 介绍"></a>Buffer 介绍</h1><p>Buffer 是 bytes 包中的一个 type Buffer struct{…}<br>A buffer is a variable-sized buffer of bytes with Read and Write methods. The zero value for Buffer is an empty buffer ready to use.<br>（是一个变长的 buffer，具有 Read 和Write 方法。 Buffer 的 零值 是一个 空的 buffer，但是可以使用）<br>Buffer 就像一个集装箱容器，可以存东西，取东西（存取数据）</p><h1 id="创建缓冲器"><a href="#创建缓冲器" class="headerlink" title="创建缓冲器"></a>创建缓冲器</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">buf1 := bytes.NewBufferString(<span class="string">"hello"</span>)</span><br><span class="line">buf2 := bytes.NewBuffer([]<span class="keyword">byte</span>(<span class="string">"hello"</span>))</span><br><span class="line">buf3 := bytes.NewBuffer([]<span class="keyword">byte</span>&#123;<span class="string">'h'</span>,<span class="string">'e'</span>,<span class="string">'l'</span>,<span class="string">'l'</span>,<span class="string">'o'</span>&#125;)</span><br><span class="line">fmt.Printf(<span class="string">"%v,%v,%v\n"</span>,buf1,buf2,buf3)</span><br><span class="line">fmt.Printf(<span class="string">"%v,%v,%v\n"</span>,buf1.Bytes(),buf2.Bytes(),buf3.Bytes())</span><br><span class="line"></span><br><span class="line">buf4 := bytes.NewBufferString(<span class="string">""</span>)</span><br><span class="line">buf5 := bytes.NewBuffer([]<span class="keyword">byte</span>&#123;&#125;)</span><br><span class="line">fmt.Println(buf4.Bytes(),buf5.Bytes())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello,hello,hello</span><br><span class="line">[104 101 108 108 111],[104 101 108 108 111],[104 101 108 108 111]</span><br><span class="line">[] []</span><br></pre></td></tr></table></figure></p><h1 id="写入到缓冲器"><a href="#写入到缓冲器" class="headerlink" title="写入到缓冲器"></a>写入到缓冲器</h1><p>buffer在new的时候是空的，也是可以直接Write的</p><h2 id="Write"><a href="#Write" class="headerlink" title="Write"></a>Write</h2><p><code>func (b *Buffer) Write(p []byte) (n int,err error)</code><br>func main() {<br>    s := []byte(“ world”)<br>    buf := bytes.NewBufferString(“hello”)<br>    fmt.Printf(“%v,%v\n”,buf.String(),buf.Bytes())<br>    buf.Write(s)<br>    fmt.Printf(“%v,%v\n”,buf.String(),buf.Bytes())<br>}<br>结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello,[104 101 108 108 111]</span><br><span class="line">hello world,[104 101 108 108 111 32 119 111 114 108 100]</span><br></pre></td></tr></table></figure></p><h2 id="WriteString"><a href="#WriteString" class="headerlink" title="WriteString"></a>WriteString</h2><p><code>func (b *Buffer) WriteString(s string)(n int,err error)</code><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="string">" world"</span></span><br><span class="line">buf := bytes.NewBufferString(<span class="string">"hello"</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%v,%v\n"</span>,buf.String(),buf.Bytes())</span><br><span class="line">buf.WriteString(s)</span><br><span class="line">fmt.Printf(<span class="string">"%v,%v\n"</span>,buf.String(),buf.Bytes())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello,[104 101 108 108 111]</span><br><span class="line">hello world,[104 101 108 108 111 32 119 111 114 108 100]</span><br></pre></td></tr></table></figure></p><h2 id="WriteByte"><a href="#WriteByte" class="headerlink" title="WriteByte"></a>WriteByte</h2><p><code>func (b *Buffer) WriteByte(c byte) error</code><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">byte</span> = <span class="string">'?'</span></span><br><span class="line">buf := bytes.NewBufferString(<span class="string">"hello"</span>)</span><br><span class="line">fmt.Println(buf.Bytes()) <span class="comment">// [104 101 108 108 111]</span></span><br><span class="line">buf.WriteByte(s)</span><br><span class="line">fmt.Println(buf.Bytes())<span class="comment">// [104 101 108 108 111 63]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="WriteRune"><a href="#WriteRune" class="headerlink" title="WriteRune"></a>WriteRune</h2><p><code>func (b *Buffer) WriteRune(r Rune) (n int,err error)</code><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> s <span class="keyword">rune</span> = <span class="string">'好'</span></span><br><span class="line">   buf := bytes.NewBufferString(<span class="string">"hello"</span>)</span><br><span class="line">   fmt.Println(buf.String()) <span class="comment">//hello</span></span><br><span class="line">   buf.WriteRune(s)   </span><br><span class="line">   fmt.Println(buf.String()) <span class="comment">//hello好</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">22909</span><br><span class="line">[104 101 108 108 111]</span><br><span class="line">[104 101 108 108 111 229 165 189]</span><br></pre></td></tr></table></figure></p><h1 id="从缓冲器中写出"><a href="#从缓冲器中写出" class="headerlink" title="从缓冲器中写出"></a>从缓冲器中写出</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">file,_ := os.Create(<span class="string">"test.txt"</span>)</span><br><span class="line">buf := bytes.NewBufferString(<span class="string">"hello world"</span>)</span><br><span class="line">buf.WriteTo(file)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="读出缓冲器"><a href="#读出缓冲器" class="headerlink" title="读出缓冲器"></a>读出缓冲器</h1><h2 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h2><p><code>func (b *Buffer) Read(p []byte)(n int,err error)</code><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s1 := []<span class="keyword">byte</span>(<span class="string">"hello"</span>)</span><br><span class="line">buff :=bytes.NewBuffer(s1)</span><br><span class="line">s2 := []<span class="keyword">byte</span>(<span class="string">" world"</span>)</span><br><span class="line">buff.Write(s2)</span><br><span class="line">fmt.Println(buff.String())  <span class="comment">//hello world</span></span><br><span class="line"></span><br><span class="line">s3 := <span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">3</span>)</span><br><span class="line">buff.Read(s3)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(s3))  <span class="comment">//hel,s3的容量为3，只能读3个</span></span><br><span class="line">fmt.Println(buff.String()) <span class="comment">//lo world</span></span><br><span class="line"></span><br><span class="line">buff.Read(s3)  <span class="comment">// 会把s3覆盖掉</span></span><br><span class="line">fmt.Println(<span class="keyword">string</span>(s3))  <span class="comment">// lo </span></span><br><span class="line">fmt.Println(buff.String())  <span class="comment">// world</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="ReadByte"><a href="#ReadByte" class="headerlink" title="ReadByte"></a>ReadByte</h2><p>返回缓冲器头部的第一个byte<br><code>func (b *Buffer) ReadByte() (c byte,err error)</code><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">buf := bytes.NewBufferString(<span class="string">"hello"</span>)</span><br><span class="line">fmt.Println(buf.String())  <span class="comment">// hello</span></span><br><span class="line">b,_:= buf.ReadByte()</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(b))<span class="comment">//h</span></span><br><span class="line">fmt.Println(buf.String())<span class="comment">//ello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="ReadRun"><a href="#ReadRun" class="headerlink" title="ReadRun"></a>ReadRun</h2><p>ReadRune方法，返回缓冲器头部的第一个rune<br><code>func (b *Buffer) ReadRune() (r rune,size int,err error)</code><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">buf1 := bytes.NewBufferString(<span class="string">"你好xuxiaofeng"</span>)</span><br><span class="line">fmt.Println(buf1.Bytes()) <span class="comment">//[228 189 160 229 165 189 120 117 120 105 97 111 102 101 110 103]</span></span><br><span class="line">b1,n1,_ := buf1.ReadRune()</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(b1)) <span class="comment">// 你</span></span><br><span class="line">fmt.Println(n1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">buf := bytes.NewBufferString(<span class="string">"hello"</span>)</span><br><span class="line">fmt.Println(buf.String())  <span class="comment">//hello</span></span><br><span class="line">b,n,_:= buf.ReadRune()</span><br><span class="line">fmt.Println(n) <span class="comment">// 1</span></span><br><span class="line">fmt.Println(<span class="keyword">string</span>(b))  <span class="comment">//h</span></span><br><span class="line">fmt.Println(buf.String())<span class="comment">//ello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为什么n==3，而n1==1呢？我们看下<code>ReadRune</code> 的源码<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span> <span class="title">ReadRune</span><span class="params">()</span> <span class="params">(r <span class="keyword">rune</span>, size <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> b.empty() &#123;</span><br><span class="line"><span class="comment">// Buffer is empty, reset to recover space.</span></span><br><span class="line">b.Reset()</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>, io.EOF</span><br><span class="line">&#125;</span><br><span class="line">c := b.buf[b.off]</span><br><span class="line"><span class="keyword">if</span> c &lt; utf8.RuneSelf &#123;   <span class="comment">// 就是在这里判断，读取的第一个字符是不是Rune</span></span><br><span class="line">b.off++</span><br><span class="line">b.lastRead = opReadRune1</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">rune</span>(c), <span class="number">1</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">r, n := utf8.DecodeRune(b.buf[b.off:])</span><br><span class="line">b.off += n</span><br><span class="line">b.lastRead = readOp(n)</span><br><span class="line"><span class="keyword">return</span> r, n, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="ReadBytes"><a href="#ReadBytes" class="headerlink" title="ReadBytes"></a>ReadBytes</h2><p>ReadBytes方法，需要一个byte作为分隔符，读的时候从缓冲器里找出第一个出现的分隔符，缓冲器头部开始到分隔符之间的byte返回。<br><code>func (b *Buffer) ReadBytes(delim byte) (line []byte,err error)</code><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> d <span class="keyword">byte</span> = <span class="string">'f'</span></span><br><span class="line">buf := bytes.NewBufferString(<span class="string">"xuxiaofeng"</span>)</span><br><span class="line">fmt.Println(buf.String())</span><br><span class="line"></span><br><span class="line">b,_ :=buf.ReadBytes(d)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(b))</span><br><span class="line">fmt.Println(buf.String())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>相当于有一个分隔符</p><h2 id="ReadString"><a href="#ReadString" class="headerlink" title="ReadString"></a>ReadString</h2><p>和readBytes方法类似</p><h1 id="读入缓冲器"><a href="#读入缓冲器" class="headerlink" title="读入缓冲器"></a>读入缓冲器</h1><p>ReadFrom方法，从一个实现io.Reader接口的r，把r的内容读到缓冲器里，n返回读的数量<br><code>func (b *Buffer) ReadFrom(r io.Reader) (n int64,err error</code><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   file, _ := os.Open(<span class="string">"text.txt"</span>)</span><br><span class="line">   buf := bytes.NewBufferString(<span class="string">"bob "</span>)</span><br><span class="line">   buf.ReadFrom(file)</span><br><span class="line">   fmt.Println(buf.String()) <span class="comment">//bob hello world</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="从缓冲器取出"><a href="#从缓冲器取出" class="headerlink" title="从缓冲器取出"></a>从缓冲器取出</h1><p>Next方法，返回前n个byte（slice），原缓冲器变<br><code>func (b *Buffer) Next(n int) []byte</code><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">buf := bytes.NewBufferString(<span class="string">"helloworld"</span>)</span><br><span class="line">fmt.Println(buf.String())  <span class="comment">// helloworld</span></span><br><span class="line">b := buf.Next(<span class="number">2</span>)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(b))  <span class="comment">// he</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="缓冲区原理介绍"><a href="#缓冲区原理介绍" class="headerlink" title="缓冲区原理介绍"></a>缓冲区原理介绍</h1><p>go字节缓冲区底层以字节切片做存储，切片存在长度len与容量cap, 缓冲区写从长度len的位置开始写，当len&gt;cap时，会自动扩容。缓冲区读会从内置标记off位置开始读(off始终记录读的起始位置)，当off==len时，表明缓冲区已全部读完<br>并重置缓冲区(len=off=0),此外当将要内容长度+已写的长度(即len) &lt;= cap/2时，缓冲区前移覆盖掉已读的内容(off=0，len-=off)，从避免缓冲区不断扩容<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    byteSlice := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">20</span>) </span><br><span class="line">    byteSlice[<span class="number">0</span>] = <span class="number">1</span>                                  <span class="comment">// 将缓冲区第一个字节置1</span></span><br><span class="line">    byteBuffer := bytes.NewBuffer(byteSlice)          <span class="comment">// 创建20字节缓冲区 len = 20 off = 0</span></span><br><span class="line">    c, _ := byteBuffer.ReadByte()                     <span class="comment">// off+=1</span></span><br><span class="line">    fmt.Printf(<span class="string">"len:%d, c=%d\n"</span>, byteBuffer.Len(), c) <span class="comment">// len = 20 off =1   打印c=1</span></span><br><span class="line">    byteBuffer.Reset()                                <span class="comment">// len = 0 off = 0</span></span><br><span class="line">    fmt.Printf(<span class="string">"len:%d\n"</span>, byteBuffer.Len())          <span class="comment">// 打印len=0</span></span><br><span class="line">    byteBuffer.Write([]<span class="keyword">byte</span>(<span class="string">"hello byte buffer"</span>))     <span class="comment">// 写缓冲区  len+=17</span></span><br><span class="line">    fmt.Printf(<span class="string">"len:%d\n"</span>, byteBuffer.Len())          <span class="comment">// 打印len=17</span></span><br><span class="line">    byteBuffer.Next(<span class="number">4</span>)                                <span class="comment">// 跳过4个字节 off+=4</span></span><br><span class="line">    c, _ = byteBuffer.ReadByte()                      <span class="comment">// 读第5个字节 off+=1</span></span><br><span class="line">    fmt.Printf(<span class="string">"第5个字节:%d\n"</span>, c)                    <span class="comment">// 打印:111(对应字母o)    len=17 off=5</span></span><br><span class="line">    byteBuffer.Truncate(<span class="number">3</span>)                            <span class="comment">// 将未字节数置为3        len=off+3=8   off=5</span></span><br><span class="line">    fmt.Printf(<span class="string">"len:%d\n"</span>, byteBuffer.Len())          <span class="comment">// 打印len=3为未读字节数  上面len=8是底层切片长度</span></span><br><span class="line">    byteBuffer.WriteByte(<span class="number">96</span>)                          <span class="comment">// len+=1=9 将y改成A</span></span><br><span class="line">    byteBuffer.Next(<span class="number">3</span>)                                <span class="comment">// len=9 off+=3=8</span></span><br><span class="line">    c, _ = byteBuffer.ReadByte()                      <span class="comment">// off+=1=9    c=96</span></span><br><span class="line">    fmt.Printf(<span class="string">"第9个字节:%d\n"</span>, c)                    <span class="comment">// 打印:96</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> golang学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> bytes </tag>
            
            <tag> Buffer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>golang vs python 参数传递.md</title>
      <link href="/2019/01/07/golang-2019-03-23-golang-vs-python-%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/"/>
      <url>/2019/01/07/golang-2019-03-23-golang-vs-python-%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/</url>
      
        <content type="html"><![CDATA[<p>如果非要用一句话来概括的话，golang都是值传递，python都是引用传递</p><h1 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h1><p>在 Golang 中函数之间传递变量时总是以值的方式传递的，无论是 int,string,bool,array 这样的内置类型（或者说原始的类型），还是 slice,channel,map 这样的引用类型，在函数间传递变量时，都是以值的方式传递，也就是说传递的都是值的副本。</p><p>简单来说，就看你传递的是什么，<br>你传递的是int,string,bool,array 这样的值类型，我就把这些值拷贝一份<br>你传递的是slice,channel,map这样引用类型，我就把这些引用拷贝一份</p><p>所有都是值传递了。</p><p>需要注意：引用类型和引用传递表达的是不同的概念。</p><blockquote><p>所有类型也是对象<br>引用传递通过指针实现<br>其他默认是值传递</p></blockquote><h1 id="python"><a href="#python" class="headerlink" title="python"></a>python</h1><p>这是一篇很好的文章<br><a href="http://winterttr.me/2015/10/24/python-passing-arguments-as-value-or-reference/" target="_blank" rel="noopener">http://winterttr.me/2015/10/24/python-passing-arguments-as-value-or-reference/</a></p><p>python中全都是对象引用，有不可变对象（number，string，tuple等）和可变对象之分（list，dict等）只是引用对象是否具备可更改的能力，从而体现出类似于“传值”和“引用”的不同外在表现<br>你传可变的值到函数，就相当于是引用传递了，因为函数中对此值再操作，地址也不变。<br>你传不可变的值到函数，就相当于是值传递了，因为函数中再对此值造作，就需要创造新的对象，变量就要指向新的地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="keyword">print</span> id(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">print</span> id(a)</span><br><span class="line"></span><br><span class="line">b = a</span><br><span class="line"><span class="keyword">print</span> id(b)</span><br></pre></td></tr></table></figure><p>在python中，上面三个print打印出来的结果都是相同的</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>go 日志系统</title>
      <link href="/2019/01/07/golang-2019-01-07-go%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/"/>
      <url>/2019/01/07/golang-2019-01-07-go%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>golang的log包已经提供了比较完善的功能，我们只是做了一些简单的封装</p><blockquote><p>主要就是构造了<code>Writer</code>，这个<code>writer</code>每次调用<code>Write()</code>的时候，执行了两步<br>第一步就是在终端输出，其实就是写到终端里<br>第二部就是写入到我们的日志文件。写入到日志文件的时候，有个大小判断，超过预定的大小后，就会进行分割和压缩</p></blockquote><h1 id="golang原生日志系统"><a href="#golang原生日志系统" class="headerlink" title="golang原生日志系统"></a>golang原生日志系统</h1><h2 id="log包简单实用"><a href="#log包简单实用" class="headerlink" title="log包简单实用"></a>log包简单实用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">log.Println(&quot;this is my first log&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入到log包中，看<code>Println()</code>函数<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Println calls Output to print to the standard logger.</span></span><br><span class="line"><span class="comment">// Arguments are handled in the manner of fmt.Println.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Println</span><span class="params">(v ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">std.Output(<span class="number">2</span>, fmt.Sprintln(v...))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再往上追溯<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stdout = NewFile(<span class="keyword">uintptr</span>(syscall.Stdout), <span class="string">"/dev/stdout"</span>)</span><br><span class="line"><span class="keyword">var</span> std = New(os.Stderr, <span class="string">""</span>, LstdFlags)</span><br></pre></td></tr></table></figure></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// New creates a new Logger. The out variable sets the</span></span><br><span class="line"><span class="comment">// destination to which log data will be written.</span></span><br><span class="line"><span class="comment">// The prefix appears at the beginning of each generated log line.</span></span><br><span class="line"><span class="comment">// The flag argument defines the logging properties.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(out io.Writer, prefix <span class="keyword">string</span>, flag <span class="keyword">int</span>)</span> *<span class="title">Logger</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Logger&#123;out: out, prefix: prefix, flag: flag&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>Logger</code>就是一切的重点了<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Logger represents an active logging object that generates lines of</span></span><br><span class="line"><span class="comment">// output to an io.Writer. Each logging operation makes a single call to</span></span><br><span class="line"><span class="comment">// the Writer's Write method. A Logger can be used simultaneously from</span></span><br><span class="line"><span class="comment">// multiple goroutines; it guarantees to serialize access to the Writer.</span></span><br><span class="line"><span class="keyword">type</span> Logger <span class="keyword">struct</span> &#123;</span><br><span class="line">mu     sync.Mutex <span class="comment">// ensures atomic writes; protects the following fields</span></span><br><span class="line">prefix <span class="keyword">string</span>     <span class="comment">// prefix to write at beginning of each line</span></span><br><span class="line">flag   <span class="keyword">int</span>        <span class="comment">// properties</span></span><br><span class="line">out    io.Writer  <span class="comment">// destination for output</span></span><br><span class="line">buf    []<span class="keyword">byte</span>     <span class="comment">// for accumulating text to write</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们再看<code>Output</code> 函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func (l *Logger) Output(calldepth int, s string) error &#123;</span><br><span class="line">...</span><br><span class="line">    ...</span><br><span class="line">_, err := l.out.Write(l.buf)</span><br><span class="line">return err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实就是把日志写入到一个文件中。只是终端有默认的文件而已。</p><h2 id="构建我们自己的Logger"><a href="#构建我们自己的Logger" class="headerlink" title="构建我们自己的Logger"></a>构建我们自己的Logger</h2><p>上面的例子，当我们没有创建<code>Logger</code>时，系统会使用默认的<code>Logger</code>，也就是<code>Stdout</code>.<br>接下来，我们构建一个自己的<code>Logger</code> ,让日志输出到我们自己指定的文件中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">//logFile,_ := os.Open(&quot;./test.log&quot;) /</span><br><span class="line">logFile, _ := os.OpenFile(&quot;test.log&quot;, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0666)</span><br><span class="line">logger := log.New(logFile, &quot;TEST&quot;, log.Lshortfile|log.Ldate|log.Ltime)</span><br><span class="line">for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">logger.Printf(&quot;this is my %v test log&quot;,i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>注意两点</p></blockquote><ol><li><p><code>open(filename)</code> 默认是以只读方式打开，那我们就不能写入了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func Open(name string) (*File, error) &#123;</span><br><span class="line">return OpenFile(name, O_RDONLY, 0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>os.O_APPEND</code>以追加模式<br>test.log</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TEST2019/01/10 14:25:35 test01.go:13: this is my 0 test log</span><br><span class="line">TEST2019/01/10 14:25:35 test01.go:13: this is my 1 test log</span><br><span class="line">TEST2019/01/10 14:25:35 test01.go:13: this is my 2 test log</span><br><span class="line">TEST2019/01/10 14:25:35 test01.go:13: this is my 3 test log</span><br><span class="line">TEST2019/01/10 14:25:35 test01.go:13: this is my 4 test log</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ol><h1 id="开始造轮子"><a href="#开始造轮子" class="headerlink" title="开始造轮子"></a>开始造轮子</h1><p>第一步就是在终端输出，其实就是写到终端里<br>第二部就是写入到我们的日志文件。写入到日志文件的时候，有个大小判断，超过预定的大小后，就会进行分割和压缩<br>接下来展示一下目录结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mlog  定义了我们日志系统，还有日志子系统</span><br><span class="line">    log.go  日志系统接口实现和子系统的创建</span><br><span class="line">    interface.go  日志系统接口</span><br><span class="line">rotator  </span><br><span class="line">    rotator.go  日志写入文件、日志分割、日志压缩</span><br><span class="line">log.go  项目的日志配置文件，创建日志系统及子系统</span><br><span class="line">config.go 项目的配置文件，加载日志等级，用配置的日志文件初始化rotator</span><br><span class="line">main.go 项目入口文件</span><br></pre></td></tr></table></figure></p><p>源码<br><a href="https://github.com/naichadouban/logProject" target="_blank" rel="noopener">https://github.com/naichadouban/logProject</a></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先在<code>log.go</code>文件中，初始化后台日志系统,还有日志子系统。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">backendLog = mlog.NewBackend(logWriter&#123;&#125;)  //往终端中写入日志 </span><br><span class="line">logRotator *rotator.Rotator  // 往文件中写入日志</span><br><span class="line">Mainlog     = backendLog.Logger(&quot;HCD&quot;)  //日志子系统</span><br><span class="line">TESTlog = backendLog.Logger(&quot;TEST&quot;)  // 日志子系统</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>然后我们会在<code>config.go</code> 会初始化 <code>logRatator</code>,设置日志等级<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">initLogRotator(&quot;./test.log&quot;)  // 这里已经设置了日志输出文件</span><br><span class="line">setLogLevels(DebugLevel)</span><br></pre></td></tr></table></figure></p><p>当我们调用子日志系统打印日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mainlog.Infof(&quot;this si my log %v&quot;,i)</span><br></pre></td></tr></table></figure></p><p>判断日志级别后，调用Backend打印日志，BackendLog统一管理各个子日志系统的日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func (l *slog) Infof(format string, args ...interface&#123;&#125;) &#123;</span><br><span class="line">lvl := l.Level()</span><br><span class="line">if lvl &lt;= LevelInfo &#123;</span><br><span class="line">l.b.printf(&quot;INF&quot;, l.tag, format, args...)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后我们再看Backend.printf()函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b.mu.Lock()</span><br><span class="line">b.w.Write(*bytebuf)</span><br><span class="line">b.mu.Unlock()</span><br></pre></td></tr></table></figure></p><p><code>b.w.Write(*bytebuf)</code>,这个<code>w.Write()</code>是我们实现io.Writer接口的Write函数。<br>他内部有两个Write()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type logWriter struct&#123;&#125;</span><br><span class="line">func (logWriter) Write(p []byte)(n int,err error)&#123;</span><br><span class="line">os.Stdout.Write(p)  //标准输出，就是我们看到的前台显示</span><br><span class="line">logRotator.Write(p)  // rotator的输出，就是文件记录中的操作</span><br><span class="line">return len(p),nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">backendLog = mlog.NewBackend(logWriter&#123;&#125;)</span><br></pre></td></tr></table></figure><p>我们再分析logWriter的Write方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.Stdout.Write(p)</span><br></pre></td></tr></table></figure></p><p>这个是系统的标准数据，暂时不讨论</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logRotator.Write(p)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func (r *Rotator) Write(p []byte) (n int, err error) &#123;</span><br><span class="line">   // 写入文件</span><br><span class="line">n, _ = r.out.Write(p)</span><br><span class="line">r.size += int64(n)</span><br><span class="line">  // 日志拆分，压缩</span><br><span class="line">if r.size &gt;= r.threshold &amp;&amp; len(p) &gt; 0 &amp;&amp; p[len(p)-1] == &apos;\n&apos; &#123;</span><br><span class="line">err := r.rotate()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return 0, err</span><br><span class="line">&#125;</span><br><span class="line">r.size = 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return n, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的日志压缩，可以看源码</p>]]></content>
      
      
      <categories>
          
          <category> golang学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> go log </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2019/01/06/golang-2019-01-06-go-%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%81new%E3%80%81make/"/>
      <url>/2019/01/06/golang-2019-01-06-go-%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%81new%E3%80%81make/</url>
      
        <content type="html"><![CDATA[<h2 id="lt-lt-lt-lt-lt-lt-lt-HEAD"><a href="#lt-lt-lt-lt-lt-lt-lt-HEAD" class="headerlink" title="&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD"></a>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</h2><p>title: go 变量声明初始化、new、make<br>date: 2019-01-07<br>tags:</p><pre><code>- golang- 变量声明和初始化- new- make</code></pre><p>categories:</p><pre><code>- golang</code></pre><hr><h1 id="变量的声明和初始化"><a href="#变量的声明和初始化" class="headerlink" title="变量的声明和初始化"></a>变量的声明和初始化</h1><h2 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h2><p>起源于大远问，下面的代码会输出什么？<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> p Person</span><br><span class="line">fmt.Println(p.age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>按照我之前的理解，报错。因为p只是声明了，并没有初始化。<br>但是打印出来却是<code>0</code></p><p>说明Person对象确实初始化了。</p><h2 id="实验二"><a href="#实验二" class="headerlink" title="实验二"></a>实验二</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> p *Person</span><br><span class="line">fmt.Println(p) <span class="comment">//&lt;nil&gt;</span></span><br><span class="line">fmt.Println(p.age) <span class="comment">//panic: runtime error: invalid memory address or nil pointer dereference</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>声明一个变量，初始化的内容只跟变量的类型相关</p></blockquote><p>声明了一个<code>*Person</code>类型的指针p,说明<code>p</code>初始化的内容就是指针的默认值，那就是<code>nil</code> 了。<br>打印p.age出错，证明了Person并没有初始化，当然是空指针错误了。</p><p>我们可以画图说明下两者的关系<br><img src="https://upload-images.jianshu.io/upload_images/422094-61bd4e0fd3823b06.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_20190106203742.jpg"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>nil 只能赋值给指针类型的变量，实际上nil就是是指针类型变量的零值。值类型的变量有各自的零值 比如 int 是 0 string 是 “”</li><li>变量的声明，无论是值类型还是指针类型的变量，声明之后，变量都会占有一块内存，并且被初始化为一个零值，被初始化的内容只跟变量的类型有关（注意：<code>Post</code>跟 <code>*Post是两种类型</code><br>var i int // 值类型 因此 i 是 0<br>var p Person // 值类型 因此 p.title 是””, p.num 是 0<br>var po <em>Person // 初始化的不是Post类型，而是</em>Post类型，即指针类型，因此p是nil p.title 会报错  </li></ol><h1 id="make和new"><a href="#make和new" class="headerlink" title="make和new"></a>make和new</h1><p>new 和 make 都可以用来分配空间，初始化类型。他们和上面有什么关系吗？</p><h2 id="new-T-返回的是-T-的指针"><a href="#new-T-返回的是-T-的指针" class="headerlink" title="new(T) 返回的是 T 的指针"></a>new(T) 返回的是 T 的指针</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">*a = <span class="number">3</span></span><br><span class="line">fmt.Printf(<span class="string">"%T,%p,%p,%v\n"</span>,a,&amp;a,a,a) <span class="comment">// *int,0xc000006028,0xc00000a0a8,0xc00000a0a8</span></span><br><span class="line"></span><br><span class="line">b := <span class="built_in">new</span>(Person)</span><br><span class="line">fmt.Printf(<span class="string">"%T,%p,%p,%v\n"</span>,b,&amp;b,b,b.age) <span class="comment">// *main.Person,0xc000006038,0xc000004460,0</span></span><br><span class="line"></span><br><span class="line">c := <span class="built_in">new</span>(Person)</span><br><span class="line">c = &amp;Person&#123;<span class="string">"xuxiaofeng"</span>,<span class="number">26</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%T,%p,%p,%v\n"</span>,c,&amp;c,c,c.age) <span class="comment">// *main.Person,0xc000006040,0xc0000044a0,26</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>画图表示一下<br><img src="https://upload-images.jianshu.io/upload_images/422094-78d6fab85d216c4f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_20190106203742.jpg"></p><p>第三段中，new就相当于下面这两句话<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c *Person</span><br><span class="line">c = &amp;Person&#123;<span class="string">"xuxiaofeng"</span>,<span class="number">26</span>&#125;</span><br></pre></td></tr></table></figure></p><p>如果我们<code>new(*Person)</code>呢,道理还是同样的道理，只是多了一层指针，指针的指针，容易绕晕。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="built_in">new</span>(*Person)</span><br><span class="line">fmt.Printf(<span class="string">"%T.%p,%p\n"</span>,a,&amp;a,a)  <span class="comment">// **main.Person.0xc000006028,0xc000006030</span></span><br><span class="line"><span class="comment">//a = Person&#123;&#125;  // error</span></span><br><span class="line"><span class="comment">//a = &amp;Person&#123;&#125;  // error</span></span><br><span class="line"><span class="comment">//*a = Person&#123;&#125;  //error</span></span><br><span class="line"> *a = &amp;Person&#123;<span class="string">"xuxiaofeng"</span>,<span class="number">16</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">"%T.%p,%p\n"</span>,*a,&amp;(*a),*a)  <span class="comment">// *main.Person.0xc000006030,0xc000004460</span></span><br><span class="line">fmt.Println((**a).age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>画图表示一下<br><img src="https://upload-images.jianshu.io/upload_images/422094-08fab9271d92a434.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_20190106203742.jpg"></p><p>new就是初始化T为默认值，然后返回了*T，就是指向初始化的T的指针</p><h2 id="make-只能用于-slice-map-channel"><a href="#make-只能用于-slice-map-channel" class="headerlink" title="make 只能用于 slice,map,channel"></a>make 只能用于 slice,map,channel</h2><p>make基本使用就不做介绍了，只要注意只能是slice,map,channel，这三种类型就可以了。这三种类型都是引用类型</p><h3 id="new-slice"><a href="#new-slice" class="headerlink" title="new slice"></a>new slice</h3><p>我们能否<code>new([]int)</code> new一个slice呢？<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="built_in">new</span>([]<span class="keyword">int</span>)</span><br><span class="line"><span class="comment">//a[0] = 1  //(type *[]int does not support indexing)</span></span><br><span class="line"><span class="comment">//(*a)[0] = 2  // error: index out of range</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(*a),<span class="built_in">cap</span>(*a)) <span class="comment">//0 0</span></span><br><span class="line">*a = <span class="built_in">append</span>(*a,<span class="number">1</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>,a)  <span class="comment">//*[]int</span></span><br><span class="line">fmt.Println((*a)[<span class="number">0</span>])  <span class="comment">//1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们看也是可以的，只是给我们返回了长度和容量都是0的slice，而append之后，slice的底层数据已经不是原来的数组了。</p><h3 id="new-map"><a href="#new-map" class="headerlink" title="new map"></a>new map</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="built_in">new</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">(*a)[<span class="string">"xuxaiofeng"</span>] =<span class="number">26</span>  <span class="comment">//panic: assignment to entry in nil map</span></span><br><span class="line">fmt.Println(*a)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="new-chan"><a href="#new-chan" class="headerlink" title="new chan"></a>new chan</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="built_in">new</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">(*a) &lt;- <span class="number">2</span></span><br><span class="line">&#125;()</span><br><span class="line">t := &lt;-*a</span><br><span class="line">fmt.Println(t)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//fatal error: all goroutines are asleep - deadlock!</span></span><br><span class="line"><span class="comment">//goroutine 1 [chan receive (nil chan)]:</span></span><br></pre></td></tr></table></figure><p>说明我们创建的chan就是一个nil，还没有初始化，从一个nil中读数据，程序当然会deadlock</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>new(T) 返回 T 的指针 *T 并指向 T 的零值。<br>make(T) 返回的初始化的 T，只能用于 slice，map，channel。</p><h1 id="p-name-和-p-name"><a href="#p-name-和-p-name" class="headerlink" title="p.name 和*p.name"></a>p.name 和*p.name</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p := <span class="built_in">new</span>(Person)</span><br><span class="line"><span class="comment">//p = Person&#123;"xuxiaofeng",26&#125; //cannot use Person literal (type Person) as type *Person in assignment</span></span><br><span class="line">p.name = <span class="string">"xuxiaofeng"</span></span><br><span class="line">fmt.Println(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>p是*Person,是Person的指针，所以不能直接复制，要想复制也要这样<code>p = &amp;Person{&quot;xuxiaofeng&quot;,26}</code>,但是为什么调用字段的时候就可以<code>p.name = &quot;xuxiaofeng&quot;</code>？</p><blockquote><p>如果 x 是可寻址的，&amp;x 的 filed 集合包含 m，x.m 和 (&amp;x).m 是等同的，go 自动做转换，也就是 p.name和 (*p).name调用是等价的，go 在下面自动做了转换。</p></blockquote><h1 id="接口、结构体实现和结构体指针的实现"><a href="#接口、结构体实现和结构体指针的实现" class="headerlink" title="接口、结构体实现和结构体指针的实现"></a>接口、结构体实现和结构体指针的实现</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">interface</span> &#123;</span><br><span class="line">Eat()</span><br><span class="line">Drink()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">age <span class="keyword">int</span></span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Student)</span><span class="title">Drink</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(s.name +<span class="string">"正在喝酒"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Student)</span><span class="title">Eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(s.name +<span class="string">"正在吃东西"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">s := Student&#123;<span class="number">30</span>,<span class="string">"xuxioafeng"</span>&#125;</span><br><span class="line">testEat(s)  <span class="comment">// success</span></span><br><span class="line">testEat(&amp;s) <span class="comment">// success</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testEat</span><span class="params">(p Person)</span></span>&#123;</span><br><span class="line">p.Eat()</span><br><span class="line">p.Drink()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论我们传的是<code>Student</code>本身<code>s</code>,还是<code>Student</code>对象的指针<code>&amp;s</code>,都是可以调用成功了。<br>但是下面就不一样了<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">interface</span> &#123;</span><br><span class="line">Eat()</span><br><span class="line">Drink()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">age <span class="keyword">int</span></span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span><span class="title">Eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(s.name +<span class="string">"正在吃东西"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Student)</span><span class="title">Drink</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(s.name +<span class="string">"正在喝酒"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">s := Student&#123;<span class="number">30</span>,<span class="string">"xuxioafeng"</span>&#125;</span><br><span class="line">testEat(&amp;s) <span class="comment">// success</span></span><br><span class="line">testEat(s) <span class="comment">// false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testEat</span><span class="params">(p Person)</span></span>&#123;</span><br><span class="line">p.Eat()</span><br><span class="line">p.Drink()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>func (s *Student)Eat(){}</code> 我们改成了指针的实现。<br>这时候如果传<code>Student</code>本身<code>s</code>就不可能了。</p><p>看错误提示：Cannot use ‘s’ (type Student) as type Person Type does not implement ‘Person’ as ‘Eat’ method has a pointer receiver。<br>就是说我们没有实现接口的<code>Eat</code>方法</p><h2 id=""><a href="#" class="headerlink" title="======="></a>=======</h2><p>title: go 变量声明初始化、new、make<br>date: 2019-01-07<br>tags:</p><pre><code>- golang- 变量声明和初始化- new- make</code></pre><p>categories:</p><pre><code>- golang</code></pre><hr><h1 id="变量的声明和初始化-1"><a href="#变量的声明和初始化-1" class="headerlink" title="变量的声明和初始化"></a>变量的声明和初始化</h1><h2 id="实验一-1"><a href="#实验一-1" class="headerlink" title="实验一"></a>实验一</h2><p>起源于大远问，下面的代码会输出什么？<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> p Person</span><br><span class="line">fmt.Println(p.age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>按照我之前的理解，报错。因为p只是声明了，并没有初始化。<br>但是打印出来却是<code>0</code></p><p>说明Person对象确实初始化了。</p><h2 id="实验二-1"><a href="#实验二-1" class="headerlink" title="实验二"></a>实验二</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> p *Person</span><br><span class="line">fmt.Println(p) <span class="comment">//&lt;nil&gt;</span></span><br><span class="line">fmt.Println(p.age) <span class="comment">//panic: runtime error: invalid memory address or nil pointer dereference</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>声明一个变量，初始化的内容只跟变量的类型相关</p></blockquote><p>声明了一个<code>*Person</code>类型的指针p,说明<code>p</code>初始化的内容就是指针的默认值，那就是<code>nil</code> 了。<br>打印p.age出错，证明了Person并没有初始化，当然是空指针错误了。</p><p>我们可以画图说明下两者的关系<br><img src="https://upload-images.jianshu.io/upload_images/422094-61bd4e0fd3823b06.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_20190106203742.jpg"></p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><ol><li>nil 只能赋值给指针类型的变量，实际上nil就是是指针类型变量的零值。值类型的变量有各自的零值 比如 int 是 0 string 是 “”</li><li>变量的声明，无论是值类型还是指针类型的变量，声明之后，变量都会占有一块内存，并且被初始化为一个零值，被初始化的内容只跟变量的类型有关（注意：<code>Post</code>跟 <code>*Post是两种类型</code><br>var i int // 值类型 因此 i 是 0<br>var p Person // 值类型 因此 p.title 是””, p.num 是 0<br>var po <em>Person // 初始化的不是Post类型，而是</em>Post类型，即指针类型，因此p是nil p.title 会报错  </li></ol><h1 id="make和new-1"><a href="#make和new-1" class="headerlink" title="make和new"></a>make和new</h1><p>new 和 make 都可以用来分配空间，初始化类型。他们和上面有什么关系吗？</p><h2 id="new-T-返回的是-T-的指针-1"><a href="#new-T-返回的是-T-的指针-1" class="headerlink" title="new(T) 返回的是 T 的指针"></a>new(T) 返回的是 T 的指针</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">*a = <span class="number">3</span></span><br><span class="line">fmt.Printf(<span class="string">"%T,%p,%p,%v\n"</span>,a,&amp;a,a,a) <span class="comment">// *int,0xc000006028,0xc00000a0a8,0xc00000a0a8</span></span><br><span class="line"></span><br><span class="line">b := <span class="built_in">new</span>(Person)</span><br><span class="line">fmt.Printf(<span class="string">"%T,%p,%p,%v\n"</span>,b,&amp;b,b,b.age) <span class="comment">// *main.Person,0xc000006038,0xc000004460,0</span></span><br><span class="line"></span><br><span class="line">c := <span class="built_in">new</span>(Person)</span><br><span class="line">c = &amp;Person&#123;<span class="string">"xuxiaofeng"</span>,<span class="number">26</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%T,%p,%p,%v\n"</span>,c,&amp;c,c,c.age) <span class="comment">// *main.Person,0xc000006040,0xc0000044a0,26</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>画图表示一下<br><img src="https://upload-images.jianshu.io/upload_images/422094-78d6fab85d216c4f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_20190106203742.jpg"></p><p>第三段中，new就相当于下面这两句话<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c *Person</span><br><span class="line">c = &amp;Person&#123;<span class="string">"xuxiaofeng"</span>,<span class="number">26</span>&#125;</span><br></pre></td></tr></table></figure></p><p>如果我们<code>new(*Person)</code>呢,道理还是同样的道理，只是多了一层指针，指针的指针，容易绕晕。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="built_in">new</span>(*Person)</span><br><span class="line">fmt.Printf(<span class="string">"%T.%p,%p\n"</span>,a,&amp;a,a)  <span class="comment">// **main.Person.0xc000006028,0xc000006030</span></span><br><span class="line"><span class="comment">//a = Person&#123;&#125;  // error</span></span><br><span class="line"><span class="comment">//a = &amp;Person&#123;&#125;  // error</span></span><br><span class="line"><span class="comment">//*a = Person&#123;&#125;  //error</span></span><br><span class="line"> *a = &amp;Person&#123;<span class="string">"xuxiaofeng"</span>,<span class="number">16</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">"%T.%p,%p\n"</span>,*a,&amp;(*a),*a)  <span class="comment">// *main.Person.0xc000006030,0xc000004460</span></span><br><span class="line">fmt.Println((**a).age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>画图表示一下<br><img src="https://upload-images.jianshu.io/upload_images/422094-08fab9271d92a434.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_20190106203742.jpg"></p><p>new就是初始化T为默认值，然后返回了*T，就是指向初始化的T的指针</p><h2 id="make-只能用于-slice-map-channel-1"><a href="#make-只能用于-slice-map-channel-1" class="headerlink" title="make 只能用于 slice,map,channel"></a>make 只能用于 slice,map,channel</h2><p>make基本使用就不做介绍了，只要注意只能是slice,map,channel，这三种类型就可以了。这三种类型都是引用类型</p><h3 id="new-slice-1"><a href="#new-slice-1" class="headerlink" title="new slice"></a>new slice</h3><p>我们能否<code>new([]int)</code> new一个slice呢？<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="built_in">new</span>([]<span class="keyword">int</span>)</span><br><span class="line"><span class="comment">//a[0] = 1  //(type *[]int does not support indexing)</span></span><br><span class="line"><span class="comment">//(*a)[0] = 2  // error: index out of range</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(*a),<span class="built_in">cap</span>(*a)) <span class="comment">//0 0</span></span><br><span class="line">*a = <span class="built_in">append</span>(*a,<span class="number">1</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>,a)  <span class="comment">//*[]int</span></span><br><span class="line">fmt.Println((*a)[<span class="number">0</span>])  <span class="comment">//1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们看也是可以的，只是给我们返回了长度和容量都是0的slice，而append之后，slice的底层数据已经不是原来的数组了。</p><h3 id="new-map-1"><a href="#new-map-1" class="headerlink" title="new map"></a>new map</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="built_in">new</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">(*a)[<span class="string">"xuxaiofeng"</span>] =<span class="number">26</span>  <span class="comment">//panic: assignment to entry in nil map</span></span><br><span class="line">fmt.Println(*a)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="new-chan-1"><a href="#new-chan-1" class="headerlink" title="new chan"></a>new chan</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="built_in">new</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">(*a) &lt;- <span class="number">2</span></span><br><span class="line">&#125;()</span><br><span class="line">t := &lt;-*a</span><br><span class="line">fmt.Println(t)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//fatal error: all goroutines are asleep - deadlock!</span></span><br><span class="line"><span class="comment">//goroutine 1 [chan receive (nil chan)]:</span></span><br></pre></td></tr></table></figure><p>说明我们创建的chan就是一个nil，还没有初始化，从一个nil中读数据，程序当然会deadlock</p><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>new(T) 返回 T 的指针 *T 并指向 T 的零值。<br>make(T) 返回的初始化的 T，只能用于 slice，map，channel。</p><h1 id="p-name-和-p-name-1"><a href="#p-name-和-p-name-1" class="headerlink" title="p.name 和*p.name"></a>p.name 和*p.name</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p := <span class="built_in">new</span>(Person)</span><br><span class="line"><span class="comment">//p = Person&#123;"xuxiaofeng",26&#125; //cannot use Person literal (type Person) as type *Person in assignment</span></span><br><span class="line">p.name = <span class="string">"xuxiaofeng"</span></span><br><span class="line">fmt.Println(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>p是*Person,是Person的指针，所以不能直接复制，要想复制也要这样<code>p = &amp;Person{&quot;xuxiaofeng&quot;,26}</code>,但是为什么调用字段的时候就可以<code>p.name = &quot;xuxiaofeng&quot;</code>？</p><blockquote><p>如果 x 是可寻址的，&amp;x 的 filed 集合包含 m，x.m 和 (&amp;x).m 是等同的，go 自动做转换，也就是 p.name和 (*p).name调用是等价的，go 在下面自动做了转换。</p></blockquote><h1 id="接口、结构体实现和结构体指针的实现-1"><a href="#接口、结构体实现和结构体指针的实现-1" class="headerlink" title="接口、结构体实现和结构体指针的实现"></a>接口、结构体实现和结构体指针的实现</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">interface</span> &#123;</span><br><span class="line">Eat()</span><br><span class="line">Drink()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">age <span class="keyword">int</span></span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Student)</span><span class="title">Drink</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(s.name +<span class="string">"正在喝酒"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Student)</span><span class="title">Eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(s.name +<span class="string">"正在吃东西"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">s := Student&#123;<span class="number">30</span>,<span class="string">"xuxioafeng"</span>&#125;</span><br><span class="line">testEat(s)  <span class="comment">// success</span></span><br><span class="line">testEat(&amp;s) <span class="comment">// success</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testEat</span><span class="params">(p Person)</span></span>&#123;</span><br><span class="line">p.Eat()</span><br><span class="line">p.Drink()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论我们传的是<code>Student</code>本身<code>s</code>,还是<code>Student</code>对象的指针<code>&amp;s</code>,都是可以调用成功了。<br>但是下面就不一样了<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">interface</span> &#123;</span><br><span class="line">Eat()</span><br><span class="line">Drink()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">age <span class="keyword">int</span></span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span><span class="title">Eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(s.name +<span class="string">"正在吃东西"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Student)</span><span class="title">Drink</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(s.name +<span class="string">"正在喝酒"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">s := Student&#123;<span class="number">30</span>,<span class="string">"xuxioafeng"</span>&#125;</span><br><span class="line">testEat(&amp;s) <span class="comment">// success</span></span><br><span class="line">testEat(s) <span class="comment">// false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testEat</span><span class="params">(p Person)</span></span>&#123;</span><br><span class="line">p.Eat()</span><br><span class="line">p.Drink()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>func (s *Student)Eat(){}</code> 我们改成了指针的实现。<br>这时候如果传<code>Student</code>本身<code>s</code>就不可能了。</p><p>看错误提示：Cannot use ‘s’ (type Student) as type Person Type does not implement ‘Person’ as ‘Eat’ method has a pointer receiver。<br>就是说我们没有实现接口的<code>Eat</code>方法</p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>6da34f0459eccf958c470f5fc458327949c04c6d<br>说明：还是和上面一样，这是golang的解引用。我们传<code>&amp;s</code>的时候，先找<code>&amp;s</code>，没有的话就会去<code>s</code>上找了</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>go指针类型转化 unsafe Pointer</title>
      <link href="/2019/01/04/golang-2019-01-05-go%E5%8F%8D%E5%B0%84%E8%A7%84%E5%88%99-the-law-of-reflection/"/>
      <url>/2019/01/04/golang-2019-01-05-go%E5%8F%8D%E5%B0%84%E8%A7%84%E5%88%99-the-law-of-reflection/</url>
      
        <content type="html"><![CDATA[<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://segmentfault.com/a/1190000006190038" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006190038</a><br><a href="https://mikespook.com/2011/09/%E5%8F%8D%E5%B0%84%E7%9A%84%E8%A7%84%E5%88%99/" target="_blank" rel="noopener">https://mikespook.com/2011/09/%E5%8F%8D%E5%B0%84%E7%9A%84%E8%A7%84%E5%88%99/</a></p>]]></content>
      
      
      <categories>
          
          <category> golang学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 指针转化 </tag>
            
            <tag> unsafe </tag>
            
            <tag> Pointer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>go指针类型转化 unsafe Pointer</title>
      <link href="/2019/01/04/golang-2019-01-04-go-unsafe-Pointer%E3%80%81%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96/"/>
      <url>/2019/01/04/golang-2019-01-04-go-unsafe-Pointer%E3%80%81%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="golang强类型"><a href="#golang强类型" class="headerlink" title="golang强类型"></a>golang强类型</h1><p>golang是一种<code>强类型</code>的<code>静态</code>语言。<br>强类型就是说一旦类型定义了，就不能够再改变它的类型。<br>静态是说，程序在运行前检测类型，而不是像JavaScript和python等动态语言，运行时才检测</p><blockquote><p>为了安全考虑，golang时不允许两种<code>指针类型</code> 之间相互转化的。</p></blockquote><h1 id="指针类型转换"><a href="#指针类型转换" class="headerlink" title="指针类型转换"></a>指针类型转换</h1><p>即使有相同的底层类型也是不能转换的<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i Myint = <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> j <span class="keyword">int</span> =<span class="number">3</span></span><br><span class="line">j = i   <span class="comment">// cannot use i (type Myint) as type int in assignment</span></span><br><span class="line">fmt.Println(j)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">10</span></span><br><span class="line">fmt.Printf(<span class="string">"%T:%v,%p,%T\n"</span>,i,i,&amp;i,&amp;i)  <span class="comment">// int:10,0x416020,*in</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> j <span class="keyword">float64</span> = <span class="number">3.434</span></span><br><span class="line">fmt.Printf(<span class="string">"%T:%v,%p,%T\n"</span>,j,j,&amp;j,&amp;j)  <span class="comment">// float64:3.434,0x416038,*float64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型转化</span></span><br><span class="line">m := <span class="keyword">float64</span>(i)</span><br><span class="line">fmt.Printf(<span class="string">"%T:%v,%p,%T\n"</span>,m,m,&amp;m,&amp;m) <span class="comment">// float64:10,0x416060,*float64</span></span><br><span class="line"><span class="comment">// 指针类型转化</span></span><br><span class="line">n := (*<span class="keyword">float64</span>)(&amp;i)  <span class="comment">//cannot convert &amp;i (type *int) to type *float64</span></span><br><span class="line">fmt.Printf(<span class="string">"%T:%v,%p,%T\n"</span>,n,n,&amp;n,&amp;n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序中我们需明白</p><blockquote><ol><li><code>*int</code>，表示int类型的指针，<code>*float</code> 表示float类型的指针</li><li><code>float64(i)</code>就是普通的类型转化，golang时允许的</li><li><code>(*float64)(&amp;i)</code> 中 <code>(*float64)</code> 括号中整体是一个类型，表示float64类型的指针类型</li></ol></blockquote><p>通过上面的例子，我们知道不同的指针类型是不同转换的，但是我们就需要转化怎么办？<br>就需要用到unsafe包的 Pointer了</p><h1 id="unsafe-Pointer"><a href="#unsafe-Pointer" class="headerlink" title="unsafe.Pointer"></a>unsafe.Pointer</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>unsafe.Pointer是一种特殊类型的指针，它可以包含任意类型的地址<br>我们可以在golang的源码中看到如下的定义<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ArbitraryType <span class="keyword">int</span></span><br><span class="line"><span class="keyword">type</span> Pointer *ArbitraryType</span><br></pre></td></tr></table></figure></p><p>说明unsafe.Pointer其实就是<code>*int</code> ，一个通用类型的指针<br>示例一<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">10</span></span><br><span class="line">fmt.Printf(<span class="string">"%T,%v\n"</span>,&amp;i,&amp;i)  <span class="comment">// *int,0xc00004c080</span></span><br><span class="line"><span class="keyword">var</span> j unsafe.Pointer =  unsafe.Pointer(&amp;i) <span class="comment">// unsafe.Pointer,0xc00004c080</span></span><br><span class="line">fmt.Printf(<span class="string">"%T,%v"</span>,j,j)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果我们直接<code>var j unsafe.Pointer =  &amp;i</code> 的话，就会报错：cannot use &amp;i (type *int) as type unsafe.Pointer in assignment。说民unsafe.Pointer是一种类型，上面的示例只是类型强转。</p><h2 id="利用unsafe-Pointer再不同-T之间转换"><a href="#利用unsafe-Pointer再不同-T之间转换" class="headerlink" title="利用unsafe.Pointer再不同*T之间转换"></a>利用unsafe.Pointer再不同<code>*T</code>之间转换</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> j *<span class="keyword">float64</span> = (*<span class="keyword">float64</span>)(unsafe.Pointer(&amp;i))</span><br><span class="line">fmt.Printf(<span class="string">"%T.%T\n"</span>,j,*j) <span class="comment">// *float64.float64</span></span><br><span class="line">*j = *j * <span class="number">3</span></span><br><span class="line">fmt.Printf(<span class="string">"%v,%v"</span>,i,j) <span class="comment">//30,0xc00004c080</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，我们通过操作<code>j</code>指针就改变了<code>i</code>的值。<br>虽然毫无意义，但是证明了通过<code>unsafe.Pointer</code>，我们可以将<code>*int</code>转化成<code>*float64</code></p><h2 id="unsafe-Pointer-四原则"><a href="#unsafe-Pointer-四原则" class="headerlink" title="unsafe.Pointer 四原则"></a>unsafe.Pointer 四原则</h2><blockquote><p>1.任何指针都可以转化为unsafe.Pointer<br>2.unsafe.Pointer 可以转化为任何指针<br>3.uintptr可以转化为unsafe.Pointer<br>4.unsafe.Pointer可以转化为uintptr</p></blockquote><p>规则1,2我们前面已经演示过了，3,4是干什么的？<br><code>*T</code> 不能计算偏移量，也不能计算便宜。但是uintptr可以。所以，涉及到指针运算的时候，我们可以转化为<code>uintptr</code>计算，之后再转化回去。利用<code>uintprt</code> 我们可以访问特定的内存，可以达到对特定内存的读写</p><h2 id="uintptr"><a href="#uintptr" class="headerlink" title="uintptr"></a>uintptr</h2><p>写一个uintptr直接操作内存的代码<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">u := <span class="built_in">new</span>(user)</span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>,u)</span><br><span class="line">pname := (*<span class="keyword">string</span>)(unsafe.Pointer(u))</span><br><span class="line">*pname = <span class="string">"xuxiaofeng"</span></span><br><span class="line"></span><br><span class="line">page := (*<span class="keyword">int64</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(u))+unsafe.Offsetof(u.age)))</span><br><span class="line">*page = <span class="number">26</span></span><br><span class="line"><span class="comment">// print u</span></span><br><span class="line">fmt.Println(u)  <span class="comment">//&amp;&#123;xuxiaofeng 26&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>name</code>值是user的第一个字段，不用偏移<br><code>age</code> 是第二个字段，需要便宜。就需要用到uintptr和unsafe.Pointer</p><p><strong>注意事项</strong></p><blockquote><p>如若改成下面的代码，虽然从逻辑上是对的<br>但是这里会牵涉到GC，如果我们的这些临时变量被GC，那么导致的内存操作就错了，我们最终操作的，就不知道是哪块内存了，会引起莫名其妙的问题。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">temp:=<span class="keyword">uintptr</span>(unsafe.Pointer(u))+unsafe.Offsetof(u.age)</span><br><span class="line">pAge:=(*<span class="keyword">int</span>)(unsafe.Pointer(temp))</span><br><span class="line">*pAge = <span class="number">20</span></span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> golang学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 指针转化 </tag>
            
            <tag> unsafe </tag>
            
            <tag> Pointer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>golang切片的使用和本质</title>
      <link href="/2019/01/03/golang-2019-01-03-golang%E5%88%87%E7%89%87%E4%BD%BF%E7%94%A8%E5%92%8C%E6%9C%AC%E8%B4%A8/"/>
      <url>/2019/01/03/golang-2019-01-03-golang%E5%88%87%E7%89%87%E4%BD%BF%E7%94%A8%E5%92%8C%E6%9C%AC%E8%B4%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h1><p>切片中有三个字段，</p><ul><li>指向底层数组的指针</li><li>切片的长度</li><li>切片的容量</li></ul><h1 id="声明和初始化"><a href="#声明和初始化" class="headerlink" title="声明和初始化"></a>声明和初始化</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1：声明</span></span><br><span class="line">s1 := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">5</span>)</span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">5</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接创建并且初始哈</span></span><br><span class="line">s3 := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">s4 := []<span class="keyword">int</span>&#123;<span class="number">4</span>:<span class="number">6</span>&#125; <span class="comment">//第四个元素是6，其他的默认</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组和切片的区别</span></span><br><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">4</span>:<span class="number">1</span>&#125;  <span class="comment">//切片</span></span><br><span class="line">array := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">4</span>:<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空切片和nil切片</span></span><br><span class="line"><span class="comment">// 切片还有nil切片和空切片，它们的长度和容量都是0，但是它们指向底层数组的指针不一样</span></span><br><span class="line"><span class="comment">// nil切片意味着指向底层数组的指针为nil，而空切片对应的指针是个地址</span></span><br><span class="line">s6 := []<span class="keyword">int</span>&#123;&#125;  <span class="comment">//空切片</span></span><br><span class="line"><span class="keyword">var</span> s7 []<span class="keyword">int</span>   <span class="comment">// nil切片</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于现有的切片或数组创建</span></span><br><span class="line">sl := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">sl1 := sl[:]</span><br><span class="line">sl2 := sl[:<span class="number">2</span>]</span><br></pre></td></tr></table></figure><h2 id="基于数据或者切片创建新切片"><a href="#基于数据或者切片创建新切片" class="headerlink" title="基于数据或者切片创建新切片"></a>基于数据或者切片创建新切片</h2><p>基于数据或者切片创建一个新切片后，新切片和原切片共用一个底层数组</p><blockquote><p>基于切片创建新切片</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">s1 := s[:]</span><br><span class="line">fmt.Println(s1)  <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">s[<span class="number">0</span>] = <span class="number">88</span></span><br><span class="line">fmt.Println(s1)   <span class="comment">//[88 2 3 4 5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>基于数组创建新切片</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">s1 := s[:]</span><br><span class="line">fmt.Println(s1)  <span class="comment">//[1 2 3 4 5 ]</span></span><br><span class="line">s[<span class="number">0</span>] = <span class="number">88</span></span><br><span class="line">fmt.Println(s1)   <span class="comment">//[88 2 3 4 5]</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="新切片的长度和容量"><a href="#新切片的长度和容量" class="headerlink" title="新切片的长度和容量"></a>新切片的长度和容量</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s))   <span class="comment">// 6</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(s))  <span class="comment">//6</span></span><br><span class="line"></span><br><span class="line">s1 := s[<span class="number">1</span>:<span class="number">2</span>]</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s1))  <span class="comment">// 1</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(s1))  <span class="comment">// 5 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s2 := s[<span class="number">1</span>:<span class="number">5</span>]</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s2))  <span class="comment">//4</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(s2))  <span class="comment">//5 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s3 := s[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s3))  <span class="comment">//2</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(s3))  <span class="comment">//6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>规律就是：新切片长度还算正常，但是容量就是从你截取的部分一直到原切片容量的结束。这也符合切片在内存中线性分布的特征</p><h1 id="切片的使用"><a href="#切片的使用" class="headerlink" title="切片的使用"></a>切片的使用</h1><h2 id="长度和容量房"><a href="#长度和容量房" class="headerlink" title="长度和容量房"></a>长度和容量房</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">5</span>,<span class="number">10</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s))  <span class="comment">// 5</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(s))  <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="取值和修改"><a href="#取值和修改" class="headerlink" title="取值和修改"></a>取值和修改</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">5</span>,<span class="number">10</span>)</span><br><span class="line">fmt.Println(s[<span class="number">2</span>])<span class="comment">// 0</span></span><br><span class="line">s[<span class="number">2</span>] = <span class="number">88</span>  </span><br><span class="line">fmt.Println(s[<span class="number">2</span>])<span class="comment">// 88</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="append"><a href="#append" class="headerlink" title="append"></a>append</h2><h3 id="可用容量足够"><a href="#可用容量足够" class="headerlink" title="可用容量足够"></a>可用容量足够</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">s1 := s[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">fmt.Println(s1)  <span class="comment">//[2,3]</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(s1))</span><br><span class="line">s1 = <span class="built_in">append</span>(s1,<span class="number">66</span>)</span><br><span class="line">fmt.Println(s1) <span class="comment">//[2,3,66]</span></span><br><span class="line">fmt.Println(s)  <span class="comment">//[1,2,3,66,5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>s1中增加66很正常，为什么s的值中也会去掉4，而增加66呢？</p><ol><li>s1有可用的容量，不会创建新的切片来满足追加</li><li>s1和s共用一个底层数组<br>其实这里的追加只是把第四个元素4，替换成了66</li></ol></blockquote><h3 id="可用容量不够"><a href="#可用容量不够" class="headerlink" title="可用容量不够"></a>可用容量不够</h3><p>当容量不够的时候，会把原来的数组复制一份，再增加新值，这时候对新切片的操作就不会影响旧切片了。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">s1:= s[:]</span><br><span class="line">fmt.Printf(<span class="string">"%p:%v\n"</span>,s1,s1) <span class="comment">//0x452000:[1 2 3 4 5]</span></span><br><span class="line"><span class="comment">// 此时两者共用一个底层数组，一个变都变</span></span><br><span class="line">s1[<span class="number">0</span>] = <span class="number">66</span></span><br><span class="line">fmt.Println(s)  <span class="comment">//[66 2 3 4 5]</span></span><br><span class="line">fmt.Println(s1)  <span class="comment">//[66 2 3 4 5]</span></span><br><span class="line"><span class="comment">// s1 append之后，容量不够了，会把底层数组复制一份。</span></span><br><span class="line">s1 = <span class="built_in">append</span>(s1,<span class="number">6</span>)</span><br><span class="line">fmt.Println(s) <span class="comment">//[66 2 3 4 5]</span></span><br><span class="line">fmt.Println(s1)  <span class="comment">//[66 2 3 4 5 6]</span></span><br><span class="line"><span class="comment">// 再改变s1,s就没有收到影响</span></span><br><span class="line">s1[<span class="number">0</span>] = <span class="number">88</span></span><br><span class="line">fmt.Println(s)  <span class="comment">//[66 2 3 4 5]</span></span><br><span class="line">fmt.Println(s1)  <span class="comment">//[88 2 3 4 5 6]</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>建议：<br>我们再创建切片的时候，尽量让长度和容量相同。这样我们再追加操作的时候，就可以生成新的底层数据。会减免一些共用底层数据引起的错误。</p></blockquote><p>append函数会智能的增长底层数组的容量，目前的算法是：容量小于1000个时，总是成倍的增长，一旦容量超过1000个，增长因子设为1.25，也就是说每次会增加25%的容量。</p><p>我们看append函数的定义：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(slice []Type, elems ...Type)</span> []<span class="title">Type</span></span></span><br></pre></td></tr></table></figure></p><p>所以我们可以穿多个值，也可以传切片<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">s1 = <span class="built_in">append</span>(s1,<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line">s1 = <span class="built_in">append</span>(s1,[]<span class="keyword">int</span>&#123;<span class="number">8</span>,<span class="number">9</span>&#125;...)</span><br></pre></td></tr></table></figure></p><h1 id="slice-append灾难"><a href="#slice-append灾难" class="headerlink" title="slice append灾难"></a>slice append灾难</h1><p>首先分析下面的代码<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Slice []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(A Slice)</span><span class="title">Append</span><span class="params">(value <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">A = <span class="built_in">append</span>(A, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">mSlice := <span class="built_in">make</span>(Slice, <span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">mSlice.Append(<span class="number">5</span>)</span><br><span class="line">fmt.Println(mSlice)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>抛开代码的规范性不说，这段代码本意是要调用一次<code>mSlice.Append(5)</code> ,就往mSlice中添加一个值。但是结果却是无论怎么Append，mSlice都不变。<br>这里有一篇详细的解释<br><a href="https://www.flysnow.org/2018/12/21/golang-sliceheader.html" target="_blank" rel="noopener">https://www.flysnow.org/2018/12/21/golang-sliceheader.html</a><br>其实主要的区别就是这句话中<code>A = append(A, value)</code>,<code>=</code>两边的A已经不是同一个了。<br>我们可以更改一下代码<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Slice []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(A Slice)</span><span class="title">Append</span><span class="params">(value <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">A1 := <span class="built_in">append</span>(A,value)</span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span>,A)</span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span>,A1)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">mSlice := <span class="built_in">make</span>(Slice, <span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">mSlice.Append(<span class="number">5</span>)</span><br><span class="line">fmt.Println(mSlice)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>？？打印出来的是相同的啊，为什么说不一样，看下面</p><h2 id="SliceHeader"><a href="#SliceHeader" class="headerlink" title="SliceHeader"></a>SliceHeader</h2><p>SliceHeader是Slice运行时的具体表现，它的结构定义如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">Data <span class="keyword">uintptr</span></span><br><span class="line">Len  <span class="keyword">int</span></span><br><span class="line">Cap  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们把代码改变成这样<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(A Slice)</span><span class="title">Append</span><span class="params">(value <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">A1 := <span class="built_in">append</span>(A, value)</span><br><span class="line"></span><br><span class="line">sh:=(*reflect.SliceHeader)(unsafe.Pointer(&amp;A))</span><br><span class="line">fmt.Printf(<span class="string">"A Data:%d,Len:%d,Cap:%d\n"</span>,sh.Data,sh.Len,sh.Cap)</span><br><span class="line"></span><br><span class="line">sh1:=(*reflect.SliceHeader)(unsafe.Pointer(&amp;A1))</span><br><span class="line">fmt.Printf(<span class="string">"A1 Data:%d,Len:%d,Cap:%d\n"</span>,sh1.Data,sh1.Len,sh1.Cap)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// A Data:4530176,Len:10,Cap:20</span></span><br><span class="line"><span class="comment">// A1 Data:4530176,Len:11,Cap:20</span></span><br></pre></td></tr></table></figure></p><p>这下大家明白了吧，他们的Len不一样，并不是一个Slice，所以使用append方法并没有改变原来的A，而是新生成了一个A1,A1只是在方法内有效。而且新生成的A1并没有return。即使Dreamerque这位朋友通过如下代码 A = append(A, value) 进行复制，也只是一个mSlice的拷贝A的指向被改变了，而且这个A只在Append方法内有效（其实就是上面的A1），mSlice本身并没有改变，所以输出的mSlice不会有任何变化。</p><p>这里正确的做法是让Append返回append后的结果。其实对于内置函数append的使用，Go语言(golang)官方做了说明的，要保存返回的值。</p><p><em>Append returns the updated slice. It is therefore necessary to store the result of append</em></p>]]></content>
      
      
      <categories>
          
          <category> golang学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 切片 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>标志寄存器</title>
      <link href="/2018/12/22/study-%E7%BC%96%E7%A8%8B%E8%BE%BE%E4%BA%BA-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%913%E6%9C%9F%E5%AD%A6%E4%B9%A0-2018-12-25-%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8/"/>
      <url>/2018/12/22/study-%E7%BC%96%E7%A8%8B%E8%BE%BE%E4%BA%BA-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%913%E6%9C%9F%E5%AD%A6%E4%B9%A0-2018-12-25-%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="crackme-exe-引出标志寄存器"><a href="#crackme-exe-引出标志寄存器" class="headerlink" title="crackme.exe 引出标志寄存器"></a>crackme.exe 引出标志寄存器</h1><p>现在有一个crackme.exe的程序，进去后需要我们注册成功后才可以使用。要想破解这个小软件，我们需要掌握哪些东西呢？</p><ol><li>PE</li><li>断点<br>我们随便输入一个用户名和密码，就会弹出一个失败提示框。我们就在弹出提示框的地方打断点。</li><li>win32 API<br>我们知道要在弹出提示框的地方打断点，可是只有我们知道了win32的API后，我们才知道， 那就是一个messageBoxA<br><code>bp messageBoxA</code></li><li>函数调用</li><li>熟悉堆栈，熟练绘画堆栈图</li></ol><blockquote><p>如果熟悉堆栈，肯定知道，一个函数调用的时候，栈顶的位置肯定放着它的放回地址。所以函数执行完毕后，就会返回到栈顶编号对应的位置。</p></blockquote><ol start="6"><li><p>call 、 jcc and 标志寄存器<br>最后判断我们输入的对不对，是否继续，其实就是判断某个标志寄存器中的值</p></li><li><p>copy to executable -&gt; 保存即可完成我们的修改</p></li></ol><p><strong>以上的东西其实就是暴力破解，不管你算法多么优秀，我们只找那个关键点，让你直接进行下一步</strong></p><h1 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h1><p><img src="https://upload-images.jianshu.io/upload_images/422094-ff61e2505145f6be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>这就是计算机中的标志寄存器，说到标志我们就应该想到flag，bool类型。而一个bool类型用1bit就可以表示了，所以我们谈论这个32位的标志寄存器，更多的时候是讨论其中的某一位。<br>比如0位，2位，4位，都是cpu中设定好的用途，就跟通用寄存器一样，有自己的名字。比如C位，P位，O位。</p><h2 id="进位标志位CF（carry-flag）"><a href="#进位标志位CF（carry-flag）" class="headerlink" title="进位标志位CF（carry flag）"></a>进位标志位CF（carry flag）</h2><blockquote><p>如果运算结果的最高位产生了一个进位或借位，那么，其值为1，否则其值为0。</p></blockquote><p>三个实验:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mov al,0xff</span><br><span class="line">add al,2   // c位变成1</span><br><span class="line">mov al,0xfe // mov不是运算所以C位不变</span><br><span class="line">// C位手动清零</span><br><span class="line">add al,2 // c位又变成1</span><br><span class="line">// C位手动清零</span><br><span class="line">mov ax,0xff</span><br><span class="line">add ax,2  // c位已经是0</span><br><span class="line">// =========================重点</span><br><span class="line">// 标志寄存器在学习过程中，我们一定要明白数据的宽度 </span><br><span class="line">//【mov ax，0xff 】中，数据的宽度是16位，add之后，确实是进位了，但不是最高位的进位</span><br></pre></td></tr></table></figure></p><blockquote><p>补充：什么是运算？<br>mov不算是运算，其他的加减乘除异或等都是运算</p></blockquote><h2 id="奇偶标志位：PF（Parity-Flag）"><a href="#奇偶标志位：PF（Parity-Flag）" class="headerlink" title="奇偶标志位：PF（Parity Flag）"></a>奇偶标志位：PF（Parity Flag）</h2><blockquote><p>PF 反应运算结果中“1”的个数的奇偶性，如果1的个数是偶数，则P位是1，如果1的个数是奇数，则P位是0</p></blockquote><p>实验<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV AL,3  // 00001011 p位：0</span><br><span class="line">add al,2  // 00001010 P位：1</span><br></pre></td></tr></table></figure></p><h2 id="辅助进位标志AF-Auxiliary-Carry-Flag"><a href="#辅助进位标志AF-Auxiliary-Carry-Flag" class="headerlink" title="辅助进位标志AF(Auxiliary Carry Flag)"></a>辅助进位标志AF(Auxiliary Carry Flag)</h2><blockquote><p>在发生下列情况时，辅助进位标志AF的值被置为1，否则其值为0：<br>(1)、在字节操作时，发生低字节向高字节进位或借位时；<br>(2)、在字节操作时，发生低4位向高4位进位或借位时。<br>大白话说下，就是运算时，把位划分成两半，低位的一半的第一位如果向高位进位（加）或者借位（减）时，A位就是1<br>如下图，就看突出的那一位<br>32位运算： _ _ _ _  - _ _ _<br>16位运算： _ _ - _<br>8位运算：   _ -</p></blockquote><p>实验：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 第一组</span><br><span class="line">MOV EAX,0x55EEFFFF</span><br><span class="line">ADD EAX,2    // A位变1</span><br><span class="line">// 第二组</span><br><span class="line">MOV AX,5EFE  </span><br><span class="line">add ax,2  // A位又变1</span><br><span class="line">// 第三组</span><br><span class="line">MOV AL,4E</span><br><span class="line">add al,2 // A位又变1</span><br></pre></td></tr></table></figure></p><h2 id="零标志ZF-Zero-Flag"><a href="#零标志ZF-Zero-Flag" class="headerlink" title="零标志ZF(Zero Flag)"></a>零标志ZF(Zero Flag)</h2><blockquote><p>零标志ZF用来反映运算结果是否为0<br>如果运算结果为0，则其值为1，否则其值为0。在判断运算结果是否为0时，可使用此标志位。</p></blockquote><p>实验<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">XOR EAX,EAX  // Z位：1</span><br><span class="line">// 这句话的作用有两个</span><br><span class="line">// 1.将EAX的值变为1</span><br><span class="line">// 2.将标志位Z位置为1。如果[mov eax,0] 的话就没有第二个作用了,mov就不是运算</span><br></pre></td></tr></table></figure></p><h2 id="符号标志SF-Sign-Flag"><a href="#符号标志SF-Sign-Flag" class="headerlink" title="符号标志SF(Sign Flag)"></a>符号标志SF(Sign Flag)</h2><blockquote><p>符号标志SF用来反映运算结果的符号位，它与运算结果的最高位相同。<br>特别注意：这里的最高位说的是二进制的最高位，所以只能是0或1</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV AL,7F</span><br><span class="line">ADD AL,2   // 1</span><br></pre></td></tr></table></figure><h2 id="溢出标志OF-Overflow-Flag"><a href="#溢出标志OF-Overflow-Flag" class="headerlink" title="溢出标志OF(Overflow Flag)"></a>溢出标志OF(Overflow Flag)</h2><blockquote><p>溢出标志OF用于反映<strong>有符号数</strong>加减运算所得结果是否溢出。<br>如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF的值被置为1，否则，OF的值被清为0。</p></blockquote><p>最高位进位（CF）和溢出（OF）的区别？<br>这里主要涉及到了无符号整数和有符号整数。计算机在存储的时候，并不知道自己存储的是有符号整数还是无符号整数。只有使用的人才知道，就是程序员喽。<br><strong>C位是做无符号运算时该关注的</strong><br><strong>O位是做有符号运算时该关注的</strong></p><blockquote><p>想知道现在计算的结果有没有溢出，是看CF位还是OF位？<br>我要看那个取决于我做的是有符号还是无符号运算。<br> 如果你知道自己做的是无符号运算，你只用看C位，不用管O位<br>如果你知道自己的做的是有符号运算，只要看O位，不用管C位</p></blockquote><p>好好看这个图就什么都明白了<br><img src="https://upload-images.jianshu.io/upload_images/422094-3ad495cb7405f026.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/422094-f6ffe2cae7646bfe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>正数+负数，一定在圈内，永远不会溢出<br>正数+正数，如果结果为负数（超过7F内），一定溢出。因为越界了，两个正数相加不应该是负数。</p><p>说结果之前，一定要指定到底是无符号运算还是有符号预算。<br><img src="https://upload-images.jianshu.io/upload_images/422094-4a9e51373fbc748d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>自己这个分析判断是错误的，其实只要是圈上的点可以表示的，都没有溢出，圈上的点不能表示的，就是溢出了。<br>只是有符号的话，只有右边区域表示正数，左边区域表示负数<br>无符号的话，整个区域都可以表示</p><h1 id="和标志寄存器相关的指令"><a href="#和标志寄存器相关的指令" class="headerlink" title="和标志寄存器相关的指令"></a>和标志寄存器相关的指令</h1><h2 id="ADC指令：带进位加法"><a href="#ADC指令：带进位加法" class="headerlink" title="ADC指令：带进位加法"></a>ADC指令：带进位加法</h2><p><img src="https://upload-images.jianshu.io/upload_images/422094-1ec8a53efc66fbaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p>百度百科：<br>ADC 带进位的加法指令 ADC Reg/Mem, Reg/Mem/Imm 功能，将目的<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E6%95%B0" target="_blank" rel="noopener">操作数</a>和源操作数相加再加低位进位，结果送入目的的地址 dst+src+cf-&gt;dst， 受影响的标志位：AF、CF、OF、PF、SF和ZF，该指令的功能是把源操作数和进位标志位CF的值(0/1)一起加到目的操作数中。</p></blockquote><p>实验<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MOV AL,1</span><br><span class="line">MOV CL,2</span><br><span class="line">ADC AL,CL //按照我们正常的ADD指令，此时AL中应该是3</span><br><span class="line">// 但是ADC指令是带进位的加法,它会把c位中的值也给加上。</span><br><span class="line">// 如果此时cf中的值是1，那结果:AL中的值是4，cf的值：0</span><br></pre></td></tr></table></figure></p><p>注意事项：1.两边</p><h2 id="SBB指令：带借位减法"><a href="#SBB指令：带借位减法" class="headerlink" title="SBB指令：带借位减法"></a>SBB指令：带借位减法</h2><p><img src="https://upload-images.jianshu.io/upload_images/422094-02081cd06522e891.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p>百度百科的解释很明确<br>SBB：带借位减法， 格式：SBB DST,SRC, 执行的操作：（DST)←(DST)-(SRC)-CF,其中CF为进位的值。 SBB Compents ：他们组成了Application .他们以何种方式组合是由<a href="https://baike.baidu.com/item/SLEE" target="_blank" rel="noopener">SLEE</a>来确定的。</p></blockquote><p>实验<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MOV AL,3</span><br><span class="line">MOV CL,1</span><br><span class="line">SBB AL,CL </span><br><span class="line">// 分两种情况：</span><br><span class="line">// 1. 如果cf是0，那么结果和我们预想的一样，2</span><br><span class="line">// 2. 如果cf是1，那么结果还会减1，结果al变为1了</span><br></pre></td></tr></table></figure></p><h2 id="XCHG指令：交换数据"><a href="#XCHG指令：交换数据" class="headerlink" title="XCHG指令：交换数据"></a>XCHG指令：交换数据</h2><p><img src="https://upload-images.jianshu.io/upload_images/422094-812f0841db6ec3d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p>百度百科<br>交换指令XCHG是两个寄存器，寄存器和<a href="https://baike.baidu.com/item/%E5%86%85%E5%AD%98%E5%8F%98%E9%87%8F/3389507" target="_blank" rel="noopener">内存变量</a>之间内容的交换指令，两个<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E6%95%B0/7658270" target="_blank" rel="noopener">操作数</a>的数据类型要相同，可以是一个字节，也可以是一个字，也可以是双字</p></blockquote><p>说明什么？<br>我们交换的是两个容器，不能是立即数<br>而且交换的两个容器不能都是内存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 实验：</span><br><span class="line">MOV AL,1</span><br><span class="line">MOV CL,3</span><br><span class="line">XCHG AL,CL  // AL变成3，CL变成了1</span><br><span class="line"></span><br><span class="line">XCHG DWORD PTR DS:[0X0019FF74],EAX</span><br></pre></td></tr></table></figure><h2 id="MOVS指令：移动数据"><a href="#MOVS指令：移动数据" class="headerlink" title="MOVS指令：移动数据"></a>MOVS指令：移动数据</h2><p><img src="https://upload-images.jianshu.io/upload_images/422094-0ce184cae123305c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>看了一下通用寄存器中EDI和ESI的分工：<br><img src="https://upload-images.jianshu.io/upload_images/422094-40fb7a58383a8153.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>再回顾一下通用寄存器的划分：<br><a href="https://xuxiaofeng.gitlab.io/2018/12/12/study-%E7%BC%96%E7%A8%8B%E8%BE%BE%E4%BA%BA-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%913%E6%9C%9F%E5%AD%A6%E4%B9%A0-2018-12-12-%E8%BF%9B%E4%B8%80%E6%AD%A5%E5%AD%A6%E4%B9%A0%E5%AF%84%E5%AD%98%E5%99%A8/" target="_blank" rel="noopener">https://xuxiaofeng.gitlab.io/2018/12/12/study-%E7%BC%96%E7%A8%8B%E8%BE%BE%E4%BA%BA-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%913%E6%9C%9F%E5%AD%A6%E4%B9%A0-2018-12-12-%E8%BF%9B%E4%B8%80%E6%AD%A5%E5%AD%A6%E4%B9%A0%E5%AF%84%E5%AD%98%E5%99%A8/</a><br><img src="https://upload-images.jianshu.io/upload_images/422094-6f2365cc4e601eda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>现在我们来解释MOVS指令</p><blockquote><p>movs指令是用来复制一个数据项（字节，字或双字）从源字符串到目标字符串。原字符串又ESI/SI/DH 指出，目标字符串又EDI/DI/BH指出。（具体又那个指出，我们需要看使用时定义的单位）</p></blockquote><blockquote><p>这里还有一段解释：<br>MOVS指令可以把由（SI）指向的数据段中的一个字（或字节）传送到由（DI）指向的附加段中的一个字（或字节）中去，同时根据方向标志(df标志寄存器)及数据格式（字 或字节）对SI和DI进行修改</p></blockquote><blockquote><p>在执行该指令前，应该先做好以下 准备工作：<br>   1） 把存放于数据段中的源串首地址（如反向传送则应是末地址）放入SI寄存器中；<br>   2） 把将要存放数据串的附加段中的目的串首地址（或反向传送时的末地址）放入DI寄存器中；<br>   3） 建立方向标志。</p></blockquote><p>实验<br>首先说明一下，我们之前碰到内存的时候，我们总是这样表示DS:[],没错。但是碰到EDI表示内存地址单元时，我们应该这样ES:[],所以往下，我们会经常看到这样的字符：ES:[EDI] （这里涉及到段、页的概念）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> 1.直接输入movs，点击确定，编辑器就会自动给我们生成下面的额语句</span><br><span class="line">  充分说明了这个指令是针对EDI和ESI的</span><br><span class="line">MOVS DWORD PTR ES:[EDI],DWORD PTR DS:[ESI]</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov edi,0019ff88</span><br><span class="line">mov esi,0019ff80</span><br><span class="line">MOVS DWORD PTR ES:[EDI],DWORD PTR DS:[ESI]  </span><br><span class="line">结果</span><br><span class="line">edi:0019ff8c</span><br><span class="line">esi:0019ff84</span><br><span class="line">并且刚才edi对应内存编号中的值和dsi对应内存编号中的值确实做了交换</span><br><span class="line">我们发现EDI和ESI中的值都+4 了。这是有D位（df标志寄存器决定的）</span><br></pre></td></tr></table></figure><p>所以这个<code>MOVS</code>指令有两个主要影响，一是真的交换了寄存器对应内存地址单元中的值，二是根据DF标志寄存器中的值，让ESI和EDI都进行一些位移。</p><h2 id="STOS指令：讲Al-AX-EAX的值存储到-EDI-指定的内存单元"><a href="#STOS指令：讲Al-AX-EAX的值存储到-EDI-指定的内存单元" class="headerlink" title="STOS指令：讲Al/AX/EAX的值存储到[EDI]指定的内存单元"></a>STOS指令：讲Al/AX/EAX的值存储到[EDI]指定的内存单元</h2><blockquote><p>到底是复制AL还是AX还是EAX，是又我们指定的内存宽度决定的<br>。复制完毕后，EDI的变化方向是由我们的D位（df标志寄存器）决定的。</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/422094-7184e842698d25a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 实验</span><br><span class="line">mov eax,12345678</span><br><span class="line">mov edi,0019ff88</span><br><span class="line">直接数据stos，确定酒水弹出下面的值</span><br><span class="line">STOS DWORD PTR ES:[EDI]</span><br><span class="line">运行结果（D位此时是0）</span><br><span class="line">DEI：0019FF8C</span><br><span class="line">内存单元0019FF88中的值：12345678</span><br></pre></td></tr></table></figure></p><h2 id="REP指令：按计数寄存器-ECX-中指定的次数重复执行字符串指令"><a href="#REP指令：按计数寄存器-ECX-中指定的次数重复执行字符串指令" class="headerlink" title="REP指令：按计数寄存器 (ECX) 中指定的次数重复执行字符串指令"></a>REP指令：按计数寄存器 (ECX) 中指定的次数重复执行字符串指令</h2><p>这里有一个把movs和rep指令糅合在一起的解释</p><p>MOVS指令可以把由（SI）指向的数据段中的一个字（或字节）传送到由（DI）指向的附加段中的一个字（或字节）中去，同时根据方向标志及数据格式（字 或字节）对SI和DI进行修改。当该指令与前缀REP联用时，则可将数据段中的整串数据传送到附加段中去。这里源串必须在数据段中，目的串必须在附加段 中，但源串允许使用段跨越前缀来修改。在与REP联用时还必须先把数据串的长度送到CX寄存器中，以便控制指令结束。因此在执行该指令前，应该先做好以下 准备工作：<br>   1） 把存放于数据段中的源串首地址（如反向传送则应是末地址）放入SI寄存器中；<br>   2） 把将要存放数据串的附加段中的目的串首地址（或反向传送时的末地址）放入DI寄存器中；<br>   3） 把数据串长度放入CX寄存器；<br>   4） 建立方向标志。<br>在完成这些准备工作后就可使用串指令传送信息了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV ECX,10</span><br><span class="line">REP MOVSD</span><br><span class="line">REP STOSD</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 滴水逆向三期视频教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滴水逆向 </tag>
            
            <tag> 汇编 </tag>
            
            <tag> 标志寄存器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git系统学习</title>
      <link href="/2018/12/21/tools-git-2018-12-21-git%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
      <url>/2018/12/21/tools-git-2018-12-21-git%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="git的特性"><a href="#git的特性" class="headerlink" title="git的特性"></a>git的特性</h1><ol><li>版本控制<br>最终版，最终版1，最终版2</li><li>分布式<br>分布式和集中式都需要中央服务器，不同的是分布式在工作电脑上保存了服务器的完整工程，即使服务器挂掉了，也不会影响工作电脑上的开发。<br>集中式就不可以了。中央服务器挂掉，其他人就都不可以开发了。</li></ol><h1 id="git的安装和基本使用"><a href="#git的安装和基本使用" class="headerlink" title="git的安装和基本使用"></a>git的安装和基本使用</h1><p>安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure></p><p>基本使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//目录初始化</span><br><span class="line">git init </span><br><span class="line">// 创建版本</span><br><span class="line">vim code.txt</span><br><span class="line">git add code.txt</span><br><span class="line">git commit -m &quot;create file code.txt&quot;</span><br><span class="line">// 查看版本记录</span><br><span class="line">git log</span><br><span class="line">// 版本回退</span><br><span class="line">git reset --hard HEAD^  // HEAD表示当前的最新版本，也可以用版本编号（commit hash）</span><br><span class="line">// HEAD^也是这样表示HEAD~1,回退四个版本git reset --hard HEAD~4</span><br></pre></td></tr></table></figure></p><blockquote><p>使用git reset 回退到低版本后，高版本并没有删掉。（但是git log看不到了）如果我们现在又想回到高版本该如何做？<br>git log看不到高版本的版本编号了，我们可以用<code>git reflog</code> 查看历史操作。就会看到我们高版本的commit hash（版本编号）<br><code>git reset --hard 版本编号</code></p></blockquote><h1 id="工作区和版本库"><a href="#工作区和版本库" class="headerlink" title="工作区和版本库"></a>工作区和版本库</h1><p>工作区就是本地工作的目录<br>版本库就是我们工作区下面的.git文件。</p><blockquote><p>git版本库里有很多东西，其中最重要的就是本称为stage（或者叫index）的暂存区。</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/422094-0e08b7c332e4226b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p>已经git add 到暂存区的文件，如何恢复？<br>git reset HEAD <file><br>就相当于git add 命令的倒退，从暂存区清理code.txt,但是工作区的修改依然在。此时用git status，应该又提示文件修改，需要你git add</file></p></blockquote><blockquote><p>git只会用暂存区的修改来创建版本，工作区的修改如果没有添加到暂存区。git commit创建的版本中是不会包括工作区修改的内容的。<br>vim code.txt -&gt; 添加第一行<br>git add code.txt<br>vim code.txt -&gt; 添加第二行<br>// 没有git add 直接git commit<br>git commit -m “update code.txt”  // 这个版本中是没有第二行内容的</p></blockquote><h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><p>编辑完工作区后，想撤销对工作区的修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- &lt;file&gt;</span><br></pre></td></tr></table></figure></p><p>编辑完文件，git add 提交到暂存区，突然又不想到暂存区的此文件的改动了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD &lt;file&gt;  // 这就是取消暂存</span><br><span class="line">想要继续丢弃工作区的改动</span><br><span class="line">git checkout -- &lt;file&gt;</span><br></pre></td></tr></table></figure></p><blockquote><p>总结撤销修改的三种情况<br>1.只在工作区修改，还没有提交到暂存区<br>git checkout –  <file><br>2.工作区修改后，git add 提交到了暂存区<br>git reset head <file><br>git checkout  – <file><br>3 git add 并且已经git commit<br>git reset –hard HEAD^</file></file></file></p></blockquote><h1 id="git对比文件"><a href="#git对比文件" class="headerlink" title="git对比文件"></a>git对比文件</h1><h2 id="工作区和版本库中的对比"><a href="#工作区和版本库中的对比" class="headerlink" title="工作区和版本库中的对比"></a>工作区和版本库中的对比</h2><p>git diff HEAD – <file><br>将工作区和版本库HEAD进行比较<br>如何看比较的内容？<br>—和+++ ，分队对应diff后面的第一个和第二个</file></p><blockquote><p>— a/<file>   代表HEAD版本中的<br>+++ b/<file>   代表工作区的<br>前面没有出现+或者-的，就是两个文件共有的</file></file></p></blockquote><h2 id="两个版本库中的对比"><a href="#两个版本库中的对比" class="headerlink" title="两个版本库中的对比"></a>两个版本库中的对比</h2><p>git diff HEAD HEAD^</p><h1 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rm &lt;file&gt;</span><br><span class="line">// 将删除的改动提交到暂存区</span><br><span class="line">git add &lt;file&gt;</span><br><span class="line">// 将删除的改动提交到版本库</span><br><span class="line">git commit - &quot;delete&quot;</span><br></pre></td></tr></table></figure><blockquote><p>rm <file> 和 git add <file>,两个命令可以合为一个，git rm <file></file></file></file></p></blockquote><h2 id="恢复删除"><a href="#恢复删除" class="headerlink" title="恢复删除"></a>恢复删除</h2><p>删除文件也是对工作区的改动，和上面修改文件的恢复是一样的。<br>在工作区删除后，发现删错了。想要恢复怎么办？<br>git checkout – <file></file></p><p><strong>特别注意：</strong><br><img src="https://upload-images.jianshu.io/upload_images/422094-d33c70d1e02f5694.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p>创建文件touch filename.txt后，如果没有git add添加到暂存区，git是不会开始管理这个文件的。<br>这个时候，如果你直接rm filename.txt,就真的删掉了。因为git本来就没有跟踪这个文件。</p></blockquote><h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><p>工厂里面的流水线<br>平行宇宙</p><h2 id="创建分支与合并分支"><a href="#创建分支与合并分支" class="headerlink" title="创建分支与合并分支"></a>创建分支与合并分支</h2><p>主分支，默认分支 master<br>刚才我们说HEAD指向最新的commit，严格的说：HEAD是指向master，master才是指向最新的commit<br><img src="https://upload-images.jianshu.io/upload_images/422094-13343497e65e2800.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/422094-7641de8c4b3ecd80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/422094-904b3e4ce196718d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/422094-42e149b838c4eff4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>合并完分支之后，我们可以删除dev分支。删除dev分支就是把dev指针给删除掉。删掉后，我们就剩下一个master分支。<br><img src="https://upload-images.jianshu.io/upload_images/422094-4484e6b639c58383.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">git branch  //查看当前仓库又多少分支</span><br><span class="line">  * master // *代表当前在那个分支里面</span><br><span class="line">// 创建并切换到新的分支dev</span><br><span class="line">git checkout -b dev</span><br><span class="line">vim code.txt -&gt; add online </span><br><span class="line">git add code.txt  // 在dev分支中进行开发</span><br><span class="line">git commit -m &quot;dev 分支提交&quot;  // 此时master分支并没有改变</span><br><span class="line">// 切换到master分支</span><br><span class="line">git checkout master</span><br><span class="line">// 查看master分支上有没有dev分支的操作记录</span><br><span class="line">git log --pretty=online  //发现并没有dev分支的操作记录</span><br><span class="line">// 合并分支</span><br><span class="line">git merge dev </span><br><span class="line">    执行完命令后，我们发现出现又这样的提示，fast-forward，这属于快速合并。快速合并就是直接挪动master指针就可以。</span><br><span class="line">// 删除分支</span><br><span class="line">git branch -d dev</span><br></pre></td></tr></table></figure><h2 id="分支-解决冲突"><a href="#分支-解决冲突" class="headerlink" title="分支-解决冲突"></a>分支-解决冲突</h2><blockquote><p>合并分支往往不是一帆风顺的。当我们在两个分支上都对一个文件进行修改了。那执行git merge命令的时候，就会提示自动合并失败。并给出冲突失败文件。当然我们执行git status 也会看到合并有冲突的文件。</p></blockquote><p>这时候我们该怎么做？<br>需要手动融合，打开冲突文件进行手动融合。<br>融合之后，需要做一次新的提交。gti add *，git commit - “”<br>。HEAD指向master，master向前移动了，但是dev分支是不动的。</p><blockquote><p><strong>重点</strong><br>有时候我们需要看分支图例<br>git log –graph –pretty=online</p></blockquote><h1 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h1><h2 id="没有快速合并，但是也没有冲突"><a href="#没有快速合并，但是也没有冲突" class="headerlink" title="没有快速合并，但是也没有冲突"></a>没有快速合并，但是也没有冲突</h2><blockquote><p>我们在dev分支和master分支都做了修改，但是修改的不是同一个文件。我们合并时，不能使用fast-forward模式了，但是并没有冲突。</p></blockquote><p>当我们在master分支上git merge dev时，命令行中会出现一次弹窗，让我们输入一个commit信息。<br>这种合并方式时<strong>recursive</strong>合并。这时候，git默认会给我们做一次新的提交。</p><h2 id="强制禁止快速合并"><a href="#强制禁止快速合并" class="headerlink" title="强制禁止快速合并"></a>强制禁止快速合并</h2><p>是在什么样的情景呢？</p><blockquote><p>git checkout -b dev后，在dev分支做了修改，提交了好几个commit。git checkout master，然后git merge dev。此时没有冲突，快速合并成功。<br>但是：我们在dev分支中的commit记录都没有了！！！</p></blockquote><p>解决办法，禁用fast-forward<br><code>git merge --no-ff -m &#39;禁用fast-farword合并&#39; dev</code><br>这样就会重新做一次新的提交。</p><blockquote><p>–no-ff指的是强行关闭fast-forward方式。<br>fast-forward方式就是当条件允许的时候，git直接把HEAD指针指向合并分支的头，完成合并。属于“快进方式”，不过这种情况如果删除分支，则会丢失分支信息。因为在这个过程中没有创建commit<br>git merge –squash 是用来把一些不必要commit进行压缩，比如说，你的feature在开发的时候写的commit很乱，那么我们合并的时候不希望把这些历史commit带过来，于是使用–squash进行合并，此时文件已经同合并后一样了，但不移动HEAD，不提交。需要进行一次额外的commit来“总结”一下，然后完成最终的合并。<br>总结：<br>–no-ff：不使用fast-forward方式合并，保留分支的commit历史<br>–squash：使用squash方式合并，把多次分支commit历史压缩为一次<br><img src="https://upload-images.jianshu.io/upload_images/422094-dcb82122c86bd0d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></blockquote><h2 id="bug分支"><a href="#bug分支" class="headerlink" title="bug分支"></a>bug分支</h2><p>使用场景</p><blockquote><p>我们正在dev分支上开发，突然接到任务说时让我们赶紧修复一个bug。可是我们当前的工作还没有做完，还不能提交。怎么办？</p></blockquote><p>我们可以把工作暂时保存起来。<br>git stash<br>就把我们的工作现场给保护起来了。git status一看，工作区都是干净的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">比如bug时在master分支下面，先git checkout master，然后创建bug分支</span><br><span class="line">git checkout -b bug001</span><br><span class="line">vim main.go</span><br><span class="line">git add mian.go</span><br><span class="line">git commit -m &quot;修复bug001&quot;</span><br><span class="line">git checkout master</span><br><span class="line">git merge --no-ff -m &apos;修复bug001合并&apos; bug001</span><br><span class="line">git branch -d bug001</span><br><span class="line">// 修复完成后，继续回到dev分支干活</span><br><span class="line">git status  //工作区干净</span><br><span class="line">git stash list  //列出保存的工作现场</span><br><span class="line">// 恢复现场</span><br><span class="line">git stash pop </span><br><span class="line">git status //已经回来了</span><br></pre></td></tr></table></figure></p><p>修改bug时，先回到出现bug的分支上面。</p><h2 id="分支管理小结"><a href="#分支管理小结" class="headerlink" title="分支管理小结"></a>分支管理小结</h2><p><img src="https://upload-images.jianshu.io/upload_images/422094-7bae2ea61cec4a30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br> git基本操作小结<br><img src="https://upload-images.jianshu.io/upload_images/422094-28d1479db1025f72.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="git常用操作"><a href="#git常用操作" class="headerlink" title="git常用操作"></a>git常用操作</h1><h2 id="github清空历史提交记录"><a href="#github清空历史提交记录" class="headerlink" title="github清空历史提交记录"></a>github清空历史提交记录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1.Checkout</span><br><span class="line"></span><br><span class="line">   git checkout --orphan latest_branch</span><br><span class="line"></span><br><span class="line">2. Add all the files</span><br><span class="line"></span><br><span class="line">   git add -A</span><br><span class="line"></span><br><span class="line">3. Commit the changes</span><br><span class="line"></span><br><span class="line">   git commit -am &quot;commit message&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4. Delete the branch</span><br><span class="line"></span><br><span class="line">   git branch -D master</span><br><span class="line"></span><br><span class="line">5.Rename the current branch to master</span><br><span class="line"></span><br><span class="line">   git branch -m master</span><br><span class="line"></span><br><span class="line">6.Finally, force update your repository</span><br><span class="line"></span><br><span class="line">   git push -f origin master</span><br></pre></td></tr></table></figure><h2 id="修改commit提示"><a href="#修改commit提示" class="headerlink" title="修改commit提示"></a>修改commit提示</h2><p>已经<code>git add</code>,<code>git commit</code>，还没有<code>git push</code> ,如何修改commit信息？<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit –amend</span><br><span class="line">在打开的vim编辑器中修改信息即可</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>初识堆栈之大白话堆栈</title>
      <link href="/2018/12/20/study-%E7%BC%96%E7%A8%8B%E8%BE%BE%E4%BA%BA-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%913%E6%9C%9F%E5%AD%A6%E4%B9%A0-2018-12-20-%E5%88%9D%E8%AF%86%E5%A0%86%E6%A0%88%E4%B9%8B%E5%A4%A7%E7%99%BD%E8%AF%9D%E5%A0%86%E6%A0%88/"/>
      <url>/2018/12/20/study-%E7%BC%96%E7%A8%8B%E8%BE%BE%E4%BA%BA-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%913%E6%9C%9F%E5%AD%A6%E4%B9%A0-2018-12-20-%E5%88%9D%E8%AF%86%E5%A0%86%E6%A0%88%E4%B9%8B%E5%A4%A7%E7%99%BD%E8%AF%9D%E5%A0%86%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是堆栈"><a href="#什么是堆栈" class="headerlink" title="什么是堆栈"></a>什么是堆栈</h1><h2 id="引出堆栈"><a href="#引出堆栈" class="headerlink" title="引出堆栈"></a>引出堆栈</h2><p>在学习堆栈之前，我们需要从之前寄存器和内存中引出堆栈，我们要思考堆栈有什么必要性？<br>现在假设我们需要一块内存，它可以满足如下功能</p><blockquote><p>1、主要用于临时存储一些数据<br>2、 能够记录存储了多少数据<br>3、 可以很方便的找到需要的数据</p></blockquote><p>对于第一条，有人说直接放寄存器不就可以了吗？但是如果我们有2个字节的数据，有5个字节的数据，都好说。但是如果我有几百，几千个数据呢？寄存器明显就不行了</p><h2 id="还好有高人"><a href="#还好有高人" class="headerlink" title="还好有高人"></a>还好有高人</h2><p>还有在我们之前，有那么多厉害的人。有人设计出这样一块内存，虽然简单，但却刚好满足了上面我们的三个需求。<br><img src="https://upload-images.jianshu.io/upload_images/422094-abe526fe10e2bc5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>为了满足第二条，我们直接top-base；<br>对于第三条，比如我们存储了500个数据，我们需要第50个，我们直接base+50个单位的偏移就可以找到。突然又需要第200个数据，base+200单位的偏移就是。<strong>这里的单位是指byte</strong></p><blockquote><p>还需要注意一点，在window系统中堆栈是往低位扩展了，起初会选择一个值比较大的位置作为base，然后每次往低位扩展，top不断变小。</p></blockquote><h1 id="实验，自己实现堆栈"><a href="#实验，自己实现堆栈" class="headerlink" title="实验，自己实现堆栈"></a>实验，自己实现堆栈</h1><blockquote><p>1.我们使用32位寄存器EBX和EDX作为栈顶和栈底 。<br>2.为了实验的方便，主要是DTDebug显示的方便。我们每次操作都操作4字节</p></blockquote><h2 id="压入数据"><a href="#压入数据" class="headerlink" title="压入数据"></a>压入数据</h2><p><img src="https://upload-images.jianshu.io/upload_images/422094-7e971006ce1037ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>我们就选中内存地址0019FF74吧<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV EBX,0019FF74  //栈底的内存地址（base）</span><br><span class="line">MOV EDX,0019FF74  //栈顶的内存地址（top）</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/422094-cb4e46e42f07f0ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>接下来我们有三种实现方式</p><h3 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h3><p>先存储数据，再移动栈顶<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV DWORD PTR ds:[EDX-4],0xAAAAAAAA</span><br><span class="line">SUB EDX,4</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/422094-12e79587f9c7ff73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h3><p>先移动栈顶，再存储数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SUB EDX,4</span><br><span class="line">MOV DWORD PTR DS:[EDX],0xBBBBBBBB</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/422094-7e8c0a8850ebac24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>先存储数据，再用<code>LEA</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov dword ptr ds:[edx-4],0xCCCCCCCC</span><br><span class="line">lea edx, dword ptr ds:[edx-4]</span><br></pre></td></tr></table></figure></p><blockquote><p>第二句话为什么不是这样<code>lea edx,byte ptr ds:[edx-4]</code>，暂时没有明白?<br>不就是取地址吗？为了一定要4个字节呢？</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/422094-bdc6e2c6f7c7f7a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="方法四："><a href="#方法四：" class="headerlink" title="方法四："></a>方法四：</h3><p>先lea，再存储数据<br><img src="https://upload-images.jianshu.io/upload_images/422094-2a202ac2be2d41f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h2><p>读取第N个数</p><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><p><img src="https://upload-images.jianshu.io/upload_images/422094-477a6cc051833c17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p><img src="https://upload-images.jianshu.io/upload_images/422094-a2714e24e1b83bd8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="弹出数据"><a href="#弹出数据" class="headerlink" title="弹出数据"></a>弹出数据</h2><p>不光要读取栈顶的数据，还需要将栈顶的位置进行移动<br><img src="https://upload-images.jianshu.io/upload_images/422094-dfba00669dfda926.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="操作系统实现的堆栈"><a href="#操作系统实现的堆栈" class="headerlink" title="操作系统实现的堆栈"></a>操作系统实现的堆栈</h1><h2 id="push-and-pop"><a href="#push-and-pop" class="headerlink" title="push and pop"></a>push and pop</h2><p>堆栈是软件设计常用的概念。如果每次我们需要的时候，都需要自己手动实现，效率也太低了。<br>为此，<strong>操作系统</strong>联合<strong>cpu</strong>给我们实现了堆栈。如何联合的呢？<br>cpu提供两个32位的寄存器，ESP和EBP，一个用来存储宅顶，一个用来存储栈底。其实对于cpu来说，这两个寄存器和其他的寄存器并没有什么特殊的地方，只是操作系统按照自己的习惯把他两区别对待了。这两个就用来存储栈顶和栈底，相当于cpu和操作系统的之间的约定。（突然想到了协议）</p><p>那之前我们所有的操作就可以用两个命令代替了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">入栈用push</span><br><span class="line">出战用POP</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/422094-c50ca5a16de53c96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="push和pop操作时，寄存器ESP变化宽度"><a href="#push和pop操作时，寄存器ESP变化宽度" class="headerlink" title="push和pop操作时，寄存器ESP变化宽度"></a>push和pop操作时，寄存器ESP变化宽度</h2><p>ESP中存储的是栈顶的位置，其实就是栈顶的内存编号。根据上一小节，我们每push一次，ESP中的值应该-4；每pop一次，ESP中值应该+4.</p><blockquote><p>question：ESP中的值，每次变化都是4吗？</p></blockquote><p>这个也是要分情况</p><ol><li>push + 立即数,ESP中的内存编号-4<br><code>push 0x1</code> </li><li>push + 寄存器<br><code>push al // 8位，不允许这样操作</code><br><code>push ax // 16位，ESP中的内存编号-2</code></li><li>push + 内存<br><code>push r8</code> push 8位的内存是不允许的<br><code>push r16</code> push ESP中的内存编号-2<br><code>push r32</code> psuh ESP中的内存编号-4</li></ol><p>pop is same with push</p><h1 id="PUSHAD-ADN-POPAD"><a href="#PUSHAD-ADN-POPAD" class="headerlink" title="PUSHAD ADN POPAD"></a>PUSHAD ADN POPAD</h1><p>PUASHAD:把8个通用寄存器中的值存储到堆栈中。</p><p>然后我们可以随意的操作修改寄存器，当我们又需要恢复寄存器的时候：</p><p><code>POPAD</code> ,一个指令就解决问题</p><p>这里涉及到一个知识点，堆栈平衡，我们后续再讨论</p>]]></content>
      
      
      <categories>
          
          <category> 滴水逆向三期视频教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滴水逆向 </tag>
            
            <tag> 汇编 </tag>
            
            <tag> 堆栈 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>内存读写-内存寻址</title>
      <link href="/2018/12/16/study-%E7%BC%96%E7%A8%8B%E8%BE%BE%E4%BA%BA-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%913%E6%9C%9F%E5%AD%A6%E4%B9%A0-2018-12-16-%E5%86%85%E5%AD%98%E8%AF%BB%E5%86%99-%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80/"/>
      <url>/2018/12/16/study-%E7%BC%96%E7%A8%8B%E8%BE%BE%E4%BA%BA-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%913%E6%9C%9F%E5%AD%A6%E4%B9%A0-2018-12-16-%E5%86%85%E5%AD%98%E8%AF%BB%E5%86%99-%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<h1 id="DTDebug再介绍"><a href="#DTDebug再介绍" class="headerlink" title="DTDebug再介绍"></a>DTDebug再介绍</h1><p><img src="https://upload-images.jianshu.io/upload_images/422094-2a6f4869cd460a27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>左下角就是内存数据窗口。<br>最下面是命令行窗口。我们可以输入命令查看某一块内存的数据<br><code>db 0x0019FF74</code>,然后enter，就可以查看到这个内存中的数据<br><img src="https://upload-images.jianshu.io/upload_images/422094-4b38ec0c282b74cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="存储数据的顺序问题"><a href="#存储数据的顺序问题" class="headerlink" title="存储数据的顺序问题"></a>存储数据的顺序问题</h1><p>我们往内存地址0x0019FF74中写入数据,当前0x<br><code>mov dword ptr ds:[0x0019FF74],0x12345678</code><br>F8执行<br><img src="https://upload-images.jianshu.io/upload_images/422094-a5227910ba0ea03b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>内存数据区域显示的数据和堆栈区显示的数据不一致，why?</p><blockquote><p>数据的存储时有顺序的，数据在内存中，总是高位在前，低位在后。</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/422094-34de7b27043ea78b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>0x0019FF74 存储的是78<br>0x0019FF75 存储的是56<br>0x0019FF76 存储的是34<br>0x0019FF77 存储的是12</p><h1 id="内存寻址"><a href="#内存寻址" class="headerlink" title="内存寻址"></a>内存寻址</h1><p>通过前面很多的练习，我们可以发现，设计到内存读写最关键的就是，<strong>找到内存地址，也就是内存编号</strong><br>寻找地址有哪些格式呢，主要有下面5种</p><blockquote><p>下面的所有操作中，我们一定要注意MOV和LEA的区别。</p><ol><li>mov的前后操作数不能都是内存单元</li><li>mov是操作内存中的值<br>lea是操作内存的地址</li></ol></blockquote><h2 id="立即数"><a href="#立即数" class="headerlink" title="[立即数]"></a>[立即数]</h2><p><img src="https://upload-images.jianshu.io/upload_images/422094-9e35fe0ab56be43d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>演示<br>初始状态<br><img src="https://upload-images.jianshu.io/upload_images/422094-18cd760d9f697dc7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>我们添加两条指令<br><img src="https://upload-images.jianshu.io/upload_images/422094-4f77735634a49aa5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="红色所示就是添加的命令"><br>执行后的结果<br><img src="https://upload-images.jianshu.io/upload_images/422094-1e8d2357dd0f9afb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>如果大家有迷惑，到底[0019FF74]位置存储的是12还是78？我们可以用命令证实一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov dword ptr ds:[0x19FF74],0x12345678</span><br><span class="line">mov byte ptr ds:[0x19FF74],0x00</span><br></pre></td></tr></table></figure></p><p>结果<br><img src="https://upload-images.jianshu.io/upload_images/422094-b9986e52070e6da8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>说明byte ptr ds[0x19FF74]存储的是78</p><h3 id="LEA获取内存编号"><a href="#LEA获取内存编号" class="headerlink" title="LEA获取内存编号"></a>LEA获取内存编号</h3><p>再实验一下：<br>初始状态<br><img src="https://upload-images.jianshu.io/upload_images/422094-5e97c5cb2a3a4159.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>添加三条命令<br><img src="https://upload-images.jianshu.io/upload_images/422094-16b92651106800ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>第二条运行完毕<br><img src="https://upload-images.jianshu.io/upload_images/422094-3e4533c22ec0cf0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>第三条运行完毕<br><img src="https://upload-images.jianshu.io/upload_images/422094-731e922185f6b3c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="reg"><a href="#reg" class="headerlink" title="[reg]"></a>[reg]</h2><p> reg代表寄存器 可以是8个通用寄存器中的任意一个<br><img src="https://upload-images.jianshu.io/upload_images/422094-87c30cc6740e46e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="reg-立即数"><a href="#reg-立即数" class="headerlink" title="[reg+立即数]"></a>[reg+立即数]</h2><p><img src="https://upload-images.jianshu.io/upload_images/422094-1ad3208fdbd6be78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="reg-reg-1-2-4-8"><a href="#reg-reg-1-2-4-8" class="headerlink" title="[reg+reg*{1,2,4,8}]"></a>[reg+reg*{1,2,4,8}]</h2><p><img src="https://upload-images.jianshu.io/upload_images/422094-e0b24931e13a828e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>注意这里只能是1、2、4、8，不能是其他的任何数字</p></blockquote><h2 id="reg-reg-1-2-4-8-立即数"><a href="#reg-reg-1-2-4-8-立即数" class="headerlink" title="[reg+reg*{1,2,4,8}+立即数]"></a>[reg+reg*{1,2,4,8}+立即数]</h2><p><img src="https://upload-images.jianshu.io/upload_images/422094-73eff49484669993.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 滴水逆向三期视频教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滴水逆向 </tag>
            
            <tag> 汇编 </tag>
            
            <tag> 内存读写 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python爬虫005：本地代理proxy请求</title>
      <link href="/2018/12/15/study-python%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B-2018-12-15-python%E7%88%AC%E8%99%AB005%EF%BC%9A%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%90%86proxy/"/>
      <url>/2018/12/15/study-python%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B-2018-12-15-python%E7%88%AC%E8%99%AB005%EF%BC%9A%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%90%86proxy/</url>
      
        <content type="html"><![CDATA[<h1 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line">data=<span class="string">"first=true&amp;p=1&amp;kd=python"</span></span><br><span class="line">header=&#123;<span class="string">'User-Agent'</span>:<span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36'</span>&#125;</span><br><span class="line">request = urllib2.Request(<span class="string">"https://www.lagou.com/jobs/positionAjax.json"</span>,headers=header)</span><br><span class="line">request.add_data(data) <span class="comment">#这行代码就决定了这是一个post请求</span></span><br><span class="line"><span class="keyword">print</span> urllib2.urlopen(request).read()</span><br></pre></td></tr></table></figure><blockquote><p>这段是模拟拉勾网的请求，但是返回的提示一直是请求过去频繁。说明代码还是有问题的</p></blockquote><h1 id="postcgi"><a href="#postcgi" class="headerlink" title="postcgi"></a>postcgi</h1><p>暂时不明白，感觉应该是一种post协议吧。希望知道者告知，感激不尽。</p><h1 id="为什么有些post请求也可以在url开到请求的的数据？"><a href="#为什么有些post请求也可以在url开到请求的的数据？" class="headerlink" title="为什么有些post请求也可以在url开到请求的的数据？"></a>为什么有些post请求也可以在url开到请求的的数据？</h1><p>待解决中，只知道确实是有些post请求参数也是现实的url中</p>]]></content>
      
      
      <categories>
          
          <category> python分布式爬虫教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> post </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python爬虫004：模拟手机百度请求</title>
      <link href="/2018/12/15/study-python%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B-2018-12-15-python%E7%88%AC%E8%99%AB004%EF%BC%9A%E6%A8%A1%E6%8B%9F%E6%89%8B%E6%9C%BA%E7%99%BE%E5%BA%A6%E8%AF%B7%E6%B1%82/"/>
      <url>/2018/12/15/study-python%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B-2018-12-15-python%E7%88%AC%E8%99%AB004%EF%BC%9A%E6%A8%A1%E6%8B%9F%E6%89%8B%E6%9C%BA%E7%99%BE%E5%BA%A6%E8%AF%B7%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line">data=<span class="string">"first=true&amp;p=1&amp;kd=python"</span></span><br><span class="line">header=&#123;<span class="string">'User-Agent'</span>:<span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36'</span>&#125;</span><br><span class="line">request = urllib2.Request(<span class="string">"https://www.lagou.com/jobs/positionAjax.json"</span>,headers=header)</span><br><span class="line">request.add_data(data) <span class="comment">#这行代码就决定了这是一个post请求</span></span><br><span class="line"><span class="keyword">print</span> urllib2.urlopen(request).read()</span><br></pre></td></tr></table></figure><blockquote><p>这段是模拟拉勾网的请求，但是返回的提示一直是请求过去频繁。说明代码还是有问题的</p></blockquote><h1 id="postcgi"><a href="#postcgi" class="headerlink" title="postcgi"></a>postcgi</h1><p>暂时不明白，感觉应该是一种post协议吧。希望知道者告知，感激不尽。</p><h1 id="为什么有些post请求也可以在url开到请求的的数据？"><a href="#为什么有些post请求也可以在url开到请求的的数据？" class="headerlink" title="为什么有些post请求也可以在url开到请求的的数据？"></a>为什么有些post请求也可以在url开到请求的的数据？</h1><p>待解决中，只知道确实是有些post请求参数也是现实的url中</p>]]></content>
      
      
      <categories>
          
          <category> python分布式爬虫教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> 手机代理proxy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python爬虫003：urllib post请求</title>
      <link href="/2018/12/15/study-python%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B-2018-12-15-python%E7%88%AC%E8%99%AB003%EF%BC%9Aurllib-post%E8%AF%B7%E6%B1%82/"/>
      <url>/2018/12/15/study-python%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B-2018-12-15-python%E7%88%AC%E8%99%AB003%EF%BC%9Aurllib-post%E8%AF%B7%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line">data=<span class="string">"first=true&amp;p=1&amp;kd=python"</span></span><br><span class="line">header=&#123;<span class="string">'User-Agent'</span>:<span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36'</span>&#125;</span><br><span class="line">request = urllib2.Request(<span class="string">"https://www.lagou.com/jobs/positionAjax.json"</span>,headers=header)</span><br><span class="line">request.add_data(data) <span class="comment">#这行代码就决定了这是一个post请求</span></span><br><span class="line"><span class="keyword">print</span> urllib2.urlopen(request).read()</span><br></pre></td></tr></table></figure><blockquote><p>这段是模拟拉勾网的请求，但是返回的提示一直是请求过去频繁。说明代码还是有问题的</p></blockquote><h1 id="postcgi"><a href="#postcgi" class="headerlink" title="postcgi"></a>postcgi</h1><p>暂时不明白，感觉应该是一种post协议吧。希望知道者告知，感激不尽。</p><h1 id="为什么有些post请求也可以在url开到请求的的数据？"><a href="#为什么有些post请求也可以在url开到请求的的数据？" class="headerlink" title="为什么有些post请求也可以在url开到请求的的数据？"></a>为什么有些post请求也可以在url开到请求的的数据？</h1><p>待解决中，只知道确实是有些post请求参数也是现实的url中</p>]]></content>
      
      
      <categories>
          
          <category> python分布式爬虫教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> post </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python爬虫002：代理user-agent和response信息、get请求</title>
      <link href="/2018/12/14/study-python%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B-2018-12-14-python%E7%88%AC%E8%99%AB002-%E4%BB%A3%E7%90%86user-agent%E5%92%8Cresponse%E4%BF%A1%E6%81%AF%E3%80%81get%E8%AF%B7%E6%B1%82/"/>
      <url>/2018/12/14/study-python%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B-2018-12-14-python%E7%88%AC%E8%99%AB002-%E4%BB%A3%E7%90%86user-agent%E5%92%8Cresponse%E4%BF%A1%E6%81%AF%E3%80%81get%E8%AF%B7%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="response网络详细信息"><a href="#response网络详细信息" class="headerlink" title="response网络详细信息"></a>response网络详细信息</h1><p><strong>python2中urllib和urllib2的区别</strong><br>参考地址：<a href="https://blog.csdn.net/qq_34327480/article/details/79161794" target="_blank" rel="noopener">https://blog.csdn.net/qq_34327480/article/details/79161794</a></p><blockquote><p>在python2中，urllib和urllib2都是接受URL请求的相关模块，但是提供了不同的功能。两个最显著的不同如下：<br>1、urllib2可以接受一个Request类的实例来设置URL请求的headers<br>2、urllib仅可以接受URL。这意味着，你不可以伪装你的User Agent字符串等。</p></blockquote><h2 id="python3使用urllib"><a href="#python3使用urllib" class="headerlink" title="python3使用urllib"></a>python3使用urllib</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#py3</span></span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="comment">#pycharm go declaration to search source code</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(url)</span>:</span></span><br><span class="line">  response = urllib.request.urlopen(url, timeout = <span class="number">5</span>) </span><br><span class="line"></span><br><span class="line">print(type(response))<span class="comment"># class http.client.httpresponse</span></span><br><span class="line">print(response.info()) <span class="comment">#class  http.client.HTTPMessage</span></span><br><span class="line">print(download(<span class="string">"http://ww.baidu.com"</span>))</span><br></pre></td></tr></table></figure><h2 id="python2使用urllib2"><a href="#python2使用urllib2" class="headerlink" title="python2使用urllib2"></a>python2使用urllib2</h2><p>python2里面没有urllib.reqeust,我们直接用urllib2替换即可<br>还有开头的<code>coding:utf-8</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#py2</span></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(url)</span>:</span></span><br><span class="line">  response = urllib2.urlopen(url, timeout = <span class="number">5</span>) </span><br><span class="line">  print(type(response))<span class="comment"># class http.client.httpresponse</span></span><br><span class="line">  print(response.info()) <span class="comment">#包含了网站的详细信息</span></span><br><span class="line">  print(response.read()) <span class="comment">#read source coad</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#括号内是控制多少字符的问题</span></span><br><span class="line"><span class="comment">#写爬虫记得try catch</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  print(download(<span class="string">"http://ww.google.com"</span>))</span><br><span class="line"><span class="keyword">except</span> urllib2.URLError <span class="keyword">as</span> e:</span><br><span class="line">  print(<span class="string">"网络异常"</span>, e) <span class="comment">#抓住错误对象类型当作变量</span></span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import urllib2</span><br><span class="line">req = urllib2.Request(&apos;http://www.example.com/&apos;)</span><br><span class="line">req.add_header(&apos;Referer&apos;, &apos;http://www.python.org/&apos;)</span><br><span class="line"># Customize the default User-Agent header value:</span><br><span class="line">req.add_header(&apos;User-Agent&apos;, &apos;urllib-example/0.1 (Contact: . . .)&apos;)</span><br><span class="line">r = urllib2.urlopen(req)</span><br></pre></td></tr></table></figure></p><h2 id="response信息"><a href="#response信息" class="headerlink" title="response信息"></a>response信息</h2><p>再贴一下打印response.info()的信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Bdpagetype: 1</span><br><span class="line">Bdqid: 0xe33c14ce00005740</span><br><span class="line">Cache-Control: private</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Cxy_all: baidu+7b2f0340f919578bfe3264aa8c0016f8</span><br><span class="line">Date: Sun, 02 Dec 2018 03:03:24 GMT</span><br><span class="line">Expires: Sun, 02 Dec 2018 03:03:01 GMT</span><br><span class="line">P3p: CP=&quot; OTI DSP COR IVA OUR IND COM &quot;</span><br><span class="line">Server: BWS/1.1</span><br><span class="line">Set-Cookie: BAIDUID=00813CE4F82EFFA6488DB896F424E587:FG=1; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com</span><br><span class="line">Set-Cookie: BIDUPSID=00813CE4F82EFFA6488DB896F424E587; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com</span><br><span class="line">Set-Cookie: PSTM=1543719804; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com</span><br><span class="line">Set-Cookie: delPer=0; path=/; domain=.baidu.com</span><br><span class="line">Set-Cookie: BDSVRTM=0; path=/</span><br><span class="line">Set-Cookie: BD_HOME=0; path=/</span><br><span class="line">Set-Cookie: H_PS_PSSID=1441_25810_21122_22159; path=/; domain=.baidu.com</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">X-Ua-Compatible: IE=Edge,chrome=1</span><br><span class="line">Connection: close</span><br><span class="line">Transfer-Encoding: chunked</span><br></pre></td></tr></table></figure></p><p>注意参数里面有一个<code>Bdqid</code>,这是百度给每个用户的唯一标识</p><h3 id="response-read"><a href="#response-read" class="headerlink" title="response.read()"></a>response.read()</h3><p>查看全部网页源代码</p><h3 id="response-read-100"><a href="#response-read-100" class="headerlink" title="response.read(100)"></a>response.read(100)</h3><p>查看网页源代码的前100个字节</p><p>写爬虫的时候多家try，catch</p><h1 id="agent"><a href="#agent" class="headerlink" title="agent"></a>agent</h1><p>就像大会狼冒充大白兔<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(url)</span>:</span></span><br><span class="line">  headers = &#123;<span class="string">"User Agent : "</span>&#125;</span><br><span class="line">  request = urllib2.Request(url, headers = headers) <span class="comment">#发起请求</span></span><br><span class="line">  data = urllib2.urlopen(request).read() <span class="comment">#打开请求，抓取数据</span></span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">url = <span class="string">"https://sou.zhaopin.com/?jl=613&amp;kw="</span> + searchname + <span class="string">"&amp;kt=3"</span></span><br><span class="line"><span class="keyword">print</span> download(url)</span><br></pre></td></tr></table></figure></p><blockquote><p>上面这段代码构造了一个request，在python2的情况下</p></blockquote><h2 id="常见的代理"><a href="#常见的代理" class="headerlink" title="常见的代理"></a>常见的代理</h2><p>手机代理<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">safariiOS4<span class="number">.33</span>–iPhone</span><br><span class="line">User-Agent:Mozilla/<span class="number">5.0</span>(iPhone;U;CPUiPhoneOS4_3_3likeMacOSX;en-us)AppleWebKit/<span class="number">533.17</span><span class="number">.9</span>(KHTML,likeGecko)Version/<span class="number">5.0</span><span class="number">.2</span>Mobile/<span class="number">8J</span>2Safari/<span class="number">6533.18</span><span class="number">.5</span></span><br><span class="line">safariiOS4<span class="number">.33</span>–iPodTouch</span><br><span class="line">User-Agent:Mozilla/<span class="number">5.0</span>(iPod;U;CPUiPhoneOS4_3_3likeMacOSX;en-us)AppleWebKit/<span class="number">533.17</span><span class="number">.9</span>(KHTML,likeGecko)Version/<span class="number">5.0</span><span class="number">.2</span>Mobile/<span class="number">8J</span>2Safari/<span class="number">6533.18</span><span class="number">.5</span></span><br><span class="line">safariiOS4<span class="number">.33</span>–iPad</span><br><span class="line">User-Agent:Mozilla/<span class="number">5.0</span>(iPad;U;CPUOS4_3_3likeMacOSX;en-us)AppleWebKit/<span class="number">533.17</span><span class="number">.9</span>(KHTML,likeGecko)Version/<span class="number">5.0</span><span class="number">.2</span>Mobile/<span class="number">8J</span>2Safari/<span class="number">6533.18</span><span class="number">.5</span></span><br><span class="line">AndroidN1</span><br><span class="line">User-Agent:Mozilla/<span class="number">5.0</span>(Linux;U;Android2<span class="number">.3</span><span class="number">.7</span>;en-us;NexusOneBuild/FRF91)AppleWebKit/<span class="number">533.1</span>(KHTML,likeGecko)Version/<span class="number">4.0</span>MobileSafari/<span class="number">533.1</span></span><br><span class="line">AndroidQQ浏览器Forandroid</span><br><span class="line">User-Agent:MQQBrowser/<span class="number">26</span>Mozilla/<span class="number">5.0</span>(Linux;U;Android2<span class="number">.3</span><span class="number">.7</span>;zh-cn;MB200Build/GRJ22;CyanogenMod<span class="number">-7</span>)AppleWebKit/<span class="number">533.1</span>(KHTML,likeGecko)Version/<span class="number">4.0</span>MobileSafari/<span class="number">533.1</span></span><br><span class="line">AndroidOperaMobile</span><br><span class="line">User-Agent:Opera/<span class="number">9.80</span>(Android2<span class="number">.3</span><span class="number">.4</span>;Linux;OperaMobi/build<span class="number">-1107180945</span>;U;en-GB)Presto/<span class="number">2.8</span><span class="number">.149</span>Version/<span class="number">11.10</span></span><br><span class="line">AndroidPadMotoXoom</span><br><span class="line">User-Agent:Mozilla/<span class="number">5.0</span>(Linux;U;Android3<span class="number">.0</span>;en-us;XoomBuild/HRI39)AppleWebKit/<span class="number">534.13</span>(KHTML,likeGecko)Version/<span class="number">4.0</span>Safari/<span class="number">534.13</span></span><br><span class="line">BlackBerry</span><br><span class="line">User-Agent:Mozilla/<span class="number">5.0</span>(BlackBerry;U;BlackBerry9800;en)AppleWebKit/<span class="number">534.1</span>+(KHTML,likeGecko)Version/<span class="number">6.0</span><span class="number">.0</span><span class="number">.337</span>MobileSafari/<span class="number">534.1</span>+</span><br><span class="line">WebOSHPTouchpad</span><br><span class="line">User-Agent:Mozilla/<span class="number">5.0</span>(hp-tablet;Linux;hpwOS/<span class="number">3.0</span><span class="number">.0</span>;U;en-US)AppleWebKit/<span class="number">534.6</span>(KHTML,likeGecko)wOSBrowser/<span class="number">233.70</span>Safari/<span class="number">534.6</span>TouchPad/<span class="number">1.0</span></span><br><span class="line">NokiaN97</span><br><span class="line">User-Agent:Mozilla/<span class="number">5.0</span>(SymbianOS/<span class="number">9.4</span>;Series60/<span class="number">5.0</span>NokiaN97<span class="number">-1</span>/<span class="number">20.0</span><span class="number">.019</span>;Profile/MIDP<span class="number">-2.1</span>Configuration/CLDC<span class="number">-1.1</span>)AppleWebKit/<span class="number">525</span>(KHTML,likeGecko)BrowserNG/<span class="number">7.1</span><span class="number">.18124</span></span><br><span class="line">WindowsPhoneMango</span><br><span class="line">User-Agent:Mozilla/<span class="number">5.0</span>(compatible;MSIE9<span class="number">.0</span>;WindowsPhoneOS7<span class="number">.5</span>;Trident/<span class="number">5.0</span>;IEMobile/<span class="number">9.0</span>;HTC;Titan)</span><br><span class="line">UC无</span><br><span class="line">User-Agent:UCWEB7<span class="number">.0</span><span class="number">.2</span><span class="number">.37</span>/<span class="number">28</span>/<span class="number">999</span></span><br><span class="line">UC标准</span><br><span class="line">User-Agent:NOKIA5700/UCWEB7<span class="number">.0</span><span class="number">.2</span><span class="number">.37</span>/<span class="number">28</span>/<span class="number">999</span></span><br><span class="line">UCOpenwave</span><br><span class="line">User-Agent:Openwave/UCWEB7<span class="number">.0</span><span class="number">.2</span><span class="number">.37</span>/<span class="number">28</span>/<span class="number">999</span></span><br><span class="line">UCOpera</span><br><span class="line">User-Agent:Mozilla/<span class="number">4.0</span>(compatible;MSIE6<span class="number">.0</span>;)Opera/UCWEB7<span class="number">.0</span><span class="number">.2</span><span class="number">.37</span>/<span class="number">28</span>/<span class="number">999</span></span><br></pre></td></tr></table></figure></p><p>电脑代理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">safari5.1–MAC</span><br><span class="line">User-Agent:Mozilla/5.0(Macintosh;U;IntelMacOSX10_6_8;en-us)AppleWebKit/534.50(KHTML,likeGecko)Version/5.1Safari/534.50</span><br><span class="line">safari5.1–Windows</span><br><span class="line">User-Agent:Mozilla/5.0(Windows;U;WindowsNT6.1;en-us)AppleWebKit/534.50(KHTML,likeGecko)Version/5.1Safari/534.50</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">IE9.0</span><br><span class="line">User-Agent:Mozilla/5.0(compatible;MSIE9.0;WindowsNT6.1;Trident/5.0</span><br><span class="line">IE8.0</span><br><span class="line">User-Agent:Mozilla/4.0(compatible;MSIE8.0;WindowsNT6.0;Trident/4.0)</span><br><span class="line">IE7.0</span><br><span class="line">User-Agent:Mozilla/4.0(compatible;MSIE7.0;WindowsNT6.0)</span><br><span class="line">IE6.0</span><br><span class="line">User-Agent:Mozilla/4.0(compatible;MSIE6.0;WindowsNT5.1)</span><br><span class="line">Firefox4.0.1–MAC</span><br><span class="line">User-Agent:Mozilla/5.0(Macintosh;IntelMacOSX10.6;rv:2.0.1)Gecko/20100101Firefox/4.0.1</span><br><span class="line">Firefox4.0.1–Windows</span><br><span class="line">User-Agent:Mozilla/5.0(WindowsNT6.1;rv:2.0.1)Gecko/20100101Firefox/4.0.1</span><br><span class="line">Opera11.11–MAC</span><br><span class="line">User-Agent:Opera/9.80(Macintosh;IntelMacOSX10.6.8;U;en)Presto/2.8.131Version/11.11</span><br><span class="line">Opera11.11–Windows</span><br><span class="line">User-Agent:Opera/9.80(WindowsNT6.1;U;en)Presto/2.8.131Version/11.11</span><br><span class="line">Chrome17.0–MAC</span><br><span class="line">User-Agent:Mozilla/5.0(Macintosh;IntelMacOSX10_7_0)AppleWebKit/535.11(KHTML,likeGecko)Chrome/17.0.963.56Safari/535.11</span><br><span class="line">傲游（Maxthon）</span><br><span class="line">User-Agent:Mozilla/4.0(compatible;MSIE7.0;WindowsNT5.1;Maxthon2.0)</span><br><span class="line">腾讯TT</span><br><span class="line">User-Agent:Mozilla/4.0(compatible;MSIE7.0;WindowsNT5.1;TencentTraveler4.0)</span><br><span class="line">世界之窗（TheWorld）2.x</span><br><span class="line">User-Agent:Mozilla/4.0(compatible;MSIE7.0;WindowsNT5.1)</span><br><span class="line">世界之窗（TheWorld）3.x</span><br><span class="line">User-Agent:Mozilla/4.0(compatible;MSIE7.0;WindowsNT5.1;TheWorld)</span><br><span class="line">搜狗浏览器1.x</span><br><span class="line">User-Agent:Mozilla/4.0(compatible;MSIE7.0;WindowsNT5.1;Trident/4.0;SE2.XMetaSr1.0;SE2.XMetaSr1.0;.NETCLR2.0.50727;SE2.XMetaSr1.0)</span><br><span class="line">360浏览器</span><br><span class="line">User-Agent:Mozilla/4.0(compatible;MSIE7.0;WindowsNT5.1;360SE)</span><br><span class="line">Avant</span><br><span class="line">User-Agent:Mozilla/4.0(compatible;MSIE7.0;WindowsNT5.1;AvantBrowser)</span><br><span class="line">GreenBrowser</span><br><span class="line">User-Agent:Mozilla/4.0(compatible;MSIE7.0;WindowsNT5.1)</span><br></pre></td></tr></table></figure></p><h2 id="模拟手机浏览器"><a href="#模拟手机浏览器" class="headerlink" title="模拟手机浏览器"></a>模拟手机浏览器</h2><h1 id="get模拟百度请求"><a href="#get模拟百度请求" class="headerlink" title="get模拟百度请求"></a>get模拟百度请求</h1><h3 id="urllib的编码和解码"><a href="#urllib的编码和解码" class="headerlink" title="urllib的编码和解码"></a>urllib的编码和解码</h3><p>浏览器的地址栏经常看到乱码的情况，这就是编码的问题<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">words=&#123;<span class="string">'wd'</span>:<span class="string">'徐晓峰'</span>&#125;</span><br><span class="line">urllib.urlencode(words) <span class="comment">#'wd=%E5%BE%90%E6%99%93%E5%B3%B0',注意这里是urllib不是urllib2</span></span><br></pre></td></tr></table></figure></p><pre><code class="python"><span class="comment">#coding:urf-8</span><span class="keyword">import</span> urllib<span class="keyword">import</span> urllib2url = <span class="string">'http://www.baidu.com/s'</span>word = {<span class="string">'wd'</span>:<span class="string">'徐晓峰'</span>}newurl = url+<span class="string">'?'</span>+urllib.urlencoding(word)reqeust = urllib2.Request(newurl)request.add_header(<span class="string">"Connection"</span>:<span class="string">"keep-alive"</span>) <span class="comment">#可以自由的添加头信息</span><span class="keyword">print</span> urllib2.urlopen(request).read()</code></pre>]]></content>
      
      
      <categories>
          
          <category> python分布式爬虫教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python爬虫001：python urllib读取网页</title>
      <link href="/2018/12/14/study-python%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B-2018-12-14-python%E7%88%AC%E8%99%AB001%EF%BC%9Aurllib%E8%AF%BB%E5%8F%96%E7%BD%91%E9%A1%B5/"/>
      <url>/2018/12/14/study-python%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B-2018-12-14-python%E7%88%AC%E8%99%AB001%EF%BC%9Aurllib%E8%AF%BB%E5%8F%96%E7%BD%91%E9%A1%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="正则表达式re"><a href="#正则表达式re" class="headerlink" title="正则表达式re"></a>正则表达式re</h1><p>加<code>()</code>,代表我们需要括号里面的东西<br>不加<code>()</code>,表示全部内容我们都需要<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">mystr = <span class="string">"""&lt;span class \"search_yx_t j\"&gt;</span></span><br><span class="line"><span class="string">  共&lt;em&gt;5830&lt;/em&gt;个职位满足条件</span></span><br><span class="line"><span class="string">  &lt;span&gt;"""</span></span><br><span class="line"></span><br><span class="line">restr = <span class="string">"&lt;em&gt;(\\d+)&lt;/em&gt;"</span><span class="comment">#d+表示和数字有关；():只要里面的对象</span></span><br><span class="line">regex = re.compile(restr, re, IGNORECASE)</span><br><span class="line">mylist = regex.findall(mystr)</span><br></pre></td></tr></table></figure></p><h1 id="读取网页的三种方式"><a href="#读取网页的三种方式" class="headerlink" title="读取网页的三种方式"></a>读取网页的三种方式</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#py2</span></span><br><span class="line"><span class="comment">#enconding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"></span><br><span class="line">url = <span class="string">"http://www.baidu.com"</span><span class="comment">#urlopen只能处理http，不可以处理https</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download1</span><span class="params">(url)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> urllib2.urlopen(url).read()<span class="comment">#读取全部网页</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download2</span><span class="params">(url)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> urllib2.urlopen(url).readlines()<span class="comment">#读取每一行的网页数据，然后压入列表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download3</span><span class="params">(url)</span>:</span></span><br><span class="line">  response = urllib2.orlopen(url)<span class="comment">#网页抽象为文件</span></span><br><span class="line">  <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    line = response.readline()<span class="comment">#读取一行</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> line:</span><br><span class="line">      <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h1 id="python2-和python3的区别"><a href="#python2-和python3的区别" class="headerlink" title="python2 和python3的区别"></a>python2 和python3的区别</h1><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>一般抓取英文数据用python2，抓取带中文的数据，就需要用python3</p><p>用python2打印中文是，需要在第一行<code>encoding:utf-8</code></p><h2 id="urllib2"><a href="#urllib2" class="headerlink" title="urllib2"></a>urllib2</h2><p>获取一个网页数据，urllib在python2和python3中有不同的表示</p><ul><li><p>python2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">urllib2.urlopen(url).read()</span><br><span class="line"><span class="comment"># urllib2只可以处理http，不可以处理https</span></span><br></pre></td></tr></table></figure></li><li><p>python3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">urllib2.request(url).read()</span><br></pre></td></tr></table></figure></li></ul><h1 id="python被网站屏蔽：referer"><a href="#python被网站屏蔽：referer" class="headerlink" title="python被网站屏蔽：referer"></a>python被网站屏蔽：referer</h1><p>有时候我们请求服务器的时候，服务器可以知道通过请求头中的<code>referer</code>参数，知道是谁在请求它<br>服务器如果发现不是浏览器在请求他，二是python在请求他。直接502.可以直接拒绝我们的请求。</p><h1 id="selenium"><a href="#selenium" class="headerlink" title="selenium"></a>selenium</h1><p>我们需要这个东西来模拟浏览器。selenium可以操作我们的浏览器</p><h1 id="抓取智联招聘"><a href="#抓取智联招聘" class="headerlink" title="抓取智联招聘"></a>抓取智联招聘</h1><p>基于selenium库和selenium.webdriver<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> selenium <span class="comment">#测试框架</span></span><br><span class="line"><span class="keyword">import</span> selennium.webdriver <span class="comment">#模拟浏览器</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">mystr = <span class="string">"""&lt;span class \"search_yx_t j\"&gt;</span></span><br><span class="line"><span class="string">  共&lt;em&gt;5830&lt;/em&gt;个职位满足条件</span></span><br><span class="line"><span class="string">  &lt;span&gt;"""</span></span><br><span class="line"></span><br><span class="line">restr = <span class="string">"&lt;em&gt;(\\d+)&lt;/em&gt;"</span><span class="comment">#d+表示和数字有关；():只要里面的对象</span></span><br><span class="line">regex = re.compile(restr, re. IGNORECASE)</span><br><span class="line">mylist = regex.findall(pagesource)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getnumberbyname</span><span class="params">(searchname)</span>:</span></span><br><span class="line">  url = <span class="string">"https://sou.zhaopin.com/?jl=613&amp;kw="</span> + searchname + <span class="string">"&amp;kt=3"</span></span><br><span class="line">  driver = selenium.webdriver.Firefox() <span class="comment">#调用火狐浏览器</span></span><br><span class="line">  driver.get(url) <span class="comment">#访问链接</span></span><br><span class="line">  pagesource = driver.page_source <span class="comment">#抓取网页源代码</span></span><br><span class="line">  driver.close()<span class="comment">#关闭</span></span><br><span class="line">  <span class="keyword">return</span> mylist[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># print getnumberbyname("python") 这是测试函数</span></span><br><span class="line"></span><br><span class="line">pythonlist = [<span class="string">"python"</span>, <span class="string">"python 运维"</span>, <span class="string">"python 测试"</span>, <span class="string">"python 数据"</span>, <span class="string">"python web"</span>]</span><br><span class="line"><span class="keyword">for</span> oystr <span class="keyword">in</span> pythonlist:</span><br><span class="line">  <span class="keyword">print</span> pystr, getnumberbyname(pystr)</span><br></pre></td></tr></table></figure></p><h1 id="抓取51job"><a href="#抓取51job" class="headerlink" title="抓取51job"></a>抓取51job</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> selenium <span class="comment">#测试框架</span></span><br><span class="line"><span class="keyword">import</span> selennium.webdriver <span class="comment">#模拟浏览器</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">mystr = <span class="string">"""&lt;div class = "rt"&gt;</span></span><br><span class="line"><span class="string">  共67条职位</span></span><br><span class="line"><span class="string">  &lt;\div&gt;"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getnumberbyname</span><span class="params">(searchname)</span>:</span> <span class="comment">#可能这里有一些混乱，手头没有python环境就没测试，大致就先这样吧</span></span><br><span class="line"> url=<span class="string">"https://search.51job.com/list/240200,000000,0000,00,9,99,"</span>+searchname +<span class="string">",2,1.htmllang=c&amp;stype=&amp;postchannel=0000&amp;workyear=99&amp;cotype=99&amp;degefrom=99&amp;jobterm=99&amp;companysize=99&amp;providesalary=99&amp;lonlat=0%2C0&amp;adius=-1&amp;ord_field=0&amp;confirmdate=9&amp;fromType=&amp;dibiaoid=0&amp;address=&amp;lin=&amp;specialarea=00&amp;from=&amp;welfare=</span></span><br><span class="line"><span class="string"> driver = selenium.webdriver.Firefox() #调用火狐浏览器</span></span><br><span class="line"><span class="string"> driver.get(url) #访问链接</span></span><br><span class="line"><span class="string"> pagesource = driver.page_source #抓取网页源代码</span></span><br><span class="line"><span class="string"> restr = "</span><span class="string">""</span>(\\d+)<span class="string">""" #先抓大，再抓小；尤其是空白字 符出现的时候</span></span><br><span class="line"><span class="string"> regex = re.compile(restr, re.IGNORECASE)</span></span><br><span class="line"><span class="string"> mylist = regex.findall(pagesource)</span></span><br><span class="line"><span class="string"> newstr = mylist[0].strip()</span></span><br><span class="line"><span class="string"> driver.close()#关闭</span></span><br><span class="line"><span class="string"> return mylist[0]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">pythonlist = ["python", "python 运维", "python 测试", "python 数据", "python web"]</span></span><br><span class="line"><span class="string">for oystr in pythonlist:</span></span><br><span class="line"><span class="string">  print pystr, getnumberbyname(pystr)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python分布式爬虫教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> urllib </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>内存读写</title>
      <link href="/2018/12/13/study-%E7%BC%96%E7%A8%8B%E8%BE%BE%E4%BA%BA-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%913%E6%9C%9F%E5%AD%A6%E4%B9%A0-2018-12-13-%E5%86%85%E5%AD%98%E8%AF%BB%E5%86%99/"/>
      <url>/2018/12/13/study-%E7%BC%96%E7%A8%8B%E8%BE%BE%E4%BA%BA-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%913%E6%9C%9F%E5%AD%A6%E4%B9%A0-2018-12-13-%E5%86%85%E5%AD%98%E8%AF%BB%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么需要内存？"><a href="#为什么需要内存？" class="headerlink" title="为什么需要内存？"></a>为什么需要内存？</h1><p>如果我们只需要这样的计算：<code>1+2=?</code> ,我们当然不需要内存。<br>如果有十亿个数相加呢？寄存器明显不够用。所以就需要内存了</p><blockquote><p>这里所说的<em>内存</em> 严格意义上并不是 <em>内存条</em> ，但是现在可以这样理解，内存就在内存条中，内存条提供了一个很大的容器</p></blockquote><blockquote><p>从存储角度来看的话，寄存器和内存条没有什么区别，都是容器，都存储着一些列0、1这样的数字。</p></blockquote><h1 id="寄存器和内存的区别"><a href="#寄存器和内存的区别" class="headerlink" title="寄存器和内存的区别"></a>寄存器和内存的区别</h1><p><img src="https://upload-images.jianshu.io/upload_images/422094-d32a191d47d89040.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h1 id="如何定位内存？"><a href="#如何定位内存？" class="headerlink" title="如何定位内存？"></a>如何定位内存？</h1><blockquote><p>问题引出：<br>cpu寄存器的数量是有限的，我们可以给每一个寄存器定义名字。但是内存很大，我们如何定义，方便我们找到呢？</p></blockquote><h2 id="32位、64位计算机"><a href="#32位、64位计算机" class="headerlink" title="32位、64位计算机"></a>32位、64位计算机</h2><blockquote><p>32位计算机：<br>误解：<em>cpu寄存器的最大宽度是32位，所以是32位计算机</em>。这种说法是不对的。32位指的是寻址编号。<br>就是说计算机内部有32根线，每根线都可以代表0和1，每根线变化一下，就可以得到一个地址，就可以根据这个地址找到<strong>一块</strong>内存。32根线，也就是32位，就是寻找内存的范围。也就是寻址范围。<br>这里的<strong>一块</strong>指的是<code>8bit | 1byte</code></p></blockquote><p>根据寻址范围，我们就相当于给内存起好编号了。<br><strong>注意</strong><br>编号都是以字节为单位.<br><img src="https://upload-images.jianshu.io/upload_images/422094-78efb19f54ee657b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="计算最大内存"><a href="#计算最大内存" class="headerlink" title="计算最大内存"></a>计算最大内存</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">32位计算机：</span><br><span class="line">2^32个内存编号，一个内存编号代表1byte</span><br><span class="line">2^32 byte</span><br><span class="line">2^32 / 1024 = 2^32 / 2^10 =2^22 KB</span><br><span class="line">2^22 / 1024 = 2^22 / 2^10 = 2^12 MB</span><br><span class="line">2^12 / 1024 = 2^12 / 2^10 = 2^2 GB = 4GB</span><br><span class="line">即使这里是4GB，不过一般我们看到的内存都是小于4GB的，这是有些系统固件会占用一部分内存。</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/422094-1bcf3db093c1ada2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>这个问题仔细扣是不对的。因为计算机还可以扩展内存，正常情况下，计算如果按照32位的寻址规则的话，是4GB，但是计算机也可以打破这个寻址规则。其实，如何寻址，都是计算机自己内部定义的。</p><h1 id="内存读写"><a href="#内存读写" class="headerlink" title="内存读写"></a>内存读写</h1><h2 id="内存的格式"><a href="#内存的格式" class="headerlink" title="内存的格式"></a>内存的格式</h2><p><img src="https://upload-images.jianshu.io/upload_images/422094-5dbca01e8bbe0f92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>内存的读写至少都是8位。涉及到内存，记住单位就是byte</p><h2 id="内存地址和立即数"><a href="#内存地址和立即数" class="headerlink" title="内存地址和立即数"></a>内存地址和立即数</h2><p><code>mov 0x12345678,0xFFFF</code><br>这条指令中，<code>0x12345678</code>到底是立即数，还是内存地址。<br>不好区分，所以规定，我们用 <code>[]</code>来表示内存<br><code>mov [0x12345678],0xFFFF</code><br>上面这条指令还是不好（不是不对）？</p><blockquote><p>因为<code>0x12345678</code> 表示<code>1byte</code>,而<code>0xFFFF</code>是<code>2 byte</code>.<br>内存不像寄存器，超过的会直接抛弃，所以我们应该指定宽度，下面就是标准格式。</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/422094-5436e14782e2acbe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h1><p><em>每个应用程序打开时，都会有一个4GB的空间</em><br>DTDebug打开一个应用<br><img src="https://upload-images.jianshu.io/upload_images/422094-6433ea7fffa6af2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>先认识一下我们的工具。</p><blockquote><p>说明几点：</p><ol><li>寄存器ESP一般就是用来处理堆栈的</li><li>右下角的堆栈区，我们初学者可以把他理解为内存</li></ol></blockquote><h2 id="内存写"><a href="#内存写" class="headerlink" title="内存写"></a>内存写</h2><p><code>MOV DWORD PTR DS:[8FFFFFFF],0x12345678</code><br>执行报错。<br><em>每个应用程序打开时，都会有一个4GB的空间</em>，但是有部分地址我们时无法访问的。</p><p>怎么知道我们可以访问的地址呢？寄存器ESP中存放的地址肯定时可以访问的。<br><img src="https://upload-images.jianshu.io/upload_images/422094-782e16126967c968.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>我们更改一下指令<br><code>MOV DWORD PTR DS:[0x0019FF74],0x12345678</code><br>执行<br><img src="https://upload-images.jianshu.io/upload_images/422094-87dd467b2a5d8773.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>可以看到已经写入了。<br>还有一个细节：<br><code>[0x0019FF74]</code>是1byte的地址，可是我们写入<code>0x12345678</code>,4byte,怎么回事？<br>注意看堆栈区的内存标号：<br><img src="https://upload-images.jianshu.io/upload_images/422094-68a45ac4761971f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>每四个才显示一个内存标号。<br>其实我们的<code>0x12345678</code>是存在4个内存标号里的。</p><h2 id="内存读"><a href="#内存读" class="headerlink" title="内存读"></a>内存读</h2><p><code>MOV EAX,DWORD PTR DS:[0x13FFC4]</code><br>`</p>]]></content>
      
      
      <categories>
          
          <category> 滴水逆向三期视频教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滴水逆向 </tag>
            
            <tag> 汇编 </tag>
            
            <tag> 内存读写 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>进一步学习寄存器</title>
      <link href="/2018/12/12/study-%E7%BC%96%E7%A8%8B%E8%BE%BE%E4%BA%BA-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%913%E6%9C%9F%E5%AD%A6%E4%B9%A0-2018-12-12-%E8%BF%9B%E4%B8%80%E6%AD%A5%E5%AD%A6%E4%B9%A0%E5%AF%84%E5%AD%98%E5%99%A8/"/>
      <url>/2018/12/12/study-%E7%BC%96%E7%A8%8B%E8%BE%BE%E4%BA%BA-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%913%E6%9C%9F%E5%AD%A6%E4%B9%A0-2018-12-12-%E8%BF%9B%E4%B8%80%E6%AD%A5%E5%AD%A6%E4%B9%A0%E5%AF%84%E5%AD%98%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="寄存器的种类"><a href="#寄存器的种类" class="headerlink" title="寄存器的种类"></a>寄存器的种类</h1><p>现代计算机中，寄存器都是由CPU提供的，寄存器就在cpu里面。<br>计算器按照存储宽度可以划分如下：<br><img src="https://upload-images.jianshu.io/upload_images/422094-ad2352acca70b58d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="寄存器的分类"></p><p>说明几点</p><blockquote><p>1.不同的寄存器有不同的功能，这个我们暂时先不用管</p><ol start="2"><li>寄存器是随着硬件不断发展变化的。现在已经有64位的寄存器了，将来可能还会有128位的寄存器</li></ol></blockquote><h1 id="寄存器的结构"><a href="#寄存器的结构" class="headerlink" title="寄存器的结构"></a>寄存器的结构</h1><p><img src="https://upload-images.jianshu.io/upload_images/422094-d243b96061f29295.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="寄存器的结构"><br>可以看到，32位的寄存器中是嵌套着1个16位的寄存器，16位的寄存器嵌套着两个八位的寄存器。</p><blockquote><p>大家可以找找规律，16位的寄存器名称就是把32位寄存器名称中的E给去掉了。而8位的寄存器，把16位寄存器划分为高位和低位，高位用H（high）表示，低位用L（lower）表示。</p></blockquote><p>为什么要设计成这种嵌套关系？</p><blockquote><p>1.硬件不断发展的原因。将来要增加64位的寄存器，直接套在32位上就可以。既可以保持兼容，有可以自由扩展</p><ol start="2"><li>存储不浪费。寄存器已经到32位了，我要存储8位的数据，那我们使用8位寄存器就可以。剩下的空间就可以给其他数据使用。</li></ol></blockquote><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p>我们可以通过mov指令来演示一下这种嵌套关系<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#指令如下</span><br><span class="line">mov eax,0xAAAAAAAA</span><br><span class="line">mov ax,0xBBBB</span><br><span class="line">mov al,0xEE</span><br><span class="line">mov ah,0xHH</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/422094-9e51ebc18e96279f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>连续4次F8，执行4次。结果以此如下图：<br><img src="https://upload-images.jianshu.io/upload_images/422094-0ed3ade2b93327fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/422094-894815fdee5621ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/422094-16232de601b0346a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/422094-9bde64c42af54a11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>根据这个实验，大家就能形象出寄存器的结构</p><h1 id="mov指令的用法"><a href="#mov指令的用法" class="headerlink" title="mov指令的用法"></a>mov指令的用法</h1><h2 id="立即数的概念"><a href="#立即数的概念" class="headerlink" title="立即数的概念"></a>立即数的概念</h2><blockquote><p>通常把在立即寻址方式指令中给出的数称为立即数。<br>立即数可以是8位、16位或32位，该数值紧跟在操作码之后<br><code>mov eax,0xAAAAAAAA</code> 中 <code>0xAAAAAAAA</code>就是立即数</p></blockquote><h2 id="mov指令的用法-1"><a href="#mov指令的用法-1" class="headerlink" title="mov指令的用法"></a>mov指令的用法</h2><p><img src="https://upload-images.jianshu.io/upload_images/422094-089b67f75e222879.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>根据语法，我们可以写这样的指令<br><code>mov eax,0xAAAAAAAA</code><br>还可以写这样的指令<br><code>mov eax,ebx</code><br><img src="https://upload-images.jianshu.io/upload_images/422094-e5bbeb1f0c0b9565.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>注意这里的mov和我们linux系统的mov是不一样的，linux系统的move是移动，而这里mov是拷贝</p></blockquote><h1 id="几个简单指令"><a href="#几个简单指令" class="headerlink" title="几个简单指令"></a>几个简单指令</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ADD 指令：加</span><br><span class="line">SUB 指令：减</span><br><span class="line">AND指令：逻辑与</span><br><span class="line">OR指令：逻辑或</span><br><span class="line">NOT指令：逻辑非</span><br><span class="line">XOR指令：逻辑异或</span><br></pre></td></tr></table></figure><h2 id="ADD指令演示"><a href="#ADD指令演示" class="headerlink" title="ADD指令演示"></a>ADD指令演示</h2><p>ADD指令是源操作数与目标操作数进行逻辑与运算，运算结果再放到目标地址中<br>我们写这样两条命令<br><img src="https://upload-images.jianshu.io/upload_images/422094-ae745a84f6b6440a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>按F8后，发现eax中值为2，符合我们的预期<br><img src="https://upload-images.jianshu.io/upload_images/422094-1ab30915ebafdf39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>再按F8后<br><img src="https://upload-images.jianshu.io/upload_images/422094-4023c18f6b8749eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>是没有执行吗？<br>不是，如图<br><img src="https://upload-images.jianshu.io/upload_images/422094-8abdfd10ccdf896a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>我们可以再增加一体语句<code>or eax,3</code><br><img src="https://upload-images.jianshu.io/upload_images/422094-888882dc38847c1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>执行后结果如图：<br><img src="https://upload-images.jianshu.io/upload_images/422094-ea96ccde72a26dda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 滴水逆向三期视频教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滴水逆向 </tag>
            
            <tag> 汇编 </tag>
            
            <tag> 通用寄存器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>通用寄存器和初识汇编</title>
      <link href="/2018/12/11/study-%E7%BC%96%E7%A8%8B%E8%BE%BE%E4%BA%BA-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%913%E6%9C%9F%E5%AD%A6%E4%B9%A0-2018-12-11-%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C%E5%88%9D%E8%AF%86%E6%B1%87%E7%BC%96/"/>
      <url>/2018/12/11/study-%E7%BC%96%E7%A8%8B%E8%BE%BE%E4%BA%BA-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%913%E6%9C%9F%E5%AD%A6%E4%B9%A0-2018-12-11-%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C%E5%88%9D%E8%AF%86%E6%B1%87%E7%BC%96/</url>
      
        <content type="html"><![CDATA[<h1 id="寄存器初识"><a href="#寄存器初识" class="headerlink" title="寄存器初识"></a>寄存器初识</h1><p>不论如何存储，在计算机中，我们存储的都是0和1。<br>再熟悉一点计算机的组成，我们就会知道，cpu和硬盘中都可以存储，我们可以理解为cpu和硬盘中都有一些容器。<br>cpu中比较通用的就是 <code>32位通用寄存器</code></p><h2 id="32位通用寄存器的功能如下"><a href="#32位通用寄存器的功能如下" class="headerlink" title="32位通用寄存器的功能如下"></a>32位通用寄存器的功能如下</h2><p><img src="https://upload-images.jianshu.io/upload_images/422094-e1ffdfc03d835b20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>这个需要我们牢牢的记住，但是我们也应该知道两点</p><ol><li>说是寄存器，其实就是一个容器</li><li>这里所说的寄存器的主要功能，其实是操作系统给我们的建议功能。就像我们买一个牙刷缸，建议的功能肯定是刷牙。但是你非要用来喝茶，也是没有关系的。</li></ol><h1 id="学习汇编"><a href="#学习汇编" class="headerlink" title="学习汇编"></a>学习汇编</h1><h2 id="准备开发工具"><a href="#准备开发工具" class="headerlink" title="准备开发工具"></a>准备开发工具</h2><p>我们使用滴水推荐的DTdebug工具。<br><a href="https://pan.baidu.com/s/1ck1ii_lsV9ZsAs-4FdjLmA" target="_blank" rel="noopener">https://pan.baidu.com/s/1ck1ii_lsV9ZsAs-4FdjLmA</a><br>这个是绿色软件，下载解压后直接打开就可以。<br>注意两点</p><blockquote><p>1.以管理身份运行</p><ol start="2"><li>需要配置一下options<br><img src="https://upload-images.jianshu.io/upload_images/422094-1965bd0af72ec5dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>这两个存储目录分别对应，我们解压后udd和plugin目录。</li></ol></blockquote><h2 id="DTdebug界面"><a href="#DTdebug界面" class="headerlink" title="DTdebug界面"></a>DTdebug界面</h2><p>file -&gt; open ,打开一个.exe文件，就可以看到各种汇编代码。</p><p><img src="https://upload-images.jianshu.io/upload_images/422094-915c773b866e4a6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>看右边，registers界面，就可以看到我们刚才说的32位通用寄存器中的几个容器。</p><h2 id="EIP寄存器"><a href="#EIP寄存器" class="headerlink" title="EIP寄存器"></a>EIP寄存器</h2><p><img src="https://upload-images.jianshu.io/upload_images/422094-b886c979558c64bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="EIP"><br>我们可以看到，左边黑色就表示cpu当前执行的位置，右边的EIP中位置和左边的相同，说明EIP中存储的就是当前程序的执行位置。</p><h2 id="发送指令"><a href="#发送指令" class="headerlink" title="发送指令"></a>发送指令</h2><p>我们在左边的随意一个命令中双击，就会跳出操作指令的窗口。<br><img src="https://upload-images.jianshu.io/upload_images/422094-49da3af2283eccb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="操作指令"><br>输入指令后，点击<code>Assemble</code>，就会执行相应的指令。</p><h2 id="mov指令"><a href="#mov指令" class="headerlink" title="mov指令"></a>mov指令</h2><p>汇编指令都是由 <code>操作码+操作数</code> 组成。<br><code>mov，* 0x12</code><br>就是把十六进制数<code>0x12</code> 移动到寄存器 *中。</p><p>汇编学习，往后继续</p>]]></content>
      
      
      <categories>
          
          <category> 滴水逆向三期视频教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滴水逆向 </tag>
            
            <tag> 汇编 </tag>
            
            <tag> 通用寄存器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据的宽度和逻辑运算</title>
      <link href="/2018/12/10/study-%E7%BC%96%E7%A8%8B%E8%BE%BE%E4%BA%BA-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%913%E6%9C%9F%E5%AD%A6%E4%B9%A0-2018-12-10-%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AE%BD%E5%BA%A6%E7%9A%84%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97/"/>
      <url>/2018/12/10/study-%E7%BC%96%E7%A8%8B%E8%BE%BE%E4%BA%BA-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%913%E6%9C%9F%E5%AD%A6%E4%B9%A0-2018-12-10-%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AE%BD%E5%BA%A6%E7%9A%84%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="数据的宽度"><a href="#数据的宽度" class="headerlink" title="数据的宽度"></a>数据的宽度</h1><p>我们需要知道，无论是我们平时看到的视频(avi,mp4)，还是图片png，jpg，在计算机中存储的时候，都是存储为0，1这个符号。</p><p>在之前我们的学习中，我们经常会听到原码、反码、补码等消息，这都是后人总结出来的一些概念，计算机本质是没有这些的。</p><p>就比如说有符号整型和无符号整型，计算机只知道自己存储的是0和1，是使用它的人自己规定这个是有符号还是无符号的。</p><blockquote><p>我们先把存储比作是容器，如果容器只能装16 bit，比如我们存了一个数<code>ffff</code>,我们再给这个数加1，会变成什么？</p></blockquote><p>答案是0.计算机和真实的世界是不一样的，存不下的时候，直接抛弃。</p><blockquote><p>在有符号数据中，为什么用1表示负数？</p></blockquote><p>这都是使用这个数字的人决定的，计算机并不知道自己存储的是负数。</p><h2 id="几个重要的计量单位-数据宽度"><a href="#几个重要的计量单位-数据宽度" class="headerlink" title="几个重要的计量单位(数据宽度)"></a>几个重要的计量单位(数据宽度)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 byte = 8 bit</span><br><span class="line">1 word = 16 bit</span><br><span class="line">1 dword = 32 bit</span><br></pre></td></tr></table></figure><h1 id="二进制的逻辑运算"><a href="#二进制的逻辑运算" class="headerlink" title="二进制的逻辑运算"></a>二进制的逻辑运算</h1><p>逻辑运算就是CPU计算的本质，汇编语言并不是cpu计算的本质。（这块就设计到了电路的知识）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">或 or |</span><br><span class="line">与 and &amp;</span><br><span class="line">异或 xor ^</span><br><span class="line">非  not ！</span><br></pre></td></tr></table></figure><blockquote><p>or，and，xor，not就是汇编语言的表示</p></blockquote><h2 id="CPU是如何计算2-3-？"><a href="#CPU是如何计算2-3-？" class="headerlink" title="CPU是如何计算2+3=？"></a>CPU是如何计算2+3=？</h2><p>先用一个容器X：存放二进制的2：0010<br>在用一个容器Y：存放二进制的3：0011<br><img src="https://upload-images.jianshu.io/upload_images/422094-28b0924e661c3965.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>然后再用一个容器R：存放0010和0011异或的结果。<br>CPU需要判断容器R中是否是最终的结果，是否还需要继续运算。怎么判断呢？<br><img src="https://upload-images.jianshu.io/upload_images/422094-1179798e070e1821.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>让0010和0011进行与运算，与运算的结果向左移一位，<code>&lt;&lt;1</code> ,如果结果是0，那说明上面容器R中的就是真正的结果。</p><p>如果不是0，就是容器R中的值放到X中，把刚才判断得到的结果放到Y中，重复上面的操作。</p><p><img src="https://upload-images.jianshu.io/upload_images/422094-8ab2be60425d089a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="逻辑运算的两个应用"><a href="#逻辑运算的两个应用" class="headerlink" title="逻辑运算的两个应用"></a>逻辑运算的两个应用</h2><blockquote><p>判断某个值第N位的值是多少？</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/422094-dbab7b6d6436d689.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>比如我们要判断第四位的值是多少，我们就构造一个第四位是1的数，然后与这个数进行与运算。如果结果<code>&gt;0</code>,表明第四位是1，不然第四位是0.<br>因为我们构造的数除了第四位是1，其他都是0.与运算的话，除了第四位，其他的肯定都是0.</p>]]></content>
      
      
      <categories>
          
          <category> 滴水逆向三期视频教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滴水逆向 </tag>
            
            <tag> 汇编 </tag>
            
            <tag> 逻辑运算 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>汇编、进制学习</title>
      <link href="/2018/12/09/study-%E7%BC%96%E7%A8%8B%E8%BE%BE%E4%BA%BA-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%913%E6%9C%9F%E5%AD%A6%E4%B9%A0-2018-12-09-%E6%B1%87%E7%BC%96%E3%80%81%E8%BF%9B%E5%88%B6/"/>
      <url>/2018/12/09/study-%E7%BC%96%E7%A8%8B%E8%BE%BE%E4%BA%BA-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%913%E6%9C%9F%E5%AD%A6%E4%B9%A0-2018-12-09-%E6%B1%87%E7%BC%96%E3%80%81%E8%BF%9B%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>视频教程地址：<a href="https://www.bcdaren.com/330281569183076352/video_content.html" target="_blank" rel="noopener">https://www.bcdaren.com/330281569183076352/video_content.html</a></p><h1 id="进制的概念"><a href="#进制的概念" class="headerlink" title="进制的概念"></a>进制的概念</h1><blockquote><p>二进制：由两个符号组成，分别用0和1表示，逢二进一。</p></blockquote><blockquote><p>四进制：由四个符号组成，分别用0、1、2、3表示，逢四进一。</p></blockquote><blockquote><p>八进制：由8个符号组成，分别用0、1、2、3、4、5、6、7表示，逢八进一。</p></blockquote><blockquote><p>十六进制：由16个符号组成，分别用0、1、2。。。。8、9、A、B、C、D、E、F表示，逢十六进一</p></blockquote><p>由此我们可以得出。<br>n进制：由n个符号组成，分别用n个符号表示，逢n进一。</p><h2 id="忽略的地方"><a href="#忽略的地方" class="headerlink" title="忽略的地方"></a>忽略的地方</h2><p>表示8进制，我们就用0-8，8个数字来表示，那我们能不能用八个图片来表示？八个表情呢？</p><blockquote><p>答案是肯定的，我们可以用任何的符号来表示，并不局限于8个数字</p></blockquote><p>用别的符号表示，有什么作用呢？</p><blockquote><p>这就涉及到密码学的问题了，比如两个人商量好，用微笑😊表情表示1，用伤心💔的表情表示0。那我收到两个微笑，两个伤心。😊😊💔💔，我就知道你发的是1100.但是别人就不只知道。<br>如果我们在自己的项目中运用了自定义的元素，别人还以为我们运用了多么高深的加密算法。</p></blockquote><h1 id="进制的转化"><a href="#进制的转化" class="headerlink" title="进制的转化"></a>进制的转化</h1><p>在以往的概念中，我们一般都是通过10进制作为中间桥梁来进行进制转化。这是没有必要的。往后，我们只需要熟练掌握二进制和16进制之间的转化就可以了。</p><h2 id="2进制和16进制-进制转化表"><a href="#2进制和16进制-进制转化表" class="headerlink" title="2进制和16进制-进制转化表"></a>2进制和16进制-进制转化表</h2><table><thead><tr><th>二进制</th><th style="text-align:center">十六进制</th><th style="text-align:right">十进制</th></tr></thead><tbody><tr><td>0000</td><td style="text-align:center">00</td><td style="text-align:right">0</td></tr><tr><td>0001</td><td style="text-align:center">01</td><td style="text-align:right">1</td></tr><tr><td>0010</td><td style="text-align:center">02</td><td style="text-align:right">2</td></tr><tr><td>0011</td><td style="text-align:center">03</td><td style="text-align:right">3</td></tr><tr><td>0100</td><td style="text-align:center">04</td><td style="text-align:right">4</td></tr><tr><td>0101</td><td style="text-align:center">05</td><td style="text-align:right">5</td></tr><tr><td>0110</td><td style="text-align:center">06</td><td style="text-align:right">6</td></tr><tr><td>0111</td><td style="text-align:center">07</td><td style="text-align:right">7</td></tr><tr><td>1000</td><td style="text-align:center">08</td><td style="text-align:right">8</td></tr><tr><td>1001</td><td style="text-align:center">09</td><td style="text-align:right">9</td></tr><tr><td>1010</td><td style="text-align:center">0A</td><td style="text-align:right">10</td></tr><tr><td>1011</td><td style="text-align:center">0B</td><td style="text-align:right">11</td></tr><tr><td>1100</td><td style="text-align:center">0C</td><td style="text-align:right">12</td></tr><tr><td>1101</td><td style="text-align:center">0D</td><td style="text-align:right">13</td></tr><tr><td>1110</td><td style="text-align:center">0E</td><td style="text-align:right">14</td></tr><tr><td>1111</td><td style="text-align:center">0F</td><td style="text-align:right">15</td></tr></tbody></table><h1 id="进制的运算"><a href="#进制的运算" class="headerlink" title="进制的运算"></a>进制的运算</h1><p>当我们10进制运算16+9的时候，我们可以脱口而出25.我们是怎么做到的？仔细想了想，使我们从小就记住了两张表，一张加法运算表，一张乘法运算表。<br>对于其他进制的运算，以往我们都是转化为10进制，来回转，最后算出结果。但这都偏离了进制的本质。</p><p>要想进行进制的运算，我们首先也应该构建两张表。然后进制的运算，我们就是单纯的查表。你说查表麻烦？那你可以选择把它记住，10进制的乘法表，大家不就是已经记住了吗？</p><blockquote><p>我们就以八进制为例</p></blockquote><h2 id="加法表的构建"><a href="#加法表的构建" class="headerlink" title="加法表的构建"></a>加法表的构建</h2><p>想要构建加法表，我们首先应该按照8进制从0写道100。<br>0+1 ，我们就从0开始往后数1，就是1<br>1+3，我们就从1开始往后数3，就是4<br>6+4，我们就从4开始往后数4，就是7，10，11，12 ，就是12了</p><p>依次类推我们就会构建出八进制的加法表</p><h2 id="乘法表的构建"><a href="#乘法表的构建" class="headerlink" title="乘法表的构建"></a>乘法表的构建</h2><p>乘法表，当然是从加法表构建出来的。</p><p>2✖3，就是3+3，或者2+2+2=4+2，我们在加法表中一查就会知道结果</p><p>一次类推，我们也可以得出乘法表。</p><h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><blockquote><p>加法表，乘法表都是单位数，那多位数的加减乘除该如何运算？</p></blockquote><p>多位数的加法我们可以参照加法表<br>多位数的乘法我们可以参照乘法表<br>多位数的减法，我们可以参照减法表<br>多位数的除法，我们可以参照乘法表</p><blockquote><p>但是切记，进制的运算，我们完全可以在其内部完成，不用在十进制之间来回转换。</p></blockquote><h1 id="自定义三进制的表示"><a href="#自定义三进制的表示" class="headerlink" title="自定义三进制的表示"></a>自定义三进制的表示</h1><p>涉及到自定义符号的时候，我们一定要注意，0，1，2，3这些都不是数字，只是一个符号</p><blockquote><p>如果我们用2，0，1分别表示三进制的三个元素，三进制表则可以表示如下。<br>不要觉得很简单哦，自己能写出来才知道自己会不会</p></blockquote><table><thead><tr><th></th><th style="text-align:center"></th><th style="text-align:right"></th><th>说明</th></tr></thead><tbody><tr><td>2</td><td style="text-align:center">0</td><td style="text-align:right">1</td><td></td></tr><tr><td>02</td><td style="text-align:center">00</td><td style="text-align:right">01</td><td>能得出02就厉害了</td></tr><tr><td>12</td><td style="text-align:center">10</td><td style="text-align:right">11</td><td>注意进位的时候</td></tr><tr><td>022</td><td style="text-align:center">020</td><td style="text-align:right">021</td></tr></tbody></table><p>我们要彻底忘掉十进制的概念，彻底忘掉0，1，2，3的概念。切记，0，1，2，3只是符号，而不是数字</p>]]></content>
      
      
      <categories>
          
          <category> 滴水逆向三期视频教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滴水逆向 </tag>
            
            <tag> 汇编 </tag>
            
            <tag> 进制 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>真的会有那么两个人</title>
      <link href="/2018/12/08/personal-2018-12-08-%E7%9C%9F%E7%9A%84%E4%BC%9A%E6%9C%89%E4%B8%A4%E4%B8%AA%E4%BA%BA/"/>
      <url>/2018/12/08/personal-2018-12-08-%E7%9C%9F%E7%9A%84%E4%BC%9A%E6%9C%89%E4%B8%A4%E4%B8%AA%E4%BA%BA/</url>
      
        <content type="html"><![CDATA[<p>后来我发现，原来真的会有两个人，互相喜欢，互相惦记，互相忘不掉，确实不能在一起。忘不掉，放不下，却又回不去。</p>]]></content>
      
      
      <categories>
          
          <category> 个人 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回忆 </tag>
            
            <tag> 心灵 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>连回忆都留不住</title>
      <link href="/2018/12/06/personal-2018-12-06-%E8%BF%9E%E5%9B%9E%E5%BF%86%E9%83%BD%E7%95%99%E4%B8%8D%E4%BD%8F/"/>
      <url>/2018/12/06/personal-2018-12-06-%E8%BF%9E%E5%9B%9E%E5%BF%86%E9%83%BD%E7%95%99%E4%B8%8D%E4%BD%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>百年孤独里说，无论走到哪里，都应该记住，过去都是假的，回忆是一条没有尽头的路。一切以往的春天都不复从来。就连那最坚韧而又狂乱的爱情归根结底也不过是一种转瞬即逝的现实。</p></blockquote><p>感觉每天有好多东西要写，可以搭建博客之后，反而不知道自己要写什么了。</p><p>马上就要搬到上海了，工作上的调用。想到搬家，我很痛苦，那几天走在路上都是彷徨的。不过这几天我想通了，反正孤身一人，反正一无所有，反正也没有去过上海。那就走吧。</p><p>女朋友还在读研，前段时间来京几日。买了不少生活用品，女孩了总是喜欢买，不过这样才更有生活的气息。在搬走之前，把属于她的东西都寄给她。收拾屋子的时候，好多觉得用不到的东西都会扔掉，每件东西都有的她的气息，每件东西后面都有她的影子。不能给她一个家，连回忆都保留不住。深深伤感。</p>]]></content>
      
      
      <categories>
          
          <category> 个人 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回忆 </tag>
            
            <tag> 心灵 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
